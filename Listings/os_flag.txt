; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\os_flag.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_flag.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\os_flag.crf UCOSII\CORE\os_flag.c]
                          THUMB

                          AREA ||i.OSFlagAccept||, CODE, READONLY, ALIGN=1

                  OSFlagAccept PROC
;;;91     #if OS_FLAG_ACCEPT_EN > 0u
;;;92     OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;93                             OS_FLAGS      flags,
;;;94                             INT8U         wait_type,
;;;95                             INT8U        *perr)
;;;96     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;97         OS_FLAGS      flags_rdy;
;;;98         INT8U         result;
;;;99         BOOLEAN       consume;
;;;100    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;101        OS_CPU_SR     cpu_sr = 0u;
00000c  f04f0b00          MOV      r11,#0
;;;102    #endif
;;;103    
;;;104    
;;;105    
;;;106    #ifdef OS_SAFETY_CRITICAL
;;;107        if (perr == (INT8U *)0) {
;;;108            OS_SAFETY_CRITICAL_EXCEPTION();
;;;109        }
;;;110    #endif
;;;111    
;;;112    #if OS_ARG_CHK_EN > 0u
;;;113        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;114            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;115            return ((OS_FLAGS)0);
;;;116        }
;;;117    #endif
;;;118        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d004              BEQ      |L1.32|
;;;119            *perr = OS_ERR_EVENT_TYPE;
000016  2001              MOVS     r0,#1
000018  7030              STRB     r0,[r6,#0]
;;;120            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L1.28|
;;;121        }
;;;122        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;123        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;124            wait_type &= ~OS_FLAG_CONSUME;
;;;125            consume    = OS_TRUE;
;;;126        } else {
;;;127            consume    = OS_FALSE;
;;;128        }
;;;129    /*$PAGE*/
;;;130        *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
;;;131        OS_ENTER_CRITICAL();
;;;132        switch (wait_type) {
;;;133            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;134                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;135                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;136                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;137                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
;;;138                     }
;;;139                 } else {
;;;140                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;141                 }
;;;142                 OS_EXIT_CRITICAL();
;;;143                 break;
;;;144    
;;;145            case OS_FLAG_WAIT_SET_ANY:
;;;146                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;147                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;148                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;149                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
;;;150                     }
;;;151                 } else {
;;;152                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;153                 }
;;;154                 OS_EXIT_CRITICAL();
;;;155                 break;
;;;156    
;;;157    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;158            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;159                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;160                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;161                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;162                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;163                     }
;;;164                 } else {
;;;165                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;166                 }
;;;167                 OS_EXIT_CRITICAL();
;;;168                 break;
;;;169    
;;;170            case OS_FLAG_WAIT_CLR_ANY:
;;;171                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;172                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;173                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;174                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;175                     }
;;;176                 } else {
;;;177                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;178                 }
;;;179                 OS_EXIT_CRITICAL();
;;;180                 break;
;;;181    #endif
;;;182    
;;;183            default:
;;;184                 OS_EXIT_CRITICAL();
;;;185                 flags_rdy = (OS_FLAGS)0;
;;;186                 *perr     = OS_ERR_FLAG_WAIT_TYPE;
;;;187                 break;
;;;188        }
;;;189        return (flags_rdy);
;;;190    }
00001c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.32|
000020  f0090a80          AND      r10,r9,#0x80          ;122
000024  f1ba0f00          CMP      r10,#0                ;123
000028  d004              BEQ      |L1.52|
00002a  f0290980          BIC      r9,r9,#0x80           ;124
00002e  f04f0801          MOV      r8,#1                 ;125
000032  e001              B        |L1.56|
                  |L1.52|
000034  f04f0800          MOV      r8,#0                 ;127
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;130
00003a  7030              STRB     r0,[r6,#0]            ;130
00003c  f7fffffe          BL       OS_CPU_SR_Save
000040  4683              MOV      r11,r0                ;131
000042  f1b90f00          CMP      r9,#0                 ;132
000046  d02c              BEQ      |L1.162|
000048  f1b90f01          CMP      r9,#1                 ;132
00004c  d03b              BEQ      |L1.198|
00004e  f1b90f02          CMP      r9,#2                 ;132
000052  d003              BEQ      |L1.92|
000054  f1b90f03          CMP      r9,#3                 ;132
000058  d146              BNE      |L1.232|
00005a  e011              B        |L1.128|
                  |L1.92|
00005c  8920              LDRH     r0,[r4,#8]            ;134
00005e  ea000507          AND      r5,r0,r7              ;134
000062  42bd              CMP      r5,r7                 ;135
000064  d106              BNE      |L1.116|
000066  f1b80f01          CMP      r8,#1                 ;136
00006a  d105              BNE      |L1.120|
00006c  8920              LDRH     r0,[r4,#8]            ;137
00006e  43a8              BICS     r0,r0,r5              ;137
000070  8120              STRH     r0,[r4,#8]            ;137
000072  e001              B        |L1.120|
                  |L1.116|
000074  2070              MOVS     r0,#0x70              ;140
000076  7030              STRB     r0,[r6,#0]            ;140
                  |L1.120|
000078  4658              MOV      r0,r11                ;142
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  e03a              B        |L1.246|
                  |L1.128|
000080  8920              LDRH     r0,[r4,#8]            ;146
000082  ea000507          AND      r5,r0,r7              ;146
000086  b135              CBZ      r5,|L1.150|
000088  f1b80f01          CMP      r8,#1                 ;148
00008c  d105              BNE      |L1.154|
00008e  8920              LDRH     r0,[r4,#8]            ;149
000090  43a8              BICS     r0,r0,r5              ;149
000092  8120              STRH     r0,[r4,#8]            ;149
000094  e001              B        |L1.154|
                  |L1.150|
000096  2070              MOVS     r0,#0x70              ;152
000098  7030              STRB     r0,[r6,#0]            ;152
                  |L1.154|
00009a  4658              MOV      r0,r11                ;154
00009c  f7fffffe          BL       OS_CPU_SR_Restore
0000a0  e029              B        |L1.246|
                  |L1.162|
0000a2  8920              LDRH     r0,[r4,#8]            ;159
0000a4  ea270500          BIC      r5,r7,r0              ;159
0000a8  42bd              CMP      r5,r7                 ;160
0000aa  d106              BNE      |L1.186|
0000ac  f1b80f01          CMP      r8,#1                 ;161
0000b0  d105              BNE      |L1.190|
0000b2  8920              LDRH     r0,[r4,#8]            ;162
0000b4  4328              ORRS     r0,r0,r5              ;162
0000b6  8120              STRH     r0,[r4,#8]            ;162
0000b8  e001              B        |L1.190|
                  |L1.186|
0000ba  2070              MOVS     r0,#0x70              ;165
0000bc  7030              STRB     r0,[r6,#0]            ;165
                  |L1.190|
0000be  4658              MOV      r0,r11                ;167
0000c0  f7fffffe          BL       OS_CPU_SR_Restore
0000c4  e017              B        |L1.246|
                  |L1.198|
0000c6  8920              LDRH     r0,[r4,#8]            ;171
0000c8  ea270500          BIC      r5,r7,r0              ;171
0000cc  b135              CBZ      r5,|L1.220|
0000ce  f1b80f01          CMP      r8,#1                 ;173
0000d2  d105              BNE      |L1.224|
0000d4  8920              LDRH     r0,[r4,#8]            ;174
0000d6  4328              ORRS     r0,r0,r5              ;174
0000d8  8120              STRH     r0,[r4,#8]            ;174
0000da  e001              B        |L1.224|
                  |L1.220|
0000dc  2070              MOVS     r0,#0x70              ;177
0000de  7030              STRB     r0,[r6,#0]            ;177
                  |L1.224|
0000e0  4658              MOV      r0,r11                ;179
0000e2  f7fffffe          BL       OS_CPU_SR_Restore
0000e6  e006              B        |L1.246|
                  |L1.232|
0000e8  4658              MOV      r0,r11                ;184
0000ea  f7fffffe          BL       OS_CPU_SR_Restore
0000ee  2500              MOVS     r5,#0                 ;185
0000f0  206f              MOVS     r0,#0x6f              ;186
0000f2  7030              STRB     r0,[r6,#0]            ;186
0000f4  bf00              NOP                            ;187
                  |L1.246|
0000f6  bf00              NOP                            ;143
0000f8  4628              MOV      r0,r5                 ;189
0000fa  e78f              B        |L1.28|
;;;191    #endif
                          ENDP


                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;213    
;;;214    OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;215                                INT8U    *perr)
;;;216    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;217        OS_FLAG_GRP *pgrp;
;;;218    #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
;;;219        OS_CPU_SR    cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;220    #endif
;;;221    
;;;222    
;;;223    
;;;224    #ifdef OS_SAFETY_CRITICAL
;;;225        if (perr == (INT8U *)0) {
;;;226            OS_SAFETY_CRITICAL_EXCEPTION();
;;;227        }
;;;228    #endif
;;;229    
;;;230    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;231        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;232            OS_SAFETY_CRITICAL_EXCEPTION();
;;;233        }
;;;234    #endif
;;;235    
;;;236        if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00000a  4813              LDR      r0,|L2.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b120              CBZ      r0,|L2.26|
;;;237            *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
000010  2010              MOVS     r0,#0x10
000012  7028              STRB     r0,[r5,#0]
;;;238            return ((OS_FLAG_GRP *)0);
000014  2000              MOVS     r0,#0
                  |L2.22|
;;;239        }
;;;240        OS_ENTER_CRITICAL();
;;;241        pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
;;;242        if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
;;;243                                                        /* Adjust free list                                */
;;;244            OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
;;;245            pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
;;;246            pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
;;;247            pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
;;;248    #if OS_FLAG_NAME_EN > 0u
;;;249            pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;250    #endif
;;;251            OS_EXIT_CRITICAL();
;;;252            *perr                = OS_ERR_NONE;
;;;253        } else {
;;;254            OS_EXIT_CRITICAL();
;;;255            *perr                = OS_ERR_FLAG_GRP_DEPLETED;
;;;256        }
;;;257        return (pgrp);                                  /* Return pointer to event flag group              */
;;;258    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L2.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;240
000020  480e              LDR      r0,|L2.92|
000022  6804              LDR      r4,[r0,#0]            ;241  ; OSFlagFreeList
000024  b184              CBZ      r4,|L2.72|
000026  6800              LDR      r0,[r0,#0]            ;244  ; OSFlagFreeList
000028  6840              LDR      r0,[r0,#4]            ;244
00002a  490c              LDR      r1,|L2.92|
00002c  6008              STR      r0,[r1,#0]            ;244  ; OSFlagFreeList
00002e  2005              MOVS     r0,#5                 ;245
000030  7020              STRB     r0,[r4,#0]            ;245
000032  8126              STRH     r6,[r4,#8]            ;246
000034  2000              MOVS     r0,#0                 ;247
000036  6060              STR      r0,[r4,#4]            ;247
000038  a009              ADR      r0,|L2.96|
00003a  60e0              STR      r0,[r4,#0xc]          ;249
00003c  4638              MOV      r0,r7                 ;251
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  2000              MOVS     r0,#0                 ;252
000044  7028              STRB     r0,[r5,#0]            ;252
000046  e004              B        |L2.82|
                  |L2.72|
000048  4638              MOV      r0,r7                 ;254
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2072              MOVS     r0,#0x72              ;255
000050  7028              STRB     r0,[r5,#0]            ;255
                  |L2.82|
000052  4620              MOV      r0,r4                 ;257
000054  e7df              B        |L2.22|
;;;259    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      OSIntNesting
                  |L2.92|
                          DCD      OSFlagFreeList
                  |L2.96|
000060  3f00              DCB      "?",0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.OSFlagDel||, CODE, READONLY, ALIGN=2

                  OSFlagDel PROC
;;;297    #if OS_FLAG_DEL_EN > 0u
;;;298    OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;299                             INT8U         opt,
;;;300                             INT8U        *perr)
;;;301    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;302        BOOLEAN       tasks_waiting;
;;;303        OS_FLAG_NODE *pnode;
;;;304        OS_FLAG_GRP  *pgrp_return;
;;;305    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;306        OS_CPU_SR     cpu_sr = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;307    #endif
;;;308    
;;;309    
;;;310    
;;;311    #ifdef OS_SAFETY_CRITICAL
;;;312        if (perr == (INT8U *)0) {
;;;313            OS_SAFETY_CRITICAL_EXCEPTION();
;;;314        }
;;;315    #endif
;;;316    
;;;317    #if OS_ARG_CHK_EN > 0u
;;;318        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;319            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;320            return (pgrp);
;;;321        }
;;;322    #endif
;;;323        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00000e  4832              LDR      r0,|L3.216|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  b120              CBZ      r0,|L3.30|
;;;324            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000014  200f              MOVS     r0,#0xf
000016  7028              STRB     r0,[r5,#0]
;;;325            return (pgrp);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;326        }
;;;327        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
;;;328            *perr = OS_ERR_EVENT_TYPE;
;;;329            return (pgrp);
;;;330        }
;;;331        OS_ENTER_CRITICAL();
;;;332        if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
;;;333            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;334        } else {
;;;335            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;336        }
;;;337        switch (opt) {
;;;338            case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
;;;339                 if (tasks_waiting == OS_FALSE) {
;;;340    #if OS_FLAG_NAME_EN > 0u
;;;341                     pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;342    #endif
;;;343                     pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;344                     pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
;;;345                     pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;346                     OSFlagFreeList       = pgrp;
;;;347                     OS_EXIT_CRITICAL();
;;;348                     *perr                = OS_ERR_NONE;
;;;349                     pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
;;;350                 } else {
;;;351                     OS_EXIT_CRITICAL();
;;;352                     *perr                = OS_ERR_TASK_WAITING;
;;;353                     pgrp_return          = pgrp;
;;;354                 }
;;;355                 break;
;;;356    
;;;357            case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
;;;358                 pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;359                 while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
;;;360                     (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
;;;361                     pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
;;;362                 }
;;;363    #if OS_FLAG_NAME_EN > 0u
;;;364                 pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;365    #endif
;;;366                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;367                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
;;;368                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;369                 OSFlagFreeList       = pgrp;
;;;370                 OS_EXIT_CRITICAL();
;;;371                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;372                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;373                 }
;;;374                 *perr = OS_ERR_NONE;
;;;375                 pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
;;;376                 break;
;;;377    
;;;378            default:
;;;379                 OS_EXIT_CRITICAL();
;;;380                 *perr                = OS_ERR_INVALID_OPT;
;;;381                 pgrp_return          = pgrp;
;;;382                 break;
;;;383        }
;;;384        return (pgrp_return);
;;;385    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  7820              LDRB     r0,[r4,#0]            ;327
000020  2805              CMP      r0,#5                 ;327
000022  d003              BEQ      |L3.44|
000024  2001              MOVS     r0,#1                 ;328
000026  7028              STRB     r0,[r5,#0]            ;328
000028  4620              MOV      r0,r4                 ;329
00002a  e7f6              B        |L3.26|
                  |L3.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4682              MOV      r10,r0                ;331
000032  6860              LDR      r0,[r4,#4]            ;332
000034  b108              CBZ      r0,|L3.58|
000036  2701              MOVS     r7,#1                 ;333
000038  e000              B        |L3.60|
                  |L3.58|
00003a  2700              MOVS     r7,#0                 ;335
                  |L3.60|
00003c  f1b90f00          CMP      r9,#0                 ;337
000040  d003              BEQ      |L3.74|
000042  f1b90f01          CMP      r9,#1                 ;337
000046  d13c              BNE      |L3.194|
000048  e019              B        |L3.126|
                  |L3.74|
00004a  b98f              CBNZ     r7,|L3.112|
00004c  a023              ADR      r0,|L3.220|
00004e  60e0              STR      r0,[r4,#0xc]          ;341
000050  2000              MOVS     r0,#0                 ;343
000052  7020              STRB     r0,[r4,#0]            ;343
000054  4822              LDR      r0,|L3.224|
000056  6800              LDR      r0,[r0,#0]            ;344  ; OSFlagFreeList
000058  6060              STR      r0,[r4,#4]            ;344
00005a  2000              MOVS     r0,#0                 ;345
00005c  8120              STRH     r0,[r4,#8]            ;345
00005e  4820              LDR      r0,|L3.224|
000060  6004              STR      r4,[r0,#0]            ;346  ; OSFlagFreeList
000062  4650              MOV      r0,r10                ;347
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2000              MOVS     r0,#0                 ;348
00006a  7028              STRB     r0,[r5,#0]            ;348
00006c  2600              MOVS     r6,#0                 ;349
00006e  e005              B        |L3.124|
                  |L3.112|
000070  4650              MOV      r0,r10                ;351
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2049              MOVS     r0,#0x49              ;352
000078  7028              STRB     r0,[r5,#0]            ;352
00007a  4626              MOV      r6,r4                 ;353
                  |L3.124|
00007c  e028              B        |L3.208|
                  |L3.126|
00007e  f8d48004          LDR      r8,[r4,#4]            ;358
000082  e005              B        |L3.144|
                  |L3.132|
000084  2100              MOVS     r1,#0                 ;360
000086  4640              MOV      r0,r8                 ;360
000088  f7fffffe          BL       OS_FlagTaskRdy
00008c  f8d88000          LDR      r8,[r8,#0]            ;361
                  |L3.144|
000090  f1b80f00          CMP      r8,#0                 ;359
000094  d1f6              BNE      |L3.132|
000096  a011              ADR      r0,|L3.220|
000098  60e0              STR      r0,[r4,#0xc]          ;364
00009a  2000              MOVS     r0,#0                 ;366
00009c  7020              STRB     r0,[r4,#0]            ;366
00009e  4810              LDR      r0,|L3.224|
0000a0  6800              LDR      r0,[r0,#0]            ;367  ; OSFlagFreeList
0000a2  6060              STR      r0,[r4,#4]            ;367
0000a4  2000              MOVS     r0,#0                 ;368
0000a6  8120              STRH     r0,[r4,#8]            ;368
0000a8  480d              LDR      r0,|L3.224|
0000aa  6004              STR      r4,[r0,#0]            ;369  ; OSFlagFreeList
0000ac  4650              MOV      r0,r10                ;370
0000ae  f7fffffe          BL       OS_CPU_SR_Restore
0000b2  2f01              CMP      r7,#1                 ;371
0000b4  d101              BNE      |L3.186|
0000b6  f7fffffe          BL       OS_Sched
                  |L3.186|
0000ba  2000              MOVS     r0,#0                 ;374
0000bc  7028              STRB     r0,[r5,#0]            ;374
0000be  2600              MOVS     r6,#0                 ;375
0000c0  e006              B        |L3.208|
                  |L3.194|
0000c2  4650              MOV      r0,r10                ;379
0000c4  f7fffffe          BL       OS_CPU_SR_Restore
0000c8  2007              MOVS     r0,#7                 ;380
0000ca  7028              STRB     r0,[r5,#0]            ;380
0000cc  4626              MOV      r6,r4                 ;381
0000ce  bf00              NOP                            ;382
                  |L3.208|
0000d0  bf00              NOP                            ;355
0000d2  4630              MOV      r0,r6                 ;384
0000d4  e7a1              B        |L3.26|
;;;386    #endif
                          ENDP

0000d6  0000              DCW      0x0000
                  |L3.216|
                          DCD      OSIntNesting
                  |L3.220|
0000dc  3f00              DCB      "?",0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L3.224|
                          DCD      OSFlagFreeList

                          AREA ||i.OSFlagNameGet||, CODE, READONLY, ALIGN=2

                  OSFlagNameGet PROC
;;;411    #if OS_FLAG_NAME_EN > 0u
;;;412    INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;413                          INT8U        **pname,
;;;414                          INT8U         *perr)
;;;415    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;416        INT8U      len;
;;;417    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;418        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;419    #endif
;;;420    
;;;421    
;;;422    
;;;423    #ifdef OS_SAFETY_CRITICAL
;;;424        if (perr == (INT8U *)0) {
;;;425            OS_SAFETY_CRITICAL_EXCEPTION();
;;;426        }
;;;427    #endif
;;;428    
;;;429    #if OS_ARG_CHK_EN > 0u
;;;430        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;431            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;432            return (0u);
;;;433        }
;;;434        if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;435            *perr = OS_ERR_PNAME_NULL;
;;;436            return (0u);
;;;437        }
;;;438    #endif
;;;439        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4810              LDR      r0,|L4.80|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b120              CBZ      r0,|L4.28|
;;;440            *perr = OS_ERR_NAME_GET_ISR;
000012  2011              MOVS     r0,#0x11
000014  7020              STRB     r0,[r4,#0]
;;;441            return (0u);
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;442        }
;;;443        OS_ENTER_CRITICAL();
;;;444        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;445            OS_EXIT_CRITICAL();
;;;446            *perr = OS_ERR_EVENT_TYPE;
;;;447            return (0u);
;;;448        }
;;;449        *pname = pgrp->OSFlagName;
;;;450        len    = OS_StrLen(*pname);
;;;451        OS_EXIT_CRITICAL();
;;;452        *perr  = OS_ERR_NONE;
;;;453        return (len);
;;;454    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L4.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4607              MOV      r7,r0                 ;443
000022  7828              LDRB     r0,[r5,#0]            ;444
000024  2805              CMP      r0,#5                 ;444
000026  d006              BEQ      |L4.54|
000028  4638              MOV      r0,r7                 ;445
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  2001              MOVS     r0,#1                 ;446
000030  7020              STRB     r0,[r4,#0]            ;446
000032  2000              MOVS     r0,#0                 ;447
000034  e7f0              B        |L4.24|
                  |L4.54|
000036  68e8              LDR      r0,[r5,#0xc]          ;449
000038  6030              STR      r0,[r6,#0]            ;449
00003a  6830              LDR      r0,[r6,#0]            ;450
00003c  f7fffffe          BL       OS_StrLen
000040  4680              MOV      r8,r0                 ;450
000042  4638              MOV      r0,r7                 ;451
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;452
00004a  7020              STRB     r0,[r4,#0]            ;452
00004c  4640              MOV      r0,r8                 ;453
00004e  e7e3              B        |L4.24|
;;;455    #endif
                          ENDP

                  |L4.80|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagNameSet||, CODE, READONLY, ALIGN=2

                  OSFlagNameSet PROC
;;;481    #if OS_FLAG_NAME_EN > 0u
;;;482    void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;483                         INT8U        *pname,
;;;484                         INT8U        *perr)
;;;485    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;486    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;487        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;488    #endif
;;;489    
;;;490    
;;;491    
;;;492    #ifdef OS_SAFETY_CRITICAL
;;;493        if (perr == (INT8U *)0) {
;;;494            OS_SAFETY_CRITICAL_EXCEPTION();
;;;495        }
;;;496    #endif
;;;497    
;;;498    #if OS_ARG_CHK_EN > 0u
;;;499        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;500            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;501            return;
;;;502        }
;;;503        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;504            *perr = OS_ERR_PNAME_NULL;
;;;505            return;
;;;506        }
;;;507    #endif
;;;508        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  480d              LDR      r0,|L5.68|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b118              CBZ      r0,|L5.26|
;;;509            *perr = OS_ERR_NAME_SET_ISR;
000012  2012              MOVS     r0,#0x12
000014  7020              STRB     r0,[r4,#0]
                  |L5.22|
;;;510            return;
;;;511        }
;;;512        OS_ENTER_CRITICAL();
;;;513        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;514            OS_EXIT_CRITICAL();
;;;515            *perr = OS_ERR_EVENT_TYPE;
;;;516            return;
;;;517        }
;;;518        pgrp->OSFlagName = pname;
;;;519        OS_EXIT_CRITICAL();
;;;520        *perr            = OS_ERR_NONE;
;;;521        return;
;;;522    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L5.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;512
000020  7828              LDRB     r0,[r5,#0]            ;513
000022  2805              CMP      r0,#5                 ;513
000024  d005              BEQ      |L5.50|
000026  4638              MOV      r0,r7                 ;514
000028  f7fffffe          BL       OS_CPU_SR_Restore
00002c  2001              MOVS     r0,#1                 ;515
00002e  7020              STRB     r0,[r4,#0]            ;515
000030  e7f1              B        |L5.22|
                  |L5.50|
000032  60ee              STR      r6,[r5,#0xc]          ;518
000034  4638              MOV      r0,r7                 ;519
000036  f7fffffe          BL       OS_CPU_SR_Restore
00003a  2000              MOVS     r0,#0                 ;520
00003c  7020              STRB     r0,[r4,#0]            ;520
00003e  bf00              NOP                            ;521
000040  e7e9              B        |L5.22|
;;;523    #endif
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;579    
;;;580    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;581                          OS_FLAGS      flags,
;;;582                          INT8U         wait_type,
;;;583                          INT32U        timeout,
;;;584                          INT8U        *perr)
;;;585    {
000004  b089              SUB      sp,sp,#0x24
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  9e12              LDR      r6,[sp,#0x48]
;;;586        OS_FLAG_NODE  node;
;;;587        OS_FLAGS      flags_rdy;
;;;588        INT8U         result;
;;;589        INT8U         pend_stat;
;;;590        BOOLEAN       consume;
;;;591    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;592        OS_CPU_SR     cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;593    #endif
;;;594    
;;;595    
;;;596    
;;;597    #ifdef OS_SAFETY_CRITICAL
;;;598        if (perr == (INT8U *)0) {
;;;599            OS_SAFETY_CRITICAL_EXCEPTION();
;;;600        }
;;;601    #endif
;;;602    
;;;603    #if OS_ARG_CHK_EN > 0u
;;;604        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;605            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;606            return ((OS_FLAGS)0);
;;;607        }
;;;608    #endif
;;;609        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000014  488c              LDR      r0,|L6.584|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000018  b128              CBZ      r0,|L6.38|
;;;610            *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00001a  2002              MOVS     r0,#2
00001c  7030              STRB     r0,[r6,#0]
;;;611            return ((OS_FLAGS)0);
00001e  2000              MOVS     r0,#0
                  |L6.32|
;;;612        }
;;;613        if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
;;;614            *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
;;;615            return ((OS_FLAGS)0);
;;;616        }
;;;617        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
;;;618            *perr = OS_ERR_EVENT_TYPE;
;;;619            return ((OS_FLAGS)0);
;;;620        }
;;;621        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;622        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;623            wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
;;;624            consume    = OS_TRUE;
;;;625        } else {
;;;626            consume    = OS_FALSE;
;;;627        }
;;;628    /*$PAGE*/
;;;629        OS_ENTER_CRITICAL();
;;;630        switch (wait_type) {
;;;631            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;632                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
;;;633                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;634                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;635                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
;;;636                     }
;;;637                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;638                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;639                     *perr                   = OS_ERR_NONE;
;;;640                     return (flags_rdy);
;;;641                 } else {                                      /* Block task until events occur or timeout */
;;;642                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;643                     OS_EXIT_CRITICAL();
;;;644                 }
;;;645                 break;
;;;646    
;;;647            case OS_FLAG_WAIT_SET_ANY:
;;;648                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
;;;649                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;650                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;651                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
;;;652                     }
;;;653                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;654                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;655                     *perr                   = OS_ERR_NONE;
;;;656                     return (flags_rdy);
;;;657                 } else {                                      /* Block task until events occur or timeout */
;;;658                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;659                     OS_EXIT_CRITICAL();
;;;660                 }
;;;661                 break;
;;;662    
;;;663    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;664            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;665                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;666                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;667                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;668                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;669                     }
;;;670                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;671                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;672                     *perr                   = OS_ERR_NONE;
;;;673                     return (flags_rdy);
;;;674                 } else {                                      /* Block task until events occur or timeout */
;;;675                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;676                     OS_EXIT_CRITICAL();
;;;677                 }
;;;678                 break;
;;;679    
;;;680            case OS_FLAG_WAIT_CLR_ANY:
;;;681                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;682                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;683                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;684                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;685                     }
;;;686                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;687                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;688                     *perr                   = OS_ERR_NONE;
;;;689                     return (flags_rdy);
;;;690                 } else {                                      /* Block task until events occur or timeout */
;;;691                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;692                     OS_EXIT_CRITICAL();
;;;693                 }
;;;694                 break;
;;;695    #endif
;;;696    
;;;697            default:
;;;698                 OS_EXIT_CRITICAL();
;;;699                 flags_rdy = (OS_FLAGS)0;
;;;700                 *perr      = OS_ERR_FLAG_WAIT_TYPE;
;;;701                 return (flags_rdy);
;;;702        }
;;;703    /*$PAGE*/
;;;704        OS_Sched();                                            /* Find next HPT ready to run               */
;;;705        OS_ENTER_CRITICAL();
;;;706        if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
;;;707            pend_stat                = OSTCBCur->OSTCBStatPend;
;;;708            OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;709            OS_FlagUnlink(&node);
;;;710            OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
;;;711            OS_EXIT_CRITICAL();
;;;712            flags_rdy                = (OS_FLAGS)0;
;;;713            switch (pend_stat) {
;;;714                case OS_STAT_PEND_ABORT:
;;;715                     *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
;;;716                     break;
;;;717    
;;;718                case OS_STAT_PEND_TO:
;;;719                default:
;;;720                     *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
;;;721                     break;
;;;722            }
;;;723            return (flags_rdy);
;;;724        }
;;;725        flags_rdy = OSTCBCur->OSTCBFlagsRdy;
;;;726        if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
;;;727            switch (wait_type) {
;;;728                case OS_FLAG_WAIT_SET_ALL:
;;;729                case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
;;;730                     pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
;;;731                     break;
;;;732    
;;;733    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;734                case OS_FLAG_WAIT_CLR_ALL:
;;;735                case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
;;;736                     pgrp->OSFlagFlags |=  flags_rdy;
;;;737                     break;
;;;738    #endif
;;;739                default:
;;;740                     OS_EXIT_CRITICAL();
;;;741                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;742                     return ((OS_FLAGS)0);
;;;743            }
;;;744        }
;;;745        OS_EXIT_CRITICAL();
;;;746        *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
;;;747        return (flags_rdy);
;;;748    }
000020  b009              ADD      sp,sp,#0x24
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.38|
000026  4889              LDR      r0,|L6.588|
000028  7800              LDRB     r0,[r0,#0]            ;613  ; OSLockNesting
00002a  b118              CBZ      r0,|L6.52|
00002c  200d              MOVS     r0,#0xd               ;614
00002e  7030              STRB     r0,[r6,#0]            ;614
000030  2000              MOVS     r0,#0                 ;615
000032  e7f5              B        |L6.32|
                  |L6.52|
000034  7828              LDRB     r0,[r5,#0]            ;617
000036  2805              CMP      r0,#5                 ;617
000038  d003              BEQ      |L6.66|
00003a  2001              MOVS     r0,#1                 ;618
00003c  7030              STRB     r0,[r6,#0]            ;618
00003e  2000              MOVS     r0,#0                 ;619
000040  e7ee              B        |L6.32|
                  |L6.66|
000042  f0090b80          AND      r11,r9,#0x80          ;621
000046  f1bb0f00          CMP      r11,#0                ;622
00004a  d004              BEQ      |L6.86|
00004c  f009097f          AND      r9,r9,#0x7f           ;623
000050  f04f0801          MOV      r8,#1                 ;624
000054  e001              B        |L6.90|
                  |L6.86|
000056  f04f0800          MOV      r8,#0                 ;626
                  |L6.90|
00005a  f7fffffe          BL       OS_CPU_SR_Save
00005e  9002              STR      r0,[sp,#8]            ;629
000060  f1b90f00          CMP      r9,#0                 ;630
000064  d04a              BEQ      |L6.252|
000066  f1b90f01          CMP      r9,#1                 ;630
00006a  d068              BEQ      |L6.318|
00006c  f1b90f02          CMP      r9,#2                 ;630
000070  d003              BEQ      |L6.122|
000072  f1b90f03          CMP      r9,#3                 ;630
000076  d176              BNE      |L6.358|
000078  e020              B        |L6.188|
                  |L6.122|
00007a  8928              LDRH     r0,[r5,#8]            ;632
00007c  ea000407          AND      r4,r0,r7              ;632
000080  42bc              CMP      r4,r7                 ;633
000082  d10f              BNE      |L6.164|
000084  f1b80f01          CMP      r8,#1                 ;634
000088  d102              BNE      |L6.144|
00008a  8928              LDRH     r0,[r5,#8]            ;635
00008c  43a0              BICS     r0,r0,r4              ;635
00008e  8128              STRH     r0,[r5,#8]            ;635
                  |L6.144|
000090  486f              LDR      r0,|L6.592|
000092  6800              LDR      r0,[r0,#0]            ;637  ; OSTCBCur
000094  8504              STRH     r4,[r0,#0x28]         ;637
000096  9802              LDR      r0,[sp,#8]            ;638
000098  f7fffffe          BL       OS_CPU_SR_Restore
00009c  2000              MOVS     r0,#0                 ;639
00009e  7030              STRB     r0,[r6,#0]            ;639
0000a0  4620              MOV      r0,r4                 ;640
0000a2  e7bd              B        |L6.32|
                  |L6.164|
0000a4  464b              MOV      r3,r9                 ;642
0000a6  463a              MOV      r2,r7                 ;642
0000a8  a904              ADD      r1,sp,#0x10           ;642
0000aa  4628              MOV      r0,r5                 ;642
0000ac  f8cda000          STR      r10,[sp,#0]           ;642
0000b0  f7fffffe          BL       OS_FlagBlock
0000b4  9802              LDR      r0,[sp,#8]            ;643
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  e069              B        |L6.400|
                  |L6.188|
0000bc  8928              LDRH     r0,[r5,#8]            ;648
0000be  ea000407          AND      r4,r0,r7              ;648
0000c2  b17c              CBZ      r4,|L6.228|
0000c4  f1b80f01          CMP      r8,#1                 ;650
0000c8  d102              BNE      |L6.208|
0000ca  8928              LDRH     r0,[r5,#8]            ;651
0000cc  43a0              BICS     r0,r0,r4              ;651
0000ce  8128              STRH     r0,[r5,#8]            ;651
                  |L6.208|
0000d0  485f              LDR      r0,|L6.592|
0000d2  6800              LDR      r0,[r0,#0]            ;653  ; OSTCBCur
0000d4  8504              STRH     r4,[r0,#0x28]         ;653
0000d6  9802              LDR      r0,[sp,#8]            ;654
0000d8  f7fffffe          BL       OS_CPU_SR_Restore
0000dc  2000              MOVS     r0,#0                 ;655
0000de  7030              STRB     r0,[r6,#0]            ;655
0000e0  4620              MOV      r0,r4                 ;656
0000e2  e79d              B        |L6.32|
                  |L6.228|
0000e4  464b              MOV      r3,r9                 ;658
0000e6  463a              MOV      r2,r7                 ;658
0000e8  a904              ADD      r1,sp,#0x10           ;658
0000ea  4628              MOV      r0,r5                 ;658
0000ec  f8cda000          STR      r10,[sp,#0]           ;658
0000f0  f7fffffe          BL       OS_FlagBlock
0000f4  9802              LDR      r0,[sp,#8]            ;659
0000f6  f7fffffe          BL       OS_CPU_SR_Restore
0000fa  e049              B        |L6.400|
                  |L6.252|
0000fc  8928              LDRH     r0,[r5,#8]            ;665
0000fe  ea270400          BIC      r4,r7,r0              ;665
000102  42bc              CMP      r4,r7                 ;666
000104  d10f              BNE      |L6.294|
000106  f1b80f01          CMP      r8,#1                 ;667
00010a  d102              BNE      |L6.274|
00010c  8928              LDRH     r0,[r5,#8]            ;668
00010e  4320              ORRS     r0,r0,r4              ;668
000110  8128              STRH     r0,[r5,#8]            ;668
                  |L6.274|
000112  484f              LDR      r0,|L6.592|
000114  6800              LDR      r0,[r0,#0]            ;670  ; OSTCBCur
000116  8504              STRH     r4,[r0,#0x28]         ;670
000118  9802              LDR      r0,[sp,#8]            ;671
00011a  f7fffffe          BL       OS_CPU_SR_Restore
00011e  2000              MOVS     r0,#0                 ;672
000120  7030              STRB     r0,[r6,#0]            ;672
000122  4620              MOV      r0,r4                 ;673
000124  e77c              B        |L6.32|
                  |L6.294|
000126  464b              MOV      r3,r9                 ;675
000128  463a              MOV      r2,r7                 ;675
00012a  a904              ADD      r1,sp,#0x10           ;675
00012c  4628              MOV      r0,r5                 ;675
00012e  f8cda000          STR      r10,[sp,#0]           ;675
000132  f7fffffe          BL       OS_FlagBlock
000136  9802              LDR      r0,[sp,#8]            ;676
000138  f7fffffe          BL       OS_CPU_SR_Restore
00013c  e028              B        |L6.400|
                  |L6.318|
00013e  8928              LDRH     r0,[r5,#8]            ;681
000140  ea270400          BIC      r4,r7,r0              ;681
000144  b184              CBZ      r4,|L6.360|
000146  f1b80f01          CMP      r8,#1                 ;683
00014a  d102              BNE      |L6.338|
00014c  8928              LDRH     r0,[r5,#8]            ;684
00014e  4320              ORRS     r0,r0,r4              ;684
000150  8128              STRH     r0,[r5,#8]            ;684
                  |L6.338|
000152  483f              LDR      r0,|L6.592|
000154  6800              LDR      r0,[r0,#0]            ;686  ; OSTCBCur
000156  8504              STRH     r4,[r0,#0x28]         ;686
000158  9802              LDR      r0,[sp,#8]            ;687
00015a  f7fffffe          BL       OS_CPU_SR_Restore
00015e  2000              MOVS     r0,#0                 ;688
000160  7030              STRB     r0,[r6,#0]            ;688
000162  4620              MOV      r0,r4                 ;689
000164  e75c              B        |L6.32|
                  |L6.358|
000166  e00b              B        |L6.384|
                  |L6.360|
000168  464b              MOV      r3,r9                 ;691
00016a  463a              MOV      r2,r7                 ;691
00016c  a904              ADD      r1,sp,#0x10           ;691
00016e  4628              MOV      r0,r5                 ;691
000170  f8cda000          STR      r10,[sp,#0]           ;691
000174  f7fffffe          BL       OS_FlagBlock
000178  9802              LDR      r0,[sp,#8]            ;692
00017a  f7fffffe          BL       OS_CPU_SR_Restore
00017e  e007              B        |L6.400|
                  |L6.384|
000180  9802              LDR      r0,[sp,#8]            ;698
000182  f7fffffe          BL       OS_CPU_SR_Restore
000186  2400              MOVS     r4,#0                 ;699
000188  206f              MOVS     r0,#0x6f              ;700
00018a  7030              STRB     r0,[r6,#0]            ;700
00018c  4620              MOV      r0,r4                 ;701
00018e  e747              B        |L6.32|
                  |L6.400|
000190  bf00              NOP                            ;645
000192  f7fffffe          BL       OS_Sched
000196  f7fffffe          BL       OS_CPU_SR_Save
00019a  9002              STR      r0,[sp,#8]            ;705
00019c  482c              LDR      r0,|L6.592|
00019e  6800              LDR      r0,[r0,#0]            ;706  ; OSTCBCur
0001a0  f8900031          LDRB     r0,[r0,#0x31]         ;706
0001a4  b320              CBZ      r0,|L6.496|
0001a6  482a              LDR      r0,|L6.592|
0001a8  6800              LDR      r0,[r0,#0]            ;707  ; OSTCBCur
0001aa  f8900031          LDRB     r0,[r0,#0x31]         ;707
0001ae  9003              STR      r0,[sp,#0xc]          ;707
0001b0  2000              MOVS     r0,#0                 ;708
0001b2  4927              LDR      r1,|L6.592|
0001b4  6809              LDR      r1,[r1,#0]            ;708  ; OSTCBCur
0001b6  f8810031          STRB     r0,[r1,#0x31]         ;708
0001ba  a804              ADD      r0,sp,#0x10           ;709
0001bc  f7fffffe          BL       OS_FlagUnlink
0001c0  2000              MOVS     r0,#0                 ;710
0001c2  4923              LDR      r1,|L6.592|
0001c4  6809              LDR      r1,[r1,#0]            ;710  ; OSTCBCur
0001c6  f8810030          STRB     r0,[r1,#0x30]         ;710
0001ca  9802              LDR      r0,[sp,#8]            ;711
0001cc  f7fffffe          BL       OS_CPU_SR_Restore
0001d0  2400              MOVS     r4,#0                 ;712
0001d2  9803              LDR      r0,[sp,#0xc]          ;713
0001d4  2801              CMP      r0,#1                 ;713
0001d6  d005              BEQ      |L6.484|
0001d8  2802              CMP      r0,#2                 ;713
0001da  d102              BNE      |L6.482|
0001dc  200e              MOVS     r0,#0xe               ;715
0001de  7030              STRB     r0,[r6,#0]            ;715
0001e0  e003              B        |L6.490|
                  |L6.482|
0001e2  bf00              NOP                            ;718
                  |L6.484|
0001e4  200a              MOVS     r0,#0xa               ;720
0001e6  7030              STRB     r0,[r6,#0]            ;720
0001e8  bf00              NOP                            ;721
                  |L6.490|
0001ea  bf00              NOP                            ;716
0001ec  4620              MOV      r0,r4                 ;723
0001ee  e717              B        |L6.32|
                  |L6.496|
0001f0  4817              LDR      r0,|L6.592|
0001f2  6800              LDR      r0,[r0,#0]            ;725  ; OSTCBCur
0001f4  8d04              LDRH     r4,[r0,#0x28]         ;725
0001f6  f1b80f01          CMP      r8,#1                 ;726
0001fa  d11e              BNE      |L6.570|
0001fc  f1b90f00          CMP      r9,#0                 ;727
000200  d00e              BEQ      |L6.544|
000202  f1b90f01          CMP      r9,#1                 ;727
000206  d00c              BEQ      |L6.546|
000208  f1b90f02          CMP      r9,#2                 ;727
00020c  d003              BEQ      |L6.534|
00020e  f1b90f03          CMP      r9,#3                 ;727
000212  d10a              BNE      |L6.554|
000214  e000              B        |L6.536|
                  |L6.534|
000216  bf00              NOP                            ;729
                  |L6.536|
000218  8928              LDRH     r0,[r5,#8]            ;730
00021a  43a0              BICS     r0,r0,r4              ;730
00021c  8128              STRH     r0,[r5,#8]            ;730
00021e  e00b              B        |L6.568|
                  |L6.544|
000220  bf00              NOP                            ;735
                  |L6.546|
000222  8928              LDRH     r0,[r5,#8]            ;736
000224  4320              ORRS     r0,r0,r4              ;736
000226  8128              STRH     r0,[r5,#8]            ;736
000228  e006              B        |L6.568|
                  |L6.554|
00022a  9802              LDR      r0,[sp,#8]            ;740
00022c  f7fffffe          BL       OS_CPU_SR_Restore
000230  206f              MOVS     r0,#0x6f              ;741
000232  7030              STRB     r0,[r6,#0]            ;741
000234  2000              MOVS     r0,#0                 ;742
000236  e6f3              B        |L6.32|
                  |L6.568|
000238  bf00              NOP                            ;731
                  |L6.570|
00023a  9802              LDR      r0,[sp,#8]            ;745
00023c  f7fffffe          BL       OS_CPU_SR_Restore
000240  2000              MOVS     r0,#0                 ;746
000242  7030              STRB     r0,[r6,#0]            ;746
000244  4620              MOV      r0,r4                 ;747
000246  e6eb              B        |L6.32|
;;;749    /*$PAGE*/
                          ENDP

                  |L6.584|
                          DCD      OSIntNesting
                  |L6.588|
                          DCD      OSLockNesting
                  |L6.592|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;764    
;;;765    OS_FLAGS  OSFlagPendGetFlagsRdy (void)
000000  b570              PUSH     {r4-r6,lr}
;;;766    {
;;;767        OS_FLAGS      flags;
;;;768    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;769        OS_CPU_SR     cpu_sr = 0u;
000002  2500              MOVS     r5,#0
;;;770    #endif
;;;771    
;;;772    
;;;773    
;;;774        OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4605              MOV      r5,r0
;;;775        flags = OSTCBCur->OSTCBFlagsRdy;
00000a  4804              LDR      r0,|L7.28|
00000c  6800              LDR      r0,[r0,#0]  ; OSTCBCur
00000e  8d04              LDRH     r4,[r0,#0x28]
;;;776        OS_EXIT_CRITICAL();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;777        return (flags);
000016  4620              MOV      r0,r4
;;;778    }
000018  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=1

                  OSFlagPost PROC
;;;821    */
;;;822    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;823                          OS_FLAGS      flags,
;;;824                          INT8U         opt,
;;;825                          INT8U        *perr)
;;;826    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461e              MOV      r6,r3
;;;827        OS_FLAG_NODE *pnode;
;;;828        BOOLEAN       sched;
;;;829        OS_FLAGS      flags_cur;
;;;830        OS_FLAGS      flags_rdy;
;;;831        BOOLEAN       rdy;
;;;832    #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
;;;833        OS_CPU_SR     cpu_sr = 0u;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;834    #endif
;;;835    
;;;836    
;;;837    
;;;838    #ifdef OS_SAFETY_CRITICAL
;;;839        if (perr == (INT8U *)0) {
;;;840            OS_SAFETY_CRITICAL_EXCEPTION();
;;;841        }
;;;842    #endif
;;;843    
;;;844    #if OS_ARG_CHK_EN > 0u
;;;845        if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
;;;846            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;847            return ((OS_FLAGS)0);
;;;848        }
;;;849    #endif
;;;850        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d004              BEQ      |L8.32|
;;;851            *perr = OS_ERR_EVENT_TYPE;
000016  2001              MOVS     r0,#1
000018  7030              STRB     r0,[r6,#0]
;;;852            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L8.28|
;;;853        }
;;;854    /*$PAGE*/
;;;855        OS_ENTER_CRITICAL();
;;;856        switch (opt) {
;;;857            case OS_FLAG_CLR:
;;;858                 pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
;;;859                 break;
;;;860    
;;;861            case OS_FLAG_SET:
;;;862                 pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
;;;863                 break;
;;;864    
;;;865            default:
;;;866                 OS_EXIT_CRITICAL();                     /* INVALID option                                 */
;;;867                 *perr = OS_ERR_FLAG_INVALID_OPT;
;;;868                 return ((OS_FLAGS)0);
;;;869        }
;;;870        sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
;;;871        pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;872        while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
;;;873            switch (pnode->OSFlagNodeWaitType) {
;;;874                case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
;;;875                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;876                     if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;877                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;878                         if (rdy == OS_TRUE) {
;;;879                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;880                         }
;;;881                     }
;;;882                     break;
;;;883    
;;;884                case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
;;;885                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;886                     if (flags_rdy != (OS_FLAGS)0) {
;;;887                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;888                         if (rdy == OS_TRUE) {
;;;889                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;890                         }
;;;891                     }
;;;892                     break;
;;;893    
;;;894    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;895                case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
;;;896                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;897                     if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;898                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;899                         if (rdy == OS_TRUE) {
;;;900                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;901                         }
;;;902                     }
;;;903                     break;
;;;904    
;;;905                case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
;;;906                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;907                     if (flags_rdy != (OS_FLAGS)0) {
;;;908                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;909                         if (rdy == OS_TRUE) {
;;;910                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;911                         }
;;;912                     }
;;;913                     break;
;;;914    #endif
;;;915                default:
;;;916                     OS_EXIT_CRITICAL();
;;;917                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;918                     return ((OS_FLAGS)0);
;;;919            }
;;;920            pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
;;;921        }
;;;922        OS_EXIT_CRITICAL();
;;;923        if (sched == OS_TRUE) {
;;;924            OS_Sched();
;;;925        }
;;;926        OS_ENTER_CRITICAL();
;;;927        flags_cur = pgrp->OSFlagFlags;
;;;928        OS_EXIT_CRITICAL();
;;;929        *perr     = OS_ERR_NONE;
;;;930        return (flags_cur);
;;;931    }
00001c  e8bd9ffc          POP      {r2-r12,pc}
                  |L8.32|
000020  f7fffffe          BL       OS_CPU_SR_Save
000024  9000              STR      r0,[sp,#0]            ;855
000026  f1ba0f00          CMP      r10,#0                ;856
00002a  d003              BEQ      |L8.52|
00002c  f1ba0f01          CMP      r10,#1                ;856
000030  d10a              BNE      |L8.72|
000032  e004              B        |L8.62|
                  |L8.52|
000034  8920              LDRH     r0,[r4,#8]            ;858
000036  ea200009          BIC      r0,r0,r9              ;858
00003a  8120              STRH     r0,[r4,#8]            ;858
00003c  e00b              B        |L8.86|
                  |L8.62|
00003e  8920              LDRH     r0,[r4,#8]            ;862
000040  ea400009          ORR      r0,r0,r9              ;862
000044  8120              STRH     r0,[r4,#8]            ;862
000046  e006              B        |L8.86|
                  |L8.72|
000048  9800              LDR      r0,[sp,#0]            ;866
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2071              MOVS     r0,#0x71              ;867
000050  7030              STRB     r0,[r6,#0]            ;867
000052  2000              MOVS     r0,#0                 ;868
000054  e7e2              B        |L8.28|
                  |L8.86|
000056  bf00              NOP                            ;859
000058  f04f0b00          MOV      r11,#0                ;870
00005c  6865              LDR      r5,[r4,#4]            ;871
00005e  e055              B        |L8.268|
                  |L8.96|
000060  7ca8              LDRB     r0,[r5,#0x12]         ;873
000062  b340              CBZ      r0,|L8.182|
000064  2801              CMP      r0,#1                 ;873
000066  d038              BEQ      |L8.218|
000068  2802              CMP      r0,#2                 ;873
00006a  d002              BEQ      |L8.114|
00006c  2803              CMP      r0,#3                 ;873
00006e  d144              BNE      |L8.250|
000070  e011              B        |L8.150|
                  |L8.114|
000072  8920              LDRH     r0,[r4,#8]            ;875
000074  8a29              LDRH     r1,[r5,#0x10]         ;875
000076  ea000701          AND      r7,r0,r1              ;875
00007a  8a28              LDRH     r0,[r5,#0x10]         ;876
00007c  42b8              CMP      r0,r7                 ;876
00007e  d109              BNE      |L8.148|
000080  4639              MOV      r1,r7                 ;877
000082  4628              MOV      r0,r5                 ;877
000084  f7fffffe          BL       OS_FlagTaskRdy
000088  4680              MOV      r8,r0                 ;877
00008a  f1b80f01          CMP      r8,#1                 ;878
00008e  d101              BNE      |L8.148|
000090  f04f0b01          MOV      r11,#1                ;879
                  |L8.148|
000094  e038              B        |L8.264|
                  |L8.150|
000096  8920              LDRH     r0,[r4,#8]            ;885
000098  8a29              LDRH     r1,[r5,#0x10]         ;885
00009a  ea000701          AND      r7,r0,r1              ;885
00009e  b14f              CBZ      r7,|L8.180|
0000a0  4639              MOV      r1,r7                 ;887
0000a2  4628              MOV      r0,r5                 ;887
0000a4  f7fffffe          BL       OS_FlagTaskRdy
0000a8  4680              MOV      r8,r0                 ;887
0000aa  f1b80f01          CMP      r8,#1                 ;888
0000ae  d101              BNE      |L8.180|
0000b0  f04f0b01          MOV      r11,#1                ;889
                  |L8.180|
0000b4  e028              B        |L8.264|
                  |L8.182|
0000b6  8a28              LDRH     r0,[r5,#0x10]         ;896
0000b8  8921              LDRH     r1,[r4,#8]            ;896
0000ba  ea200701          BIC      r7,r0,r1              ;896
0000be  8a28              LDRH     r0,[r5,#0x10]         ;897
0000c0  42b8              CMP      r0,r7                 ;897
0000c2  d109              BNE      |L8.216|
0000c4  4639              MOV      r1,r7                 ;898
0000c6  4628              MOV      r0,r5                 ;898
0000c8  f7fffffe          BL       OS_FlagTaskRdy
0000cc  4680              MOV      r8,r0                 ;898
0000ce  f1b80f01          CMP      r8,#1                 ;899
0000d2  d101              BNE      |L8.216|
0000d4  f04f0b01          MOV      r11,#1                ;900
                  |L8.216|
0000d8  e016              B        |L8.264|
                  |L8.218|
0000da  8a28              LDRH     r0,[r5,#0x10]         ;906
0000dc  8921              LDRH     r1,[r4,#8]            ;906
0000de  ea200701          BIC      r7,r0,r1              ;906
0000e2  b14f              CBZ      r7,|L8.248|
0000e4  4639              MOV      r1,r7                 ;908
0000e6  4628              MOV      r0,r5                 ;908
0000e8  f7fffffe          BL       OS_FlagTaskRdy
0000ec  4680              MOV      r8,r0                 ;908
0000ee  f1b80f01          CMP      r8,#1                 ;909
0000f2  d101              BNE      |L8.248|
0000f4  f04f0b01          MOV      r11,#1                ;910
                  |L8.248|
0000f8  e006              B        |L8.264|
                  |L8.250|
0000fa  9800              LDR      r0,[sp,#0]            ;916
0000fc  f7fffffe          BL       OS_CPU_SR_Restore
000100  206f              MOVS     r0,#0x6f              ;917
000102  7030              STRB     r0,[r6,#0]            ;917
000104  2000              MOVS     r0,#0                 ;918
000106  e789              B        |L8.28|
                  |L8.264|
000108  bf00              NOP                            ;882
00010a  682d              LDR      r5,[r5,#0]            ;920
                  |L8.268|
00010c  2d00              CMP      r5,#0                 ;872
00010e  d1a7              BNE      |L8.96|
000110  9800              LDR      r0,[sp,#0]            ;922
000112  f7fffffe          BL       OS_CPU_SR_Restore
000116  f1bb0f01          CMP      r11,#1                ;923
00011a  d101              BNE      |L8.288|
00011c  f7fffffe          BL       OS_Sched
                  |L8.288|
000120  f7fffffe          BL       OS_CPU_SR_Save
000124  9000              STR      r0,[sp,#0]            ;926
000126  8920              LDRH     r0,[r4,#8]            ;927
000128  9001              STR      r0,[sp,#4]            ;927
00012a  9800              LDR      r0,[sp,#0]            ;928
00012c  f7fffffe          BL       OS_CPU_SR_Restore
000130  2000              MOVS     r0,#0                 ;929
000132  7030              STRB     r0,[r6,#0]            ;929
000134  9801              LDR      r0,[sp,#4]            ;930
000136  e771              B        |L8.28|
;;;932    /*$PAGE*/
                          ENDP


                          AREA ||i.OSFlagQuery||, CODE, READONLY, ALIGN=1

                  OSFlagQuery PROC
;;;952    #if OS_FLAG_QUERY_EN > 0u
;;;953    OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;954                           INT8U        *perr)
;;;955    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;956        OS_FLAGS   flags;
;;;957    #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
;;;958        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;959    #endif
;;;960    
;;;961    
;;;962    
;;;963    #ifdef OS_SAFETY_CRITICAL
;;;964        if (perr == (INT8U *)0) {
;;;965            OS_SAFETY_CRITICAL_EXCEPTION();
;;;966        }
;;;967    #endif
;;;968    
;;;969    #if OS_ARG_CHK_EN > 0u
;;;970        if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
;;;971            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;972            return ((OS_FLAGS)0);
;;;973        }
;;;974    #endif
;;;975        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00000a  7820              LDRB     r0,[r4,#0]
00000c  2805              CMP      r0,#5
00000e  d004              BEQ      |L9.26|
;;;976            *perr = OS_ERR_EVENT_TYPE;
000010  2001              MOVS     r0,#1
000012  7028              STRB     r0,[r5,#0]
;;;977            return ((OS_FLAGS)0);
000014  2000              MOVS     r0,#0
                  |L9.22|
;;;978        }
;;;979        OS_ENTER_CRITICAL();
;;;980        flags = pgrp->OSFlagFlags;
;;;981        OS_EXIT_CRITICAL();
;;;982        *perr = OS_ERR_NONE;
;;;983        return (flags);                               /* Return the current value of the event flags       */
;;;984    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L9.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;979
000020  8926              LDRH     r6,[r4,#8]            ;980
000022  4638              MOV      r0,r7                 ;981
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  2000              MOVS     r0,#0                 ;982
00002a  7028              STRB     r0,[r5,#0]            ;982
00002c  4630              MOV      r0,r6                 ;983
00002e  e7f2              B        |L9.22|
;;;985    #endif
                          ENDP


                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;1024   
;;;1025   static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1026                               OS_FLAG_NODE *pnode,
;;;1027                               OS_FLAGS      flags,
;;;1028                               INT8U         wait_type,
;;;1029                               INT32U        timeout)
;;;1030   {
000002  4614              MOV      r4,r2
000004  9e05              LDR      r6,[sp,#0x14]
;;;1031       OS_FLAG_NODE  *pnode_next;
;;;1032       INT8U          y;
;;;1033   
;;;1034   
;;;1035       OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
000006  4f24              LDR      r7,|L10.152|
000008  683f              LDR      r7,[r7,#0]  ; OSTCBCur
00000a  f8977030          LDRB     r7,[r7,#0x30]
00000e  f0470720          ORR      r7,r7,#0x20
000012  f8dfc084          LDR      r12,|L10.152|
000016  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
00001a  f88c7030          STRB     r7,[r12,#0x30]
;;;1036       OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
00001e  2700              MOVS     r7,#0
000020  f8dfc074          LDR      r12,|L10.152|
000024  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000028  f88c7031          STRB     r7,[r12,#0x31]
;;;1037       OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002c  4f1a              LDR      r7,|L10.152|
00002e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000030  62fe              STR      r6,[r7,#0x2c]
;;;1038   #if OS_TASK_DEL_EN > 0u
;;;1039       OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
000032  4f19              LDR      r7,|L10.152|
000034  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000036  6279              STR      r1,[r7,#0x24]
;;;1040   #endif
;;;1041       pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
000038  820c              STRH     r4,[r1,#0x10]
;;;1042       pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
00003a  748b              STRB     r3,[r1,#0x12]
;;;1043       pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00003c  4f16              LDR      r7,|L10.152|
00003e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000040  608f              STR      r7,[r1,#8]
;;;1044       pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
000042  6847              LDR      r7,[r0,#4]
000044  600f              STR      r7,[r1,#0]
;;;1045       pnode->OSFlagNodePrev     = (void *)0;
000046  2700              MOVS     r7,#0
000048  604f              STR      r7,[r1,#4]
;;;1046       pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
00004a  60c8              STR      r0,[r1,#0xc]
;;;1047       pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00004c  6845              LDR      r5,[r0,#4]
;;;1048       if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
00004e  b105              CBZ      r5,|L10.82|
;;;1049           pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000050  6069              STR      r1,[r5,#4]
                  |L10.82|
;;;1050       }
;;;1051       pgrp->OSFlagWaitList = (void *)pnode;
000052  6041              STR      r1,[r0,#4]
;;;1052   
;;;1053       y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000054  4f10              LDR      r7,|L10.152|
000056  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000058  f8972034          LDRB     r2,[r7,#0x34]
;;;1054       OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00005c  4f0f              LDR      r7,|L10.156|
00005e  5cbf              LDRB     r7,[r7,r2]
000060  f8dfc034          LDR      r12,|L10.152|
000064  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000068  f89cc035          LDRB     r12,[r12,#0x35]
00006c  ea27070c          BIC      r7,r7,r12
000070  f8dfc028          LDR      r12,|L10.156|
000074  f80c7002          STRB     r7,[r12,r2]
;;;1055       if (OSRdyTbl[y] == 0x00u) {
000078  4667              MOV      r7,r12
00007a  5cbf              LDRB     r7,[r7,r2]
00007c  b95f              CBNZ     r7,|L10.150|
;;;1056           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00007e  4f06              LDR      r7,|L10.152|
000080  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000082  f897c036          LDRB     r12,[r7,#0x36]
000086  4f06              LDR      r7,|L10.160|
000088  783f              LDRB     r7,[r7,#0]  ; OSRdyGrp
00008a  ea27070c          BIC      r7,r7,r12
00008e  f8dfc010          LDR      r12,|L10.160|
000092  f88c7000          STRB     r7,[r12,#0]
                  |L10.150|
;;;1057       }
;;;1058   }
000096  bdf0              POP      {r4-r7,pc}
;;;1059   
                          ENDP

                  |L10.152|
                          DCD      OSTCBCur
                  |L10.156|
                          DCD      OSRdyTbl
                  |L10.160|
                          DCD      OSRdyGrp

                          AREA ||i.OS_FlagInit||, CODE, READONLY, ALIGN=2

                  OS_FlagInit PROC
;;;1075   
;;;1076   void  OS_FlagInit (void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1077   {
;;;1078   #if OS_MAX_FLAGS == 1u
;;;1079       OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
;;;1080       OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;1081       OSFlagFreeList->OSFlagWaitList = (void *)0;
;;;1082       OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
;;;1083   #if OS_FLAG_NAME_EN > 0u
;;;1084       OSFlagFreeList->OSFlagName     = (INT8U *)"?";
;;;1085   #endif
;;;1086   #endif
;;;1087   
;;;1088   #if OS_MAX_FLAGS >= 2u
;;;1089       INT16U        ix;
;;;1090       INT16U        ix_next;
;;;1091       OS_FLAG_GRP  *pgrp1;
;;;1092       OS_FLAG_GRP  *pgrp2;
;;;1093   
;;;1094   
;;;1095       OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
000004  2150              MOVS     r1,#0x50
000006  4811              LDR      r0,|L11.76|
000008  f7fffffe          BL       OS_MemClr
;;;1096       for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
00000c  2500              MOVS     r5,#0
00000e  e00d              B        |L11.44|
                  |L11.16|
;;;1097           ix_next = ix + 1u;
000010  1c68              ADDS     r0,r5,#1
000012  b286              UXTH     r6,r0
;;;1098           pgrp1 = &OSFlagTbl[ix];
000014  480d              LDR      r0,|L11.76|
000016  eb001405          ADD      r4,r0,r5,LSL #4
;;;1099           pgrp2 = &OSFlagTbl[ix_next];
00001a  eb001706          ADD      r7,r0,r6,LSL #4
;;;1100           pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001e  2000              MOVS     r0,#0
000020  7020              STRB     r0,[r4,#0]
;;;1101           pgrp1->OSFlagWaitList = (void *)pgrp2;
000022  6067              STR      r7,[r4,#4]
;;;1102   #if OS_FLAG_NAME_EN > 0u
;;;1103           pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
000024  a00a              ADR      r0,|L11.80|
000026  60e0              STR      r0,[r4,#0xc]
000028  1c68              ADDS     r0,r5,#1              ;1096
00002a  b285              UXTH     r5,r0                 ;1096
                  |L11.44|
00002c  2d04              CMP      r5,#4                 ;1096
00002e  d3ef              BCC      |L11.16|
;;;1104   #endif
;;;1105       }
;;;1106       pgrp1                 = &OSFlagTbl[ix];
000030  4806              LDR      r0,|L11.76|
000032  eb001405          ADD      r4,r0,r5,LSL #4
;;;1107       pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000036  2000              MOVS     r0,#0
000038  7020              STRB     r0,[r4,#0]
;;;1108       pgrp1->OSFlagWaitList = (void *)0;
00003a  6060              STR      r0,[r4,#4]
;;;1109   #if OS_FLAG_NAME_EN > 0u
;;;1110       pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
00003c  a004              ADR      r0,|L11.80|
00003e  60e0              STR      r0,[r4,#0xc]
;;;1111   #endif
;;;1112       OSFlagFreeList        = &OSFlagTbl[0];
000040  4802              LDR      r0,|L11.76|
000042  4904              LDR      r1,|L11.84|
000044  6008              STR      r0,[r1,#0]  ; OSFlagFreeList
;;;1113   #endif
;;;1114   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1115   
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      OSFlagTbl
                  |L11.80|
000050  3f00              DCB      "?",0
000052  00                DCB      0
000053  00                DCB      0
                  |L11.84|
                          DCD      OSFlagFreeList

                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_FlagTaskRdy PROC
;;;1139   
;;;1140   static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1141                                    OS_FLAGS      flags_rdy)
;;;1142   {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;1143       OS_TCB   *ptcb;
;;;1144       BOOLEAN   sched;
;;;1145   
;;;1146   
;;;1147       ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000006  68b4              LDR      r4,[r6,#8]
;;;1148       ptcb->OSTCBDly       = 0u;
000008  2000              MOVS     r0,#0
00000a  3428              ADDS     r4,r4,#0x28
00000c  6060              STR      r0,[r4,#4]
;;;1149       ptcb->OSTCBFlagsRdy  = flags_rdy;
00000e  8027              STRH     r7,[r4,#0]
;;;1150       ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000010  7a20              LDRB     r0,[r4,#8]
000012  f00000df          AND      r0,r0,#0xdf
000016  7220              STRB     r0,[r4,#8]
;;;1151       ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
000018  2000              MOVS     r0,#0
00001a  7260              STRB     r0,[r4,#9]
;;;1152       if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
00001c  7a20              LDRB     r0,[r4,#8]
00001e  3c28              SUBS     r4,r4,#0x28
000020  b988              CBNZ     r0,|L12.70|
;;;1153           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000022  3434              ADDS     r4,r4,#0x34
000024  78a0              LDRB     r0,[r4,#2]
000026  490b              LDR      r1,|L12.84|
000028  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
00002a  4308              ORRS     r0,r0,r1
00002c  4909              LDR      r1,|L12.84|
00002e  7008              STRB     r0,[r1,#0]
;;;1154           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000030  7820              LDRB     r0,[r4,#0]
000032  4909              LDR      r1,|L12.88|
000034  5c08              LDRB     r0,[r1,r0]
000036  7861              LDRB     r1,[r4,#1]
000038  4308              ORRS     r0,r0,r1
00003a  f8141934          LDRB     r1,[r4],#-0x34
00003e  4a06              LDR      r2,|L12.88|
000040  5450              STRB     r0,[r2,r1]
;;;1155           sched                   = OS_TRUE;
000042  2501              MOVS     r5,#1
000044  e000              B        |L12.72|
                  |L12.70|
;;;1156       } else {
;;;1157           sched                   = OS_FALSE;
000046  2500              MOVS     r5,#0
                  |L12.72|
;;;1158       }
;;;1159       OS_FlagUnlink(pnode);
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       OS_FlagUnlink
;;;1160       return (sched);
00004e  4628              MOV      r0,r5
;;;1161   }
000050  bdf0              POP      {r4-r7,pc}
;;;1162   
                          ENDP

000052  0000              DCW      0x0000
                  |L12.84|
                          DCD      OSRdyGrp
                  |L12.88|
                          DCD      OSRdyTbl

                          AREA ||i.OS_FlagUnlink||, CODE, READONLY, ALIGN=1

                  OS_FlagUnlink PROC
;;;1184   
;;;1185   void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
000000  b530              PUSH     {r4,r5,lr}
;;;1186   {
000002  4601              MOV      r1,r0
;;;1187   #if OS_TASK_DEL_EN > 0u
;;;1188       OS_TCB       *ptcb;
;;;1189   #endif
;;;1190       OS_FLAG_GRP  *pgrp;
;;;1191       OS_FLAG_NODE *pnode_prev;
;;;1192       OS_FLAG_NODE *pnode_next;
;;;1193   
;;;1194   
;;;1195       pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
000004  684a              LDR      r2,[r1,#4]
;;;1196       pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
000006  6808              LDR      r0,[r1,#0]
;;;1197       if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
000008  b92a              CBNZ     r2,|L13.22|
;;;1198           pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00000a  68cc              LDR      r4,[r1,#0xc]
;;;1199           pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00000c  6060              STR      r0,[r4,#4]
;;;1200           if (pnode_next != (OS_FLAG_NODE *)0) {
00000e  b128              CBZ      r0,|L13.28|
;;;1201               pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
000010  2500              MOVS     r5,#0
000012  6045              STR      r5,[r0,#4]
000014  e002              B        |L13.28|
                  |L13.22|
;;;1202           }
;;;1203       } else {                                                    /* No,  A node somewhere in the list   */
;;;1204           pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
000016  6010              STR      r0,[r2,#0]
;;;1205           if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
000018  b100              CBZ      r0,|L13.28|
;;;1206               pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00001a  6042              STR      r2,[r0,#4]
                  |L13.28|
;;;1207           }
;;;1208       }
;;;1209   #if OS_TASK_DEL_EN > 0u
;;;1210       ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
00001c  688b              LDR      r3,[r1,#8]
;;;1211       ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00001e  2500              MOVS     r5,#0
000020  625d              STR      r5,[r3,#0x24]
;;;1212   #endif
;;;1213   }
000022  bd30              POP      {r4,r5,pc}
;;;1214   #endif
                          ENDP

