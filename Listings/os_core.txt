; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\os_core.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\os_core.crf UCOSII\CORE\os_core.c]
                          THUMB

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=1

                  OSInit PROC
;;;569    
;;;570    void  OSInit (void)
000000  b510              PUSH     {r4,lr}
;;;571    {
;;;572        OSInitHookBegin();                                           /* Call port specific initialization code   */
000002  f7fffffe          BL       OSInitHookBegin
;;;573    
;;;574        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000006  f7fffffe          BL       OS_InitMisc
;;;575    
;;;576        OS_InitRdyList();                                            /* Initialize the Ready List                */
00000a  f7fffffe          BL       OS_InitRdyList
;;;577    
;;;578        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000e  f7fffffe          BL       OS_InitTCBList
;;;579    
;;;580        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000012  f7fffffe          BL       OS_InitEventList
;;;581    
;;;582    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;583        OS_FlagInit();                                               /* Initialize the event flag structures     */
000016  f7fffffe          BL       OS_FlagInit
;;;584    #endif
;;;585    
;;;586    #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
;;;587        OS_MemInit();                                                /* Initialize the memory manager            */
;;;588    #endif
;;;589    
;;;590    #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
;;;591        OS_QInit();                                                  /* Initialize the message queue structures  */
00001a  f7fffffe          BL       OS_QInit
;;;592    #endif
;;;593    
;;;594        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00001e  f7fffffe          BL       OS_InitTaskIdle
;;;595    #if OS_TASK_STAT_EN > 0u
;;;596        OS_InitTaskStat();                                           /* Create the Statistic Task                */
000022  f7fffffe          BL       OS_InitTaskStat
;;;597    #endif
;;;598    
;;;599    #if OS_TMR_EN > 0u
;;;600        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;601    #endif
;;;602    
;;;603        OSInitHookEnd();                                             /* Call port specific init. code            */
000026  f7fffffe          BL       OSInitHookEnd
;;;604    
;;;605    #if OS_DEBUG_EN > 0u
;;;606        OSDebugInit();
;;;607    #endif
;;;608    }
00002a  bd10              POP      {r4,pc}
;;;609    /*$PAGE*/
                          ENDP


                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;634    
;;;635    void  OSIntEnter (void)
000000  4806              LDR      r0,|L2.28|
;;;636    {
;;;637        if (OSRunning == OS_TRUE) {
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d108              BNE      |L2.26|
;;;638            if (OSIntNesting < 255u) {
000008  4805              LDR      r0,|L2.32|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  28ff              CMP      r0,#0xff
00000e  d204              BCS      |L2.26|
;;;639                OSIntNesting++;                      /* Increment ISR nesting level                        */
000010  4803              LDR      r0,|L2.32|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000014  1c40              ADDS     r0,r0,#1
000016  4902              LDR      r1,|L2.32|
000018  7008              STRB     r0,[r1,#0]
                  |L2.26|
;;;640            }
;;;641        }
;;;642    }
00001a  4770              BX       lr
;;;643    /*$PAGE*/
                          ENDP

                  |L2.28|
                          DCD      OSRunning
                  |L2.32|
                          DCD      OSIntNesting

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;662    
;;;663    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;664    {
;;;665    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;666        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;667    #endif
;;;668    
;;;669    
;;;670    
;;;671        if (OSRunning == OS_TRUE) {
000004  481a              LDR      r0,|L3.112|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d130              BNE      |L3.110|
;;;672            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;673            if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
000012  4818              LDR      r0,|L3.116|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b120              CBZ      r0,|L3.34|
;;;674                OSIntNesting--;
000018  4816              LDR      r0,|L3.116|
00001a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001c  1e40              SUBS     r0,r0,#1
00001e  4915              LDR      r1,|L3.116|
000020  7008              STRB     r0,[r1,#0]
                  |L3.34|
;;;675            }
;;;676            if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
000022  4814              LDR      r0,|L3.116|
000024  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000026  b9f8              CBNZ     r0,|L3.104|
;;;677                if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
000028  4813              LDR      r0,|L3.120|
00002a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00002c  b9e0              CBNZ     r0,|L3.104|
;;;678                    OS_SchedNew();
00002e  f7fffffe          BL       OS_SchedNew
;;;679                    OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000032  4812              LDR      r0,|L3.124|
000034  4912              LDR      r1,|L3.128|
000036  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000038  f8500021          LDR      r0,[r0,r1,LSL #2]
00003c  4911              LDR      r1,|L3.132|
00003e  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;680                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000040  480f              LDR      r0,|L3.128|
000042  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000044  4910              LDR      r1,|L3.136|
000046  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000048  4288              CMP      r0,r1
00004a  d00d              BEQ      |L3.104|
;;;681    #if OS_TASK_PROFILE_EN > 0u
;;;682                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00004c  480d              LDR      r0,|L3.132|
00004e  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000050  6b80              LDR      r0,[r0,#0x38]
000052  1c40              ADDS     r0,r0,#1
000054  490b              LDR      r1,|L3.132|
000056  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000058  6388              STR      r0,[r1,#0x38]
;;;683    #endif
;;;684                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00005a  480c              LDR      r0,|L3.140|
00005c  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00005e  1c40              ADDS     r0,r0,#1
000060  490a              LDR      r1,|L3.140|
000062  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;685                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000064  f7fffffe          BL       OSIntCtxSw
                  |L3.104|
;;;686                    }
;;;687                }
;;;688            }
;;;689            OS_EXIT_CRITICAL();
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       OS_CPU_SR_Restore
                  |L3.110|
;;;690        }
;;;691    }
00006e  bd10              POP      {r4,pc}
;;;692    /*$PAGE*/
                          ENDP

                  |L3.112|
                          DCD      OSRunning
                  |L3.116|
                          DCD      OSIntNesting
                  |L3.120|
                          DCD      OSLockNesting
                  |L3.124|
                          DCD      OSTCBPrioTbl
                  |L3.128|
                          DCD      OSPrioHighRdy
                  |L3.132|
                          DCD      OSTCBHighRdy
                  |L3.136|
                          DCD      OSPrioCur
                  |L3.140|
                          DCD      OSCtxSwCtr

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;735    #if OS_SCHED_LOCK_EN > 0u
;;;736    void  OSSchedLock (void)
000000  b510              PUSH     {r4,lr}
;;;737    {
;;;738    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;739        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;740    #endif
;;;741    
;;;742    
;;;743    
;;;744        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000004  480b              LDR      r0,|L4.52|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d111              BNE      |L4.48|
;;;745            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;746            if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
000012  4809              LDR      r0,|L4.56|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b940              CBNZ     r0,|L4.42|
;;;747                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000018  4808              LDR      r0,|L4.60|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  28ff              CMP      r0,#0xff
00001e  d204              BCS      |L4.42|
;;;748                    OSLockNesting++;                 /* Increment lock nesting level                       */
000020  4806              LDR      r0,|L4.60|
000022  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000024  1c40              ADDS     r0,r0,#1
000026  4905              LDR      r1,|L4.60|
000028  7008              STRB     r0,[r1,#0]
                  |L4.42|
;;;749                }
;;;750            }
;;;751            OS_EXIT_CRITICAL();
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L4.48|
;;;752        }
;;;753    }
000030  bd10              POP      {r4,pc}
;;;754    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      OSRunning
                  |L4.56|
                          DCD      OSIntNesting
                  |L4.60|
                          DCD      OSLockNesting

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;772    #if OS_SCHED_LOCK_EN > 0u
;;;773    void  OSSchedUnlock (void)
000000  b510              PUSH     {r4,lr}
;;;774    {
;;;775    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;776        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;777    #endif
;;;778    
;;;779    
;;;780    
;;;781        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000004  4813              LDR      r0,|L5.84|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d121              BNE      |L5.80|
;;;782            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;783            if (OSLockNesting > 0u) {                          /* Do not decrement if already 0            */
000012  4811              LDR      r0,|L5.88|
000014  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000016  b1c0              CBZ      r0,|L5.74|
;;;784                OSLockNesting--;                               /* Decrement lock nesting level             */
000018  480f              LDR      r0,|L5.88|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  1e40              SUBS     r0,r0,#1
00001e  490e              LDR      r1,|L5.88|
000020  7008              STRB     r0,[r1,#0]
;;;785                if (OSLockNesting == 0u) {                     /* See if scheduler is enabled and ...      */
000022  4608              MOV      r0,r1
000024  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000026  b960              CBNZ     r0,|L5.66|
;;;786                    if (OSIntNesting == 0u) {                  /* ... not in an ISR                        */
000028  480c              LDR      r0,|L5.92|
00002a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00002c  b928              CBNZ     r0,|L5.58|
;;;787                        OS_EXIT_CRITICAL();
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       OS_CPU_SR_Restore
;;;788                        OS_Sched();                            /* See if a HPT is ready                    */
000034  f7fffffe          BL       OS_Sched
000038  e00a              B        |L5.80|
                  |L5.58|
;;;789                    } else {
;;;790                        OS_EXIT_CRITICAL();
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  e006              B        |L5.80|
                  |L5.66|
;;;791                    }
;;;792                } else {
;;;793                    OS_EXIT_CRITICAL();
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  e002              B        |L5.80|
                  |L5.74|
;;;794                }
;;;795            } else {
;;;796                OS_EXIT_CRITICAL();
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L5.80|
;;;797            }
;;;798        }
;;;799    }
000050  bd10              POP      {r4,pc}
;;;800    #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      OSRunning
                  |L5.88|
                          DCD      OSLockNesting
                  |L5.92|
                          DCD      OSIntNesting

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;822    
;;;823    void  OSStart (void)
000000  b510              PUSH     {r4,lr}
;;;824    {
;;;825        if (OSRunning == OS_FALSE) {
000002  480b              LDR      r0,|L6.48|
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  b990              CBNZ     r0,|L6.46|
;;;826            OS_SchedNew();                               /* Find highest priority's task priority number   */
000008  f7fffffe          BL       OS_SchedNew
;;;827            OSPrioCur     = OSPrioHighRdy;
00000c  4809              LDR      r0,|L6.52|
00000e  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000010  4909              LDR      r1,|L6.56|
000012  7008              STRB     r0,[r1,#0]
;;;828            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000014  4809              LDR      r0,|L6.60|
000016  4907              LDR      r1,|L6.52|
000018  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00001a  f8500021          LDR      r0,[r0,r1,LSL #2]
00001e  4908              LDR      r1,|L6.64|
000020  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;829            OSTCBCur      = OSTCBHighRdy;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000026  4907              LDR      r1,|L6.68|
000028  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;830            OSStartHighRdy();                            /* Execute target specific code to start task     */
00002a  f7fffffe          BL       OSStartHighRdy
                  |L6.46|
;;;831        }
;;;832    }
00002e  bd10              POP      {r4,pc}
;;;833    /*$PAGE*/
                          ENDP

                  |L6.48|
                          DCD      OSRunning
                  |L6.52|
                          DCD      OSPrioHighRdy
                  |L6.56|
                          DCD      OSPrioCur
                  |L6.60|
                          DCD      OSTCBPrioTbl
                  |L6.64|
                          DCD      OSTCBHighRdy
                  |L6.68|
                          DCD      OSTCBCur

                          AREA ||i.OSStatInit||, CODE, READONLY, ALIGN=2

                  OSStatInit PROC
;;;854    #if OS_TASK_STAT_EN > 0u
;;;855    void  OSStatInit (void)
000000  b510              PUSH     {r4,lr}
;;;856    {
;;;857    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;858        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;859    #endif
;;;860    
;;;861    
;;;862    
;;;863        OSTimeDly(2u);                               /* Synchronize with clock tick                        */
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       OSTimeDly
;;;864        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4604              MOV      r4,r0
;;;865        OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
000010  2000              MOVS     r0,#0
000012  490b              LDR      r1,|L7.64|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;866        OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;867        OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00001c  2014              MOVS     r0,#0x14
00001e  f7fffffe          BL       OSTimeDly
;;;868        OS_ENTER_CRITICAL();
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4604              MOV      r4,r0
;;;869        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000028  4805              LDR      r0,|L7.64|
00002a  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00002c  4905              LDR      r1,|L7.68|
00002e  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;870        OSStatRdy    = OS_TRUE;
000030  2001              MOVS     r0,#1
000032  4905              LDR      r1,|L7.72|
000034  7008              STRB     r0,[r1,#0]
;;;871        OS_EXIT_CRITICAL();
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       OS_CPU_SR_Restore
;;;872    }
00003c  bd10              POP      {r4,pc}
;;;873    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      OSIdleCtr
                  |L7.68|
                          DCD      OSIdleCtrMax
                  |L7.72|
                          DCD      OSStatRdy

                          AREA ||i.OSTimeTick||, CODE, READONLY, ALIGN=2

                  OSTimeTick PROC
;;;888    
;;;889    void  OSTimeTick (void)
000000  b570              PUSH     {r4-r6,lr}
;;;890    {
;;;891        OS_TCB    *ptcb;
;;;892    #if OS_TICK_STEP_EN > 0u
;;;893        BOOLEAN    step;
;;;894    #endif
;;;895    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
;;;896        OS_CPU_SR  cpu_sr = 0u;
000002  2600              MOVS     r6,#0
;;;897    #endif
;;;898    
;;;899    
;;;900    
;;;901    #if OS_TIME_TICK_HOOK_EN > 0u
;;;902        OSTimeTickHook();                                      /* Call user definable hook                     */
000004  f7fffffe          BL       OSTimeTickHook
;;;903    #endif
;;;904    #if OS_TIME_GET_SET_EN > 0u
;;;905        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000008  f7fffffe          BL       OS_CPU_SR_Save
00000c  4606              MOV      r6,r0
;;;906        OSTime++;
00000e  4831              LDR      r0,|L8.212|
000010  6800              LDR      r0,[r0,#0]  ; OSTime
000012  1c40              ADDS     r0,r0,#1
000014  492f              LDR      r1,|L8.212|
000016  6008              STR      r0,[r1,#0]  ; OSTime
;;;907        OS_EXIT_CRITICAL();
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       OS_CPU_SR_Restore
;;;908    #endif
;;;909        if (OSRunning == OS_TRUE) {
00001e  482e              LDR      r0,|L8.216|
000020  7800              LDRB     r0,[r0,#0]  ; OSRunning
000022  2801              CMP      r0,#1
000024  d153              BNE      |L8.206|
;;;910    #if OS_TICK_STEP_EN > 0u
;;;911            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000026  482d              LDR      r0,|L8.220|
000028  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
00002a  b120              CBZ      r0,|L8.54|
00002c  2801              CMP      r0,#1
00002e  d004              BEQ      |L8.58|
000030  2802              CMP      r0,#2
000032  d109              BNE      |L8.72|
000034  e003              B        |L8.62|
                  |L8.54|
;;;912                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;913                     step = OS_TRUE;
000036  2501              MOVS     r5,#1
;;;914                     break;
000038  e00b              B        |L8.82|
                  |L8.58|
;;;915    
;;;916                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;917                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
00003a  2500              MOVS     r5,#0
;;;918                     break;
00003c  e009              B        |L8.82|
                  |L8.62|
;;;919    
;;;920                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;921                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
00003e  2501              MOVS     r5,#1
;;;922                     OSTickStepState = OS_TICK_STEP_WAIT;
000040  2001              MOVS     r0,#1
000042  4926              LDR      r1,|L8.220|
000044  7008              STRB     r0,[r1,#0]
;;;923                     break;
000046  e004              B        |L8.82|
                  |L8.72|
;;;924    
;;;925                default:                                       /* Invalid case, correct situation              */
;;;926                     step            = OS_TRUE;
000048  2501              MOVS     r5,#1
;;;927                     OSTickStepState = OS_TICK_STEP_DIS;
00004a  2000              MOVS     r0,#0
00004c  4923              LDR      r1,|L8.220|
00004e  7008              STRB     r0,[r1,#0]
;;;928                     break;
000050  bf00              NOP      
                  |L8.82|
000052  bf00              NOP                            ;914
;;;929            }
;;;930            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
000054  b905              CBNZ     r5,|L8.88|
                  |L8.86|
;;;931                return;
;;;932            }
;;;933    #endif
;;;934            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;935            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
;;;936                OS_ENTER_CRITICAL();
;;;937                if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
;;;938                    ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
;;;939                    if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
;;;940    
;;;941                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;942                            ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;943                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;944                        } else {
;;;945                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;946                        }
;;;947    
;;;948                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;949                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;950                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;951                        }
;;;952                    }
;;;953                }
;;;954                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
;;;955                OS_EXIT_CRITICAL();
;;;956            }
;;;957        }
;;;958    }
000056  bd70              POP      {r4-r6,pc}
                  |L8.88|
000058  4821              LDR      r0,|L8.224|
00005a  6804              LDR      r4,[r0,#0]            ;934  ; OSTCBList
00005c  e033              B        |L8.198|
                  |L8.94|
00005e  f7fffffe          BL       OS_CPU_SR_Save
000062  4606              MOV      r6,r0                 ;936
000064  6ae0              LDR      r0,[r4,#0x2c]         ;937
000066  b350              CBZ      r0,|L8.190|
000068  6ae0              LDR      r0,[r4,#0x2c]         ;938
00006a  1e40              SUBS     r0,r0,#1              ;938
00006c  62e0              STR      r0,[r4,#0x2c]         ;938
00006e  6ae0              LDR      r0,[r4,#0x2c]         ;939
000070  bb28              CBNZ     r0,|L8.190|
000072  f8940030          LDRB     r0,[r4,#0x30]         ;941
000076  f0000037          AND      r0,r0,#0x37           ;941
00007a  b140              CBZ      r0,|L8.142|
00007c  f8140f30          LDRB     r0,[r4,#0x30]!        ;942
000080  f00000c8          AND      r0,r0,#0xc8           ;942
000084  7020              STRB     r0,[r4,#0]            ;942
000086  2001              MOVS     r0,#1                 ;943
000088  7060              STRB     r0,[r4,#1]            ;943
00008a  3c30              SUBS     r4,r4,#0x30           ;943
00008c  e002              B        |L8.148|
                  |L8.142|
00008e  2000              MOVS     r0,#0                 ;945
000090  f8840031          STRB     r0,[r4,#0x31]         ;945
                  |L8.148|
000094  f8940030          LDRB     r0,[r4,#0x30]         ;948
000098  f0000008          AND      r0,r0,#8              ;948
00009c  b978              CBNZ     r0,|L8.190|
00009e  3434              ADDS     r4,r4,#0x34           ;949
0000a0  78a0              LDRB     r0,[r4,#2]            ;949
0000a2  4910              LDR      r1,|L8.228|
0000a4  7809              LDRB     r1,[r1,#0]            ;949  ; OSRdyGrp
0000a6  4308              ORRS     r0,r0,r1              ;949
0000a8  490e              LDR      r1,|L8.228|
0000aa  7008              STRB     r0,[r1,#0]            ;949
0000ac  7820              LDRB     r0,[r4,#0]            ;950
0000ae  490e              LDR      r1,|L8.232|
0000b0  5c08              LDRB     r0,[r1,r0]            ;950
0000b2  7861              LDRB     r1,[r4,#1]            ;950
0000b4  4308              ORRS     r0,r0,r1              ;950
0000b6  f8141934          LDRB     r1,[r4],#-0x34        ;950
0000ba  4a0b              LDR      r2,|L8.232|
0000bc  5450              STRB     r0,[r2,r1]            ;950
                  |L8.190|
0000be  6964              LDR      r4,[r4,#0x14]         ;954
0000c0  4630              MOV      r0,r6                 ;955
0000c2  f7fffffe          BL       OS_CPU_SR_Restore
                  |L8.198|
0000c6  f8940032          LDRB     r0,[r4,#0x32]         ;935
0000ca  283f              CMP      r0,#0x3f              ;935
0000cc  d1c7              BNE      |L8.94|
                  |L8.206|
0000ce  bf00              NOP      
0000d0  e7c1              B        |L8.86|
;;;959    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L8.212|
                          DCD      OSTime
                  |L8.216|
                          DCD      OSRunning
                  |L8.220|
                          DCD      OSTickStepState
                  |L8.224|
                          DCD      OSTCBList
                  |L8.228|
                          DCD      OSRdyGrp
                  |L8.232|
                          DCD      OSRdyTbl

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;974    
;;;975    INT16U  OSVersion (void)
000000  f2401023          MOV      r0,#0x123
;;;976    {
;;;977        return (OS_VERSION);
;;;978    }
000004  4770              BX       lr
;;;979    
                          ENDP


                          AREA ||i.OS_Dummy||, CODE, READONLY, ALIGN=1

                  OS_Dummy PROC
;;;993    #if OS_TASK_DEL_EN > 0u
;;;994    void  OS_Dummy (void)
000000  4770              BX       lr
;;;995    {
;;;996    }
;;;997    #endif
                          ENDP


                          AREA ||i.OS_EventTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_EventTaskRdy PROC
;;;1027   #if (OS_EVENT_EN)
;;;1028   INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1029                           void      *pmsg,
;;;1030                           INT8U      msk,
;;;1031                           INT8U      pend_stat)
;;;1032   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;1033       OS_TCB   *ptcb;
;;;1034       INT8U     y;
;;;1035       INT8U     x;
;;;1036       INT8U     prio;
;;;1037   #if OS_LOWEST_PRIO > 63u
;;;1038       OS_PRIO  *ptbl;
;;;1039   #endif
;;;1040   
;;;1041   
;;;1042   #if OS_LOWEST_PRIO <= 63u
;;;1043       y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00000c  7aa8              LDRB     r0,[r5,#0xa]
00000e  4919              LDR      r1,|L11.116|
000010  5c0e              LDRB     r6,[r1,r0]
;;;1044       x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000012  f105000b          ADD      r0,r5,#0xb
000016  5d80              LDRB     r0,[r0,r6]
000018  f811b000          LDRB     r11,[r1,r0]
;;;1045       prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
00001c  eb0b00c6          ADD      r0,r11,r6,LSL #3
000020  f0000aff          AND      r10,r0,#0xff
;;;1046   #else
;;;1047       if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
;;;1048           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
;;;1049       } else {
;;;1050           y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
;;;1051       }
;;;1052       ptbl = &pevent->OSEventTbl[y];
;;;1053       if ((*ptbl & 0xFFu) != 0u) {
;;;1054           x = OSUnMapTbl[*ptbl & 0xFFu];
;;;1055       } else {
;;;1056           x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
;;;1057       }
;;;1058       prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
;;;1059   #endif
;;;1060   
;;;1061       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000024  4814              LDR      r0,|L11.120|
000026  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1062       ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
00002a  2000              MOVS     r0,#0
00002c  3420              ADDS     r4,r4,#0x20
00002e  60e0              STR      r0,[r4,#0xc]
;;;1063   #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
;;;1064       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000030  6027              STR      r7,[r4,#0]
;;;1065   #else
;;;1066       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1067   #endif
;;;1068       ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
000032  7c20              LDRB     r0,[r4,#0x10]
000034  ea200008          BIC      r0,r0,r8
000038  7420              STRB     r0,[r4,#0x10]
;;;1069       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00003a  f8849011          STRB     r9,[r4,#0x11]
;;;1070                                                           /* See if task is ready (could be susp'd)      */
;;;1071       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
00003e  7c20              LDRB     r0,[r4,#0x10]
000040  3c20              SUBS     r4,r4,#0x20
000042  f0000008          AND      r0,r0,#8
000046  b968              CBNZ     r0,|L11.100|
;;;1072           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000048  f8940036          LDRB     r0,[r4,#0x36]
00004c  490b              LDR      r1,|L11.124|
00004e  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000050  4308              ORRS     r0,r0,r1
000052  490a              LDR      r1,|L11.124|
000054  7008              STRB     r0,[r1,#0]
;;;1073           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000056  480a              LDR      r0,|L11.128|
000058  5d80              LDRB     r0,[r0,r6]
00005a  f8941035          LDRB     r1,[r4,#0x35]
00005e  4308              ORRS     r0,r0,r1
000060  4907              LDR      r1,|L11.128|
000062  5588              STRB     r0,[r1,r6]
                  |L11.100|
;;;1074       }
;;;1075   
;;;1076       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OS_EventTaskRemove
;;;1077   #if (OS_EVENT_MULTI_EN > 0u)
;;;1078       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
;;;1079           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
;;;1080           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
;;;1081       }
;;;1082   #endif
;;;1083   
;;;1084       return (prio);
00006c  4650              MOV      r0,r10
;;;1085   }
00006e  e8bd8ff0          POP      {r4-r11,pc}
;;;1086   #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L11.116|
                          DCD      OSUnMapTbl
                  |L11.120|
                          DCD      OSTCBPrioTbl
                  |L11.124|
                          DCD      OSRdyGrp
                  |L11.128|
                          DCD      OSRdyTbl

                          AREA ||i.OS_EventTaskRemove||, CODE, READONLY, ALIGN=1

                  OS_EventTaskRemove PROC
;;;1179   #if (OS_EVENT_EN)
;;;1180   void  OS_EventTaskRemove (OS_TCB   *ptcb,
000000  b510              PUSH     {r4,lr}
;;;1181                             OS_EVENT *pevent)
;;;1182   {
;;;1183       INT8U  y;
;;;1184   
;;;1185   
;;;1186       y                       =  ptcb->OSTCBY;
000002  f8902034          LDRB     r2,[r0,#0x34]
;;;1187       pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
000006  f101030b          ADD      r3,r1,#0xb
00000a  5c9b              LDRB     r3,[r3,r2]
00000c  f8904035          LDRB     r4,[r0,#0x35]
000010  43a3              BICS     r3,r3,r4
000012  f101040b          ADD      r4,r1,#0xb
000016  54a3              STRB     r3,[r4,r2]
;;;1188       if (pevent->OSEventTbl[y] == 0u) {
000018  4623              MOV      r3,r4
00001a  5c9b              LDRB     r3,[r3,r2]
00001c  b923              CBNZ     r3,|L12.40|
;;;1189           pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00001e  7a8b              LDRB     r3,[r1,#0xa]
000020  f8904036          LDRB     r4,[r0,#0x36]
000024  43a3              BICS     r3,r3,r4
000026  728b              STRB     r3,[r1,#0xa]
                  |L12.40|
;;;1190       }
;;;1191   }
000028  bd10              POP      {r4,pc}
;;;1192   #endif
                          ENDP


                          AREA ||i.OS_EventTaskWait||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWait PROC
;;;1102   #if (OS_EVENT_EN)
;;;1103   void  OS_EventTaskWait (OS_EVENT *pevent)
000000  b510              PUSH     {r4,lr}
;;;1104   {
;;;1105       INT8U  y;
;;;1106   
;;;1107   
;;;1108       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000002  4a1b              LDR      r2,|L13.112|
000004  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000006  61d0              STR      r0,[r2,#0x1c]
;;;1109   
;;;1110       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000008  4a19              LDR      r2,|L13.112|
00000a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00000c  f8923034          LDRB     r3,[r2,#0x34]
000010  f100020b          ADD      r2,r0,#0xb
000014  5cd2              LDRB     r2,[r2,r3]
000016  4b16              LDR      r3,|L13.112|
000018  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00001a  f8933035          LDRB     r3,[r3,#0x35]
00001e  431a              ORRS     r2,r2,r3
000020  4b13              LDR      r3,|L13.112|
000022  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000024  f8934034          LDRB     r4,[r3,#0x34]
000028  f100030b          ADD      r3,r0,#0xb
00002c  551a              STRB     r2,[r3,r4]
;;;1111       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00002e  7a82              LDRB     r2,[r0,#0xa]
000030  4b0f              LDR      r3,|L13.112|
000032  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000034  f8933036          LDRB     r3,[r3,#0x36]
000038  431a              ORRS     r2,r2,r3
00003a  7282              STRB     r2,[r0,#0xa]
;;;1112   
;;;1113       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00003c  4a0c              LDR      r2,|L13.112|
00003e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000040  f8921034          LDRB     r1,[r2,#0x34]
;;;1114       OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000044  4a0b              LDR      r2,|L13.116|
000046  5c52              LDRB     r2,[r2,r1]
000048  4b09              LDR      r3,|L13.112|
00004a  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00004c  f8933035          LDRB     r3,[r3,#0x35]
000050  439a              BICS     r2,r2,r3
000052  4b08              LDR      r3,|L13.116|
000054  545a              STRB     r2,[r3,r1]
;;;1115       if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000056  461a              MOV      r2,r3
000058  5c52              LDRB     r2,[r2,r1]
00005a  b942              CBNZ     r2,|L13.110|
;;;1116           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00005c  4a04              LDR      r2,|L13.112|
00005e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000060  f8923036          LDRB     r3,[r2,#0x36]
000064  4a04              LDR      r2,|L13.120|
000066  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000068  439a              BICS     r2,r2,r3
00006a  4b03              LDR      r3,|L13.120|
00006c  701a              STRB     r2,[r3,#0]
                  |L13.110|
;;;1117       }
;;;1118   }
00006e  bd10              POP      {r4,pc}
;;;1119   #endif
                          ENDP

                  |L13.112|
                          DCD      OSTCBCur
                  |L13.116|
                          DCD      OSRdyTbl
                  |L13.120|
                          DCD      OSRdyGrp

                          AREA ||i.OS_EventWaitListInit||, CODE, READONLY, ALIGN=1

                  OS_EventWaitListInit PROC
;;;1249   #if (OS_EVENT_EN)
;;;1250   void  OS_EventWaitListInit (OS_EVENT *pevent)
000000  4601              MOV      r1,r0
;;;1251   {
;;;1252       INT8U  i;
;;;1253   
;;;1254   
;;;1255       pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000002  2200              MOVS     r2,#0
000004  728a              STRB     r2,[r1,#0xa]
;;;1256       for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000006  2000              MOVS     r0,#0
000008  e005              B        |L14.22|
                  |L14.10|
;;;1257           pevent->OSEventTbl[i] = 0u;
00000a  2300              MOVS     r3,#0
00000c  f101020b          ADD      r2,r1,#0xb
000010  5413              STRB     r3,[r2,r0]
000012  1c42              ADDS     r2,r0,#1              ;1256
000014  b2d0              UXTB     r0,r2                 ;1256
                  |L14.22|
000016  2808              CMP      r0,#8                 ;1256
000018  d3f7              BCC      |L14.10|
;;;1258       }
;;;1259   }
00001a  4770              BX       lr
;;;1260   #endif
                          ENDP


                          AREA ||i.OS_InitEventList||, CODE, READONLY, ALIGN=2

                  OS_InitEventList PROC
;;;1274   
;;;1275   static  void  OS_InitEventList (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1276   {
;;;1277   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
;;;1278   #if (OS_MAX_EVENTS > 1u)
;;;1279       INT16U     ix;
;;;1280       INT16U     ix_next;
;;;1281       OS_EVENT  *pevent1;
;;;1282       OS_EVENT  *pevent2;
;;;1283   
;;;1284   
;;;1285       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000002  21c8              MOVS     r1,#0xc8
000004  4811              LDR      r0,|L15.76|
000006  f7fffffe          BL       OS_MemClr
;;;1286       for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
00000a  2300              MOVS     r3,#0
00000c  e00f              B        |L15.46|
                  |L15.14|
;;;1287           ix_next = ix + 1u;
00000e  1c58              ADDS     r0,r3,#1
000010  b285              UXTH     r5,r0
;;;1288           pevent1 = &OSEventTbl[ix];
000012  eb030083          ADD      r0,r3,r3,LSL #2
000016  490d              LDR      r1,|L15.76|
000018  eb010480          ADD      r4,r1,r0,LSL #2
;;;1289           pevent2 = &OSEventTbl[ix_next];
00001c  eb050085          ADD      r0,r5,r5,LSL #2
000020  eb010680          ADD      r6,r1,r0,LSL #2
;;;1290           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
000024  2000              MOVS     r0,#0
000026  7020              STRB     r0,[r4,#0]
;;;1291           pevent1->OSEventPtr     = pevent2;
000028  6066              STR      r6,[r4,#4]
00002a  1c58              ADDS     r0,r3,#1              ;1286
00002c  b283              UXTH     r3,r0                 ;1286
                  |L15.46|
00002e  2b09              CMP      r3,#9                 ;1286
000030  d3ed              BCC      |L15.14|
;;;1292   #if OS_EVENT_NAME_EN > 0u
;;;1293           pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
;;;1294   #endif
;;;1295       }
;;;1296       pevent1                         = &OSEventTbl[ix];
000032  eb030083          ADD      r0,r3,r3,LSL #2
000036  4905              LDR      r1,|L15.76|
000038  eb010480          ADD      r4,r1,r0,LSL #2
;;;1297       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00003c  2000              MOVS     r0,#0
00003e  7020              STRB     r0,[r4,#0]
;;;1298       pevent1->OSEventPtr             = (OS_EVENT *)0;
000040  6060              STR      r0,[r4,#4]
;;;1299   #if OS_EVENT_NAME_EN > 0u
;;;1300       pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
;;;1301   #endif
;;;1302       OSEventFreeList                 = &OSEventTbl[0];
000042  4608              MOV      r0,r1
000044  4902              LDR      r1,|L15.80|
000046  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1303   #else
;;;1304       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1305       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1306       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1307   #if OS_EVENT_NAME_EN > 0u
;;;1308       OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
;;;1309   #endif
;;;1310   #endif
;;;1311   #endif
;;;1312   }
000048  bd70              POP      {r4-r6,pc}
;;;1313   /*$PAGE*/
                          ENDP

00004a  0000              DCW      0x0000
                  |L15.76|
                          DCD      OSEventTbl
                  |L15.80|
                          DCD      OSEventFreeList

                          AREA ||i.OS_InitMisc||, CODE, READONLY, ALIGN=2

                  OS_InitMisc PROC
;;;1326   
;;;1327   static  void  OS_InitMisc (void)
000000  2000              MOVS     r0,#0
;;;1328   {
;;;1329   #if OS_TIME_GET_SET_EN > 0u
;;;1330       OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
000002  490a              LDR      r1,|L16.44|
000004  6008              STR      r0,[r1,#0]  ; OSTime
;;;1331   #endif
;;;1332   
;;;1333       OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000006  490a              LDR      r1,|L16.48|
000008  7008              STRB     r0,[r1,#0]
;;;1334       OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
00000a  490a              LDR      r1,|L16.52|
00000c  7008              STRB     r0,[r1,#0]
;;;1335   
;;;1336       OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
00000e  490a              LDR      r1,|L16.56|
000010  7008              STRB     r0,[r1,#0]
;;;1337   
;;;1338       OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000012  490a              LDR      r1,|L16.60|
000014  7008              STRB     r0,[r1,#0]
;;;1339   
;;;1340       OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
000016  490a              LDR      r1,|L16.64|
000018  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1341       OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
00001a  490a              LDR      r1,|L16.68|
00001c  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1342   
;;;1343   #if OS_TASK_STAT_EN > 0u
;;;1344       OSIdleCtrRun              = 0uL;
00001e  490a              LDR      r1,|L16.72|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1345       OSIdleCtrMax              = 0uL;
000022  490a              LDR      r1,|L16.76|
000024  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1346       OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
000026  490a              LDR      r1,|L16.80|
000028  7008              STRB     r0,[r1,#0]
;;;1347   #endif
;;;1348   
;;;1349   #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;1350       OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
;;;1351   #endif
;;;1352   }
00002a  4770              BX       lr
;;;1353   /*$PAGE*/
                          ENDP

                  |L16.44|
                          DCD      OSTime
                  |L16.48|
                          DCD      OSIntNesting
                  |L16.52|
                          DCD      OSLockNesting
                  |L16.56|
                          DCD      OSTaskCtr
                  |L16.60|
                          DCD      OSRunning
                  |L16.64|
                          DCD      OSCtxSwCtr
                  |L16.68|
                          DCD      OSIdleCtr
                  |L16.72|
                          DCD      OSIdleCtrRun
                  |L16.76|
                          DCD      OSIdleCtrMax
                  |L16.80|
                          DCD      OSStatRdy

                          AREA ||i.OS_InitRdyList||, CODE, READONLY, ALIGN=2

                  OS_InitRdyList PROC
;;;1366   
;;;1367   static  void  OS_InitRdyList (void)
000000  2100              MOVS     r1,#0
;;;1368   {
;;;1369       INT8U  i;
;;;1370   
;;;1371   
;;;1372       OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
000002  4a0a              LDR      r2,|L17.44|
000004  7011              STRB     r1,[r2,#0]
;;;1373       for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
000006  2000              MOVS     r0,#0
000008  e004              B        |L17.20|
                  |L17.10|
;;;1374           OSRdyTbl[i] = 0u;
00000a  2100              MOVS     r1,#0
00000c  4a08              LDR      r2,|L17.48|
00000e  5411              STRB     r1,[r2,r0]
000010  1c41              ADDS     r1,r0,#1              ;1373
000012  b2c8              UXTB     r0,r1                 ;1373
                  |L17.20|
000014  2808              CMP      r0,#8                 ;1373
000016  d3f8              BCC      |L17.10|
;;;1375       }
;;;1376   
;;;1377       OSPrioCur     = 0u;
000018  2100              MOVS     r1,#0
00001a  4a06              LDR      r2,|L17.52|
00001c  7011              STRB     r1,[r2,#0]
;;;1378       OSPrioHighRdy = 0u;
00001e  4a06              LDR      r2,|L17.56|
000020  7011              STRB     r1,[r2,#0]
;;;1379   
;;;1380       OSTCBHighRdy  = (OS_TCB *)0;
000022  4a06              LDR      r2,|L17.60|
000024  6011              STR      r1,[r2,#0]  ; OSTCBHighRdy
;;;1381       OSTCBCur      = (OS_TCB *)0;
000026  4a06              LDR      r2,|L17.64|
000028  6011              STR      r1,[r2,#0]  ; OSTCBCur
;;;1382   }
00002a  4770              BX       lr
;;;1383   
                          ENDP

                  |L17.44|
                          DCD      OSRdyGrp
                  |L17.48|
                          DCD      OSRdyTbl
                  |L17.52|
                          DCD      OSPrioCur
                  |L17.56|
                          DCD      OSPrioHighRdy
                  |L17.60|
                          DCD      OSTCBHighRdy
                  |L17.64|
                          DCD      OSTCBCur

                          AREA ||i.OS_InitTCBList||, CODE, READONLY, ALIGN=2

                  OS_InitTCBList PROC
;;;1521   
;;;1522   static  void  OS_InitTCBList (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1523   {
;;;1524       INT8U    ix;
;;;1525       INT8U    ix_next;
;;;1526       OS_TCB  *ptcb1;
;;;1527       OS_TCB  *ptcb2;
;;;1528   
;;;1529   
;;;1530       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000002  f44f717c          MOV      r1,#0x3f0
000006  4819              LDR      r0,|L18.108|
000008  f7fffffe          BL       OS_MemClr
;;;1531       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00000c  f44f7180          MOV      r1,#0x100
000010  4817              LDR      r0,|L18.112|
000012  f7fffffe          BL       OS_MemClr
;;;1532       for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
000016  2400              MOVS     r4,#0
000018  e013              B        |L18.66|
                  |L18.26|
;;;1533           ix_next =  ix + 1u;
00001a  1c60              ADDS     r0,r4,#1
00001c  b2c5              UXTB     r5,r0
;;;1534           ptcb1   = &OSTCBTbl[ix];
00001e  ebc400c4          RSB      r0,r4,r4,LSL #3
000022  eb000040          ADD      r0,r0,r0,LSL #1
000026  4911              LDR      r1,|L18.108|
000028  eb010380          ADD      r3,r1,r0,LSL #2
;;;1535           ptcb2   = &OSTCBTbl[ix_next];
00002c  ebc500c5          RSB      r0,r5,r5,LSL #3
000030  eb000040          ADD      r0,r0,r0,LSL #1
000034  eb010680          ADD      r6,r1,r0,LSL #2
;;;1536           ptcb1->OSTCBNext = ptcb2;
000038  615e              STR      r6,[r3,#0x14]
;;;1537   #if OS_TASK_NAME_EN > 0u
;;;1538           ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
00003a  a00e              ADR      r0,|L18.116|
00003c  64d8              STR      r0,[r3,#0x4c]
00003e  1c60              ADDS     r0,r4,#1              ;1532
000040  b2c4              UXTB     r4,r0                 ;1532
                  |L18.66|
000042  2c0b              CMP      r4,#0xb               ;1532
000044  d3e9              BCC      |L18.26|
;;;1539   #endif
;;;1540       }
;;;1541       ptcb1                   = &OSTCBTbl[ix];
000046  ebc400c4          RSB      r0,r4,r4,LSL #3
00004a  eb000040          ADD      r0,r0,r0,LSL #1
00004e  4907              LDR      r1,|L18.108|
000050  eb010380          ADD      r3,r1,r0,LSL #2
;;;1542       ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
000054  2000              MOVS     r0,#0
000056  6158              STR      r0,[r3,#0x14]
;;;1543   #if OS_TASK_NAME_EN > 0u
;;;1544       ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
000058  a006              ADR      r0,|L18.116|
00005a  64d8              STR      r0,[r3,#0x4c]
;;;1545   #endif
;;;1546       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00005c  2000              MOVS     r0,#0
00005e  4906              LDR      r1,|L18.120|
000060  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1547       OSTCBFreeList           = &OSTCBTbl[0];
000062  4802              LDR      r0,|L18.108|
000064  4905              LDR      r1,|L18.124|
000066  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1548   }
000068  bd70              POP      {r4-r6,pc}
;;;1549   /*$PAGE*/
                          ENDP

00006a  0000              DCW      0x0000
                  |L18.108|
                          DCD      OSTCBTbl
                  |L18.112|
                          DCD      OSTCBPrioTbl
                  |L18.116|
000074  3f00              DCB      "?",0
000076  00                DCB      0
000077  00                DCB      0
                  |L18.120|
                          DCD      OSTCBList
                  |L18.124|
                          DCD      OSTCBFreeList

                          AREA ||i.OS_InitTaskIdle||, CODE, READONLY, ALIGN=2

                  OS_InitTaskIdle PROC
;;;1397   
;;;1398   static  void  OS_InitTaskIdle (void)
000000  b500              PUSH     {lr}
;;;1399   {
000002  b087              SUB      sp,sp,#0x1c
;;;1400   #if OS_TASK_NAME_EN > 0u
;;;1401       INT8U  err;
;;;1402   #endif
;;;1403   
;;;1404   
;;;1405   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1406       #if OS_STK_GROWTH == 1u
;;;1407       (void)OSTaskCreateExt(OS_TaskIdle,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L19.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70ff          MOV      r0,#0xffff
000018  233f              MOVS     r3,#0x3f
00001a  4a07              LDR      r2,|L19.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L19.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1408                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1409                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
;;;1410                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1411                             OS_TASK_IDLE_ID,
;;;1412                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1413                             OS_TASK_IDLE_STK_SIZE,
;;;1414                             (void *)0,                                 /* No TCB extension                     */
;;;1415                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1416       #else
;;;1417       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1418                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1419                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1420                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1421                             OS_TASK_IDLE_ID,
;;;1422                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
;;;1423                             OS_TASK_IDLE_STK_SIZE,
;;;1424                             (void *)0,                                 /* No TCB extension                     */
;;;1425                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1426       #endif
;;;1427   #else
;;;1428       #if OS_STK_GROWTH == 1u
;;;1429       (void)OSTaskCreate(OS_TaskIdle,
;;;1430                          (void *)0,
;;;1431                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
;;;1432                          OS_TASK_IDLE_PRIO);
;;;1433       #else
;;;1434       (void)OSTaskCreate(OS_TaskIdle,
;;;1435                          (void *)0,
;;;1436                          &OSTaskIdleStk[0],
;;;1437                          OS_TASK_IDLE_PRIO);
;;;1438       #endif
;;;1439   #endif
;;;1440   
;;;1441   #if OS_TASK_NAME_EN > 0u
;;;1442       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L19.64|
000028  203f              MOVS     r0,#0x3f
00002a  f7fffffe          BL       OSTaskNameSet
;;;1443   #endif
;;;1444   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1445   /*$PAGE*/
                          ENDP

000032  0000              DCW      0x0000
                  |L19.52|
                          DCD      OSTaskIdleStk
                  |L19.56|
                          DCD      OSTaskIdleStk+0x1fc
                  |L19.60|
                          DCD      OS_TaskIdle
                  |L19.64|
000040  75432f4f          DCB      "uC/OS-II Idle",0
000044  532d4949
000048  2049646c
00004c  6500    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_InitTaskStat||, CODE, READONLY, ALIGN=2

                  OS_InitTaskStat PROC
;;;1459   #if OS_TASK_STAT_EN > 0u
;;;1460   static  void  OS_InitTaskStat (void)
000000  b500              PUSH     {lr}
;;;1461   {
000002  b087              SUB      sp,sp,#0x1c
;;;1462   #if OS_TASK_NAME_EN > 0u
;;;1463       INT8U  err;
;;;1464   #endif
;;;1465   
;;;1466   
;;;1467   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1468       #if OS_STK_GROWTH == 1u
;;;1469       (void)OSTaskCreateExt(OS_TaskStat,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L20.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70fe          MOV      r0,#0xfffe
000018  233e              MOVS     r3,#0x3e
00001a  4a07              LDR      r2,|L20.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L20.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1470                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1471                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
;;;1472                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1473                             OS_TASK_STAT_ID,
;;;1474                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1475                             OS_TASK_STAT_STK_SIZE,
;;;1476                             (void *)0,                                   /* No TCB extension               */
;;;1477                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1478       #else
;;;1479       (void)OSTaskCreateExt(OS_TaskStat,
;;;1480                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1481                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1482                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1483                             OS_TASK_STAT_ID,
;;;1484                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
;;;1485                             OS_TASK_STAT_STK_SIZE,
;;;1486                             (void *)0,                                   /* No TCB extension               */
;;;1487                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1488       #endif
;;;1489   #else
;;;1490       #if OS_STK_GROWTH == 1u
;;;1491       (void)OSTaskCreate(OS_TaskStat,
;;;1492                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1493                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
;;;1494                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1495       #else
;;;1496       (void)OSTaskCreate(OS_TaskStat,
;;;1497                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1498                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1499                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1500       #endif
;;;1501   #endif
;;;1502   
;;;1503   #if OS_TASK_NAME_EN > 0u
;;;1504       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L20.64|
000028  203e              MOVS     r0,#0x3e
00002a  f7fffffe          BL       OSTaskNameSet
;;;1505   #endif
;;;1506   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1507   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L20.52|
                          DCD      OSTaskStatStk
                  |L20.56|
                          DCD      OSTaskStatStk+0x1fc
                  |L20.60|
                          DCD      OS_TaskStat
                  |L20.64|
000040  75432f4f          DCB      "uC/OS-II Stat",0
000044  532d4949
000048  20537461
00004c  7400    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_MemClr||, CODE, READONLY, ALIGN=1

                  OS_MemClr PROC
;;;1569   
;;;1570   void  OS_MemClr (INT8U  *pdest,
000000  e004              B        |L21.12|
                  |L21.2|
;;;1571                    INT16U  size)
;;;1572   {
;;;1573       while (size > 0u) {
;;;1574           *pdest++ = (INT8U)0;
000002  2200              MOVS     r2,#0
000004  f8002b01          STRB     r2,[r0],#1
;;;1575           size--;
000008  1e4a              SUBS     r2,r1,#1
00000a  b291              UXTH     r1,r2
                  |L21.12|
00000c  2900              CMP      r1,#0                 ;1573
00000e  d1f8              BNE      |L21.2|
;;;1576       }
;;;1577   }
000010  4770              BX       lr
;;;1578   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_MemCopy||, CODE, READONLY, ALIGN=1

                  OS_MemCopy PROC
;;;1602   
;;;1603   void  OS_MemCopy (INT8U  *pdest,
000000  e005              B        |L22.14|
                  |L22.2|
;;;1604                     INT8U  *psrc,
;;;1605                     INT16U  size)
;;;1606   {
;;;1607       while (size > 0u) {
;;;1608           *pdest++ = *psrc++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
;;;1609           size--;
00000a  1e53              SUBS     r3,r2,#1
00000c  b29a              UXTH     r2,r3
                  |L22.14|
00000e  2a00              CMP      r2,#0                 ;1607
000010  d1f7              BNE      |L22.2|
;;;1610       }
;;;1611   }
000012  4770              BX       lr
;;;1612   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_Sched||, CODE, READONLY, ALIGN=2

                  OS_Sched PROC
;;;1629   
;;;1630   void  OS_Sched (void)
000000  b510              PUSH     {r4,lr}
;;;1631   {
;;;1632   #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;1633       OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;1634   #endif
;;;1635   
;;;1636   
;;;1637   
;;;1638       OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4604              MOV      r4,r0
;;;1639       if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
00000a  4813              LDR      r0,|L23.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b9f8              CBNZ     r0,|L23.80|
;;;1640           if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
000010  4812              LDR      r0,|L23.92|
000012  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000014  b9e0              CBNZ     r0,|L23.80|
;;;1641               OS_SchedNew();
000016  f7fffffe          BL       OS_SchedNew
;;;1642               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00001a  4811              LDR      r0,|L23.96|
00001c  4911              LDR      r1,|L23.100|
00001e  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000020  f8500021          LDR      r0,[r0,r1,LSL #2]
000024  4910              LDR      r1,|L23.104|
000026  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1643               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
000028  480e              LDR      r0,|L23.100|
00002a  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00002c  490f              LDR      r1,|L23.108|
00002e  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000030  4288              CMP      r0,r1
000032  d00d              BEQ      |L23.80|
;;;1644   #if OS_TASK_PROFILE_EN > 0u
;;;1645                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000034  480c              LDR      r0,|L23.104|
000036  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000038  6b80              LDR      r0,[r0,#0x38]
00003a  1c40              ADDS     r0,r0,#1
00003c  490a              LDR      r1,|L23.104|
00003e  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000040  6388              STR      r0,[r1,#0x38]
;;;1646   #endif
;;;1647                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000042  480b              LDR      r0,|L23.112|
000044  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000046  1c40              ADDS     r0,r0,#1
000048  4909              LDR      r1,|L23.112|
00004a  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1648                   OS_TASK_SW();                          /* Perform a context switch                     */
00004c  f7fffffe          BL       OSCtxSw
                  |L23.80|
;;;1649               }
;;;1650           }
;;;1651       }
;;;1652       OS_EXIT_CRITICAL();
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       OS_CPU_SR_Restore
;;;1653   }
000056  bd10              POP      {r4,pc}
;;;1654   
                          ENDP

                  |L23.88|
                          DCD      OSIntNesting
                  |L23.92|
                          DCD      OSLockNesting
                  |L23.96|
                          DCD      OSTCBPrioTbl
                  |L23.100|
                          DCD      OSPrioHighRdy
                  |L23.104|
                          DCD      OSTCBHighRdy
                  |L23.108|
                          DCD      OSPrioCur
                  |L23.112|
                          DCD      OSCtxSwCtr

                          AREA ||i.OS_SchedNew||, CODE, READONLY, ALIGN=2

                  OS_SchedNew PROC
;;;1671   
;;;1672   static  void  OS_SchedNew (void)
000000  4906              LDR      r1,|L24.28|
;;;1673   {
;;;1674   #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
;;;1675       INT8U   y;
;;;1676   
;;;1677   
;;;1678       y             = OSUnMapTbl[OSRdyGrp];
000002  4a07              LDR      r2,|L24.32|
000004  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000006  5c88              LDRB     r0,[r1,r2]
;;;1679       OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
000008  4906              LDR      r1,|L24.36|
00000a  5c09              LDRB     r1,[r1,r0]
00000c  4a03              LDR      r2,|L24.28|
00000e  5c51              LDRB     r1,[r2,r1]
000010  eb0101c0          ADD      r1,r1,r0,LSL #3
000014  4a04              LDR      r2,|L24.40|
000016  7011              STRB     r1,[r2,#0]
;;;1680   #else                                            /* We support up to 256 tasks                         */
;;;1681       INT8U     y;
;;;1682       OS_PRIO  *ptbl;
;;;1683   
;;;1684   
;;;1685       if ((OSRdyGrp & 0xFFu) != 0u) {
;;;1686           y = OSUnMapTbl[OSRdyGrp & 0xFFu];
;;;1687       } else {
;;;1688           y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
;;;1689       }
;;;1690       ptbl = &OSRdyTbl[y];
;;;1691       if ((*ptbl & 0xFFu) != 0u) {
;;;1692           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
;;;1693       } else {
;;;1694           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
;;;1695       }
;;;1696   #endif
;;;1697   }
000018  4770              BX       lr
;;;1698   
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      OSUnMapTbl
                  |L24.32|
                          DCD      OSRdyGrp
                  |L24.36|
                          DCD      OSRdyTbl
                  |L24.40|
                          DCD      OSPrioHighRdy

                          AREA ||i.OS_StrLen||, CODE, READONLY, ALIGN=1

                  OS_StrLen PROC
;;;1716   #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
;;;1717   INT8U  OS_StrLen (INT8U *psrc)
000000  4601              MOV      r1,r0
;;;1718   {
;;;1719       INT8U  len;
;;;1720   
;;;1721   
;;;1722       len = 0u;
000002  2000              MOVS     r0,#0
;;;1723       while (*psrc != OS_ASCII_NUL) {
000004  e002              B        |L25.12|
                  |L25.6|
;;;1724           psrc++;
000006  1c49              ADDS     r1,r1,#1
;;;1725           len++;
000008  1c42              ADDS     r2,r0,#1
00000a  b2d0              UXTB     r0,r2
                  |L25.12|
00000c  780a              LDRB     r2,[r1,#0]            ;1723
00000e  2a00              CMP      r2,#0                 ;1723
000010  d1f9              BNE      |L25.6|
;;;1726       }
;;;1727       return (len);
;;;1728   }
000012  4770              BX       lr
;;;1729   #endif
                          ENDP


                          AREA ||i.OS_TCBInit||, CODE, READONLY, ALIGN=2

                  OS_TCBInit PROC
;;;1916   
;;;1917   INT8U  OS_TCBInit (INT8U    prio,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1918                      OS_STK  *ptos,
;;;1919                      OS_STK  *pbos,
;;;1920                      INT16U   id,
;;;1921                      INT32U   stk_size,
;;;1922                      void    *pext,
;;;1923                      INT16U   opt)
;;;1924   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;1925       OS_TCB    *ptcb;
;;;1926   #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;1927       OS_CPU_SR  cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1928   #endif
;;;1929   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1930       INT8U      i;
;;;1931   #endif
;;;1932   
;;;1933   
;;;1934       OS_ENTER_CRITICAL();
000014  f7fffffe          BL       OS_CPU_SR_Save
000018  9000              STR      r0,[sp,#0]
;;;1935       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001a  483f              LDR      r0,|L26.280|
00001c  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1936       if (ptcb != (OS_TCB *)0) {
00001e  2c00              CMP      r4,#0
000020  d074              BEQ      |L26.268|
;;;1937           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000022  3418              ADDS     r4,r4,#0x18
000024  f8540c04          LDR      r0,[r4,#-4]
000028  493b              LDR      r1,|L26.280|
00002a  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1938           OS_EXIT_CRITICAL();
00002c  9800              LDR      r0,[sp,#0]
00002e  f7fffffe          BL       OS_CPU_SR_Restore
;;;1939           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000032  f8447c18          STR      r7,[r4,#-0x18]
;;;1940           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
000036  76a5              STRB     r5,[r4,#0x1a]
;;;1941           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
000038  2000              MOVS     r0,#0
00003a  7620              STRB     r0,[r4,#0x18]
;;;1942           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
00003c  7660              STRB     r0,[r4,#0x19]
;;;1943           ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00003e  6160              STR      r0,[r4,#0x14]
;;;1944   
;;;1945   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1946           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000040  f844bc14          STR      r11,[r4,#-0x14]
;;;1947           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
000044  f844ac0c          STR      r10,[r4,#-0xc]
;;;1948           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
000048  f8448c10          STR      r8,[r4,#-0x10]
;;;1949           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00004c  980c              LDR      r0,[sp,#0x30]
00004e  f8240c08          STRH     r0,[r4,#-8]
;;;1950           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000052  f8249c06          STRH     r9,[r4,#-6]
;;;1951   #else
;;;1952           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1953           stk_size                 = stk_size;
;;;1954           pbos                     = pbos;
;;;1955           opt                      = opt;
;;;1956           id                       = id;
;;;1957   #endif
;;;1958   
;;;1959   #if OS_TASK_DEL_EN > 0u
;;;1960           ptcb->OSTCBDelReq        = OS_ERR_NONE;
000056  2000              MOVS     r0,#0
000058  77e0              STRB     r0,[r4,#0x1f]
;;;1961   #endif
;;;1962   
;;;1963   #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
;;;1964           ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00005a  10e8              ASRS     r0,r5,#3
00005c  7720              STRB     r0,[r4,#0x1c]
;;;1965           ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
00005e  f0050007          AND      r0,r5,#7
000062  76e0              STRB     r0,[r4,#0x1b]
;;;1966   #else                                                             /* Pre-compute X, Y                  */
;;;1967           ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
;;;1968           ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
;;;1969   #endif
;;;1970                                                                     /* Pre-compute BitX and BitY         */
;;;1971           ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
000064  7f21              LDRB     r1,[r4,#0x1c]
000066  2001              MOVS     r0,#1
000068  4088              LSLS     r0,r0,r1
00006a  77a0              STRB     r0,[r4,#0x1e]
;;;1972           ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
00006c  7ee1              LDRB     r1,[r4,#0x1b]
00006e  2001              MOVS     r0,#1
000070  4088              LSLS     r0,r0,r1
000072  7760              STRB     r0,[r4,#0x1d]
;;;1973   
;;;1974   #if (OS_EVENT_EN)
;;;1975           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000074  2000              MOVS     r0,#0
000076  6060              STR      r0,[r4,#4]
;;;1976   #if (OS_EVENT_MULTI_EN > 0u)
;;;1977           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
;;;1978   #endif
;;;1979   #endif
;;;1980   
;;;1981   #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
;;;1982           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000078  60e0              STR      r0,[r4,#0xc]
;;;1983   #endif
;;;1984   
;;;1985   #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;1986           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00007a  60a0              STR      r0,[r4,#8]
;;;1987   #endif
;;;1988   
;;;1989   #if OS_TASK_PROFILE_EN > 0u
;;;1990           ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
00007c  6220              STR      r0,[r4,#0x20]
;;;1991           ptcb->OSTCBCyclesStart = 0uL;
00007e  62a0              STR      r0,[r4,#0x28]
;;;1992           ptcb->OSTCBCyclesTot   = 0uL;
000080  6260              STR      r0,[r4,#0x24]
;;;1993           ptcb->OSTCBStkBase     = (OS_STK *)0;
000082  62e0              STR      r0,[r4,#0x2c]
;;;1994           ptcb->OSTCBStkUsed     = 0uL;
000084  6320              STR      r0,[r4,#0x30]
;;;1995   #endif
;;;1996   
;;;1997   #if OS_TASK_NAME_EN > 0u
;;;1998           ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
000086  a025              ADR      r0,|L26.284|
000088  6360              STR      r0,[r4,#0x34]
00008a  3c18              SUBS     r4,r4,#0x18
;;;1999   #endif
;;;2000   
;;;2001   #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
;;;2002           for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
00008c  2600              MOVS     r6,#0
00008e  e006              B        |L26.158|
                  |L26.144|
;;;2003               ptcb->OSTCBRegTbl[i] = 0u;
000090  2100              MOVS     r1,#0
000092  f1040050          ADD      r0,r4,#0x50
000096  f8401026          STR      r1,[r0,r6,LSL #2]
00009a  1c70              ADDS     r0,r6,#1              ;2002
00009c  b2c6              UXTB     r6,r0                 ;2002
                  |L26.158|
00009e  2e00              CMP      r6,#0                 ;2002
0000a0  d0f6              BEQ      |L26.144|
;;;2004           }
;;;2005   #endif
;;;2006   
;;;2007           OSTCBInitHook(ptcb);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       OSTCBInitHook
;;;2008   
;;;2009           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       OSTaskCreateHook
;;;2010   
;;;2011           OS_ENTER_CRITICAL();
0000ae  f7fffffe          BL       OS_CPU_SR_Save
0000b2  9000              STR      r0,[sp,#0]
;;;2012           OSTCBPrioTbl[prio] = ptcb;
0000b4  481a              LDR      r0,|L26.288|
0000b6  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2013           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0000ba  481a              LDR      r0,|L26.292|
0000bc  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000be  6160              STR      r0,[r4,#0x14]
;;;2014           ptcb->OSTCBPrev    = (OS_TCB *)0;
0000c0  2000              MOVS     r0,#0
0000c2  61a0              STR      r0,[r4,#0x18]
;;;2015           if (OSTCBList != (OS_TCB *)0) {
0000c4  4817              LDR      r0,|L26.292|
0000c6  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000c8  b110              CBZ      r0,|L26.208|
;;;2016               OSTCBList->OSTCBPrev = ptcb;
0000ca  4816              LDR      r0,|L26.292|
0000cc  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000ce  6184              STR      r4,[r0,#0x18]
                  |L26.208|
;;;2017           }
;;;2018           OSTCBList               = ptcb;
0000d0  4814              LDR      r0,|L26.292|
0000d2  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2019           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0000d4  3434              ADDS     r4,r4,#0x34
0000d6  78a0              LDRB     r0,[r4,#2]
0000d8  4913              LDR      r1,|L26.296|
0000da  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
0000dc  4308              ORRS     r0,r0,r1
0000de  4912              LDR      r1,|L26.296|
0000e0  7008              STRB     r0,[r1,#0]
;;;2020           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000e2  7820              LDRB     r0,[r4,#0]
0000e4  4911              LDR      r1,|L26.300|
0000e6  5c08              LDRB     r0,[r1,r0]
0000e8  7861              LDRB     r1,[r4,#1]
0000ea  4308              ORRS     r0,r0,r1
0000ec  f8141934          LDRB     r1,[r4],#-0x34
0000f0  4a0e              LDR      r2,|L26.300|
0000f2  5450              STRB     r0,[r2,r1]
;;;2021           OSTaskCtr++;                                       /* Increment the #tasks counter             */
0000f4  480e              LDR      r0,|L26.304|
0000f6  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
0000f8  1c40              ADDS     r0,r0,#1
0000fa  490d              LDR      r1,|L26.304|
0000fc  7008              STRB     r0,[r1,#0]
;;;2022           OS_EXIT_CRITICAL();
0000fe  9800              LDR      r0,[sp,#0]
000100  f7fffffe          BL       OS_CPU_SR_Restore
;;;2023           return (OS_ERR_NONE);
000104  2000              MOVS     r0,#0
                  |L26.262|
;;;2024       }
;;;2025       OS_EXIT_CRITICAL();
;;;2026       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2027   }
000106  e8bd8ff8          POP      {r3-r11,pc}
00010a  e7ff              B        |L26.268|
                  |L26.268|
00010c  9800              LDR      r0,[sp,#0]            ;2025
00010e  f7fffffe          BL       OS_CPU_SR_Restore
000112  2042              MOVS     r0,#0x42              ;2026
000114  e7f7              B        |L26.262|
;;;2028   	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  
                          ENDP

000116  0000              DCW      0x0000
                  |L26.280|
                          DCD      OSTCBFreeList
                  |L26.284|
00011c  3f00              DCB      "?",0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L26.288|
                          DCD      OSTCBPrioTbl
                  |L26.292|
                          DCD      OSTCBList
                  |L26.296|
                          DCD      OSRdyGrp
                  |L26.300|
                          DCD      OSRdyTbl
                  |L26.304|
                          DCD      OSTaskCtr

                          AREA ||i.OS_TaskIdle||, CODE, READONLY, ALIGN=2

                  OS_TaskIdle PROC
;;;1751   
;;;1752   void  OS_TaskIdle (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1753   {
;;;1754   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1755       OS_CPU_SR  cpu_sr = 0u;
;;;1756   #endif
;;;1757   
;;;1758   
;;;1759   
;;;1760       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000002  bf00              NOP      
;;;1761       for (;;) {
000004  bf00              NOP      
                  |L27.6|
;;;1762           OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4604              MOV      r4,r0
;;;1763           OSIdleCtr++;
00000c  4805              LDR      r0,|L27.36|
00000e  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000010  1c40              ADDS     r0,r0,#1
000012  4904              LDR      r1,|L27.36|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1764           OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;1765           OSTaskIdleHook();                        /* Call user definable HOOK                           */
00001c  f7fffffe          BL       OSTaskIdleHook
000020  e7f1              B        |L27.6|
;;;1766       }
;;;1767   }
;;;1768   /*$PAGE*/
                          ENDP

000022  0000              DCW      0x0000
                  |L27.36|
                          DCD      OSIdleCtr

                          AREA ||i.OS_TaskStat||, CODE, READONLY, ALIGN=2

                  OS_TaskStat PROC
;;;1793   #if OS_TASK_STAT_EN > 0u
;;;1794   void  OS_TaskStat (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1795   {
;;;1796   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1797       OS_CPU_SR  cpu_sr = 0u;
;;;1798   #endif
;;;1799   
;;;1800   
;;;1801   
;;;1802       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000002  bf00              NOP      
;;;1803       while (OSStatRdy == OS_FALSE) {
000004  e002              B        |L28.12|
                  |L28.6|
;;;1804           OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
000006  2028              MOVS     r0,#0x28
000008  f7fffffe          BL       OSTimeDly
                  |L28.12|
00000c  4819              LDR      r0,|L28.116|
00000e  7800              LDRB     r0,[r0,#0]            ;1803  ; OSStatRdy
000010  2800              CMP      r0,#0                 ;1803
000012  d0f8              BEQ      |L28.6|
;;;1805       }
;;;1806       OSIdleCtrMax /= 100uL;
000014  4818              LDR      r0,|L28.120|
000016  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000018  2164              MOVS     r1,#0x64
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  4916              LDR      r1,|L28.120|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1807       if (OSIdleCtrMax == 0uL) {
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000026  b928              CBNZ     r0,|L28.52|
;;;1808           OSCPUUsage = 0u;
000028  2000              MOVS     r0,#0
00002a  4914              LDR      r1,|L28.124|
00002c  7008              STRB     r0,[r1,#0]
;;;1809   #if OS_TASK_SUSPEND_EN > 0u
;;;1810           (void)OSTaskSuspend(OS_PRIO_SELF);
00002e  20ff              MOVS     r0,#0xff
000030  f7fffffe          BL       OSTaskSuspend
                  |L28.52|
;;;1811   #else
;;;1812           for (;;) {
;;;1813               OSTimeDly(OS_TICKS_PER_SEC);
;;;1814           }
;;;1815   #endif
;;;1816       }
;;;1817       for (;;) {
000034  bf00              NOP      
                  |L28.54|
;;;1818           OS_ENTER_CRITICAL();
000036  f7fffffe          BL       OS_CPU_SR_Save
00003a  4604              MOV      r4,r0
;;;1819           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
00003c  4810              LDR      r0,|L28.128|
00003e  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000040  4910              LDR      r1,|L28.132|
000042  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1820           OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
000044  2000              MOVS     r0,#0
000046  490e              LDR      r1,|L28.128|
000048  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1821           OS_EXIT_CRITICAL();
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_CPU_SR_Restore
;;;1822           OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
000050  480c              LDR      r0,|L28.132|
000052  6800              LDR      r0,[r0,#0]  ; OSIdleCtrRun
000054  4908              LDR      r1,|L28.120|
000056  6809              LDR      r1,[r1,#0]  ; OSIdleCtrMax
000058  fbb0f0f1          UDIV     r0,r0,r1
00005c  f1c00064          RSB      r0,r0,#0x64
000060  4906              LDR      r1,|L28.124|
000062  7008              STRB     r0,[r1,#0]
;;;1823           OSTaskStatHook();                        /* Invoke user definable hook                         */
000064  f7fffffe          BL       OSTaskStatHook
;;;1824   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1825           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000068  f7fffffe          BL       OS_TaskStatStkChk
;;;1826   #endif
;;;1827           OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
00006c  2014              MOVS     r0,#0x14
00006e  f7fffffe          BL       OSTimeDly
000072  e7e0              B        |L28.54|
;;;1828       }
;;;1829   }
;;;1830   #endif
                          ENDP

                  |L28.116|
                          DCD      OSStatRdy
                  |L28.120|
                          DCD      OSIdleCtrMax
                  |L28.124|
                          DCD      OSCPUUsage
                  |L28.128|
                          DCD      OSIdleCtr
                  |L28.132|
                          DCD      OSIdleCtrRun

                          AREA ||i.OS_TaskStatStkChk||, CODE, READONLY, ALIGN=2

                  OS_TaskStatStkChk PROC
;;;1844   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1845   void  OS_TaskStatStkChk (void)
000000  b57c              PUSH     {r2-r6,lr}
;;;1846   {
;;;1847       OS_TCB      *ptcb;
;;;1848       OS_STK_DATA  stk_data;
;;;1849       INT8U        err;
;;;1850       INT8U        prio;
;;;1851   
;;;1852   
;;;1853       for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
000002  2500              MOVS     r5,#0
000004  e014              B        |L29.48|
                  |L29.6|
;;;1854           err = OSTaskStkChk(prio, &stk_data);
000006  4669              MOV      r1,sp
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       OSTaskStkChk
00000e  4606              MOV      r6,r0
;;;1855           if (err == OS_ERR_NONE) {
000010  b966              CBNZ     r6,|L29.44|
;;;1856               ptcb = OSTCBPrioTbl[prio];
000012  4809              LDR      r0,|L29.56|
000014  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1857               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000018  b144              CBZ      r4,|L29.44|
;;;1858                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00001a  2c01              CMP      r4,#1
00001c  d006              BEQ      |L29.44|
;;;1859   #if OS_TASK_PROFILE_EN > 0u
;;;1860                       #if OS_STK_GROWTH == 1u
;;;1861                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001e  e9d40102          LDRD     r0,r1,[r4,#8]
000022  eb000081          ADD      r0,r0,r1,LSL #2
000026  6460              STR      r0,[r4,#0x44]
;;;1862                       #else
;;;1863                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1864                       #endif
;;;1865                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
000028  9801              LDR      r0,[sp,#4]
00002a  64a0              STR      r0,[r4,#0x48]
                  |L29.44|
00002c  1c68              ADDS     r0,r5,#1              ;1853
00002e  b2c5              UXTB     r5,r0                 ;1853
                  |L29.48|
000030  2d3f              CMP      r5,#0x3f              ;1853
000032  d9e8              BLS      |L29.6|
;;;1866   #endif
;;;1867                   }
;;;1868               }
;;;1869           }
;;;1870       }
;;;1871   }
000034  bd7c              POP      {r2-r6,pc}
;;;1872   #endif
                          ENDP

000036  0000              DCW      0x0000
                  |L29.56|
                          DCD      OSTCBPrioTbl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        200
                  OSFlagTbl
                          %        80
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        256
                  OSTCBTbl
                          %        1008
                  OSQTbl
                          %        120

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
                          DCD      0x00000000
000024  0000              DCB      0x00,0x00
                  OSRunning
000026  00                DCB      0x00
                  OSTaskCtr
000027  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
00003c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSQFreeList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000
