; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\modbusrtu.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\modbusrtu.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\modbusrtu.crf Protocol\ModbusRTU.c]
                          THUMB

                          AREA ||i.CRC16||, CODE, READONLY, ALIGN=2

                  CRC16 PROC
;;;48     
;;;49     u16 CRC16(u8 * _data_buf,u16 len)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;51     	u8 uchCRCHi=0xff;
000006  25ff              MOVS     r5,#0xff
;;;52     	u8 uchCRCLo=0xff;
000008  23ff              MOVS     r3,#0xff
;;;53     	u16 uindex;
;;;54     	while(len--){
00000a  e009              B        |L1.32|
                  |L1.12|
;;;55     		uindex = uchCRCHi^ *_data_buf++;
00000c  f8120b01          LDRB     r0,[r2],#1
000010  ea800105          EOR      r1,r0,r5
;;;56     		uchCRCHi = uchCRCLo^auchCRCHi[uindex];
000014  4806              LDR      r0,|L1.48|
000016  5c40              LDRB     r0,[r0,r1]
000018  ea800503          EOR      r5,r0,r3
;;;57     		uchCRCLo = auchCRCLo[uindex];
00001c  4805              LDR      r0,|L1.52|
00001e  5c43              LDRB     r3,[r0,r1]
                  |L1.32|
000020  1e20              SUBS     r0,r4,#0              ;54
000022  f1a40601          SUB      r6,r4,#1              ;54
000026  b2b4              UXTH     r4,r6                 ;54
000028  d1f0              BNE      |L1.12|
;;;58     	}
;;;59     	return (uchCRCHi<<8|uchCRCLo);
00002a  ea432005          ORR      r0,r3,r5,LSL #8
;;;60     } 
00002e  bd70              POP      {r4-r6,pc}
;;;61     
                          ENDP

                  |L1.48|
                          DCD      auchCRCHi
                  |L1.52|
                          DCD      auchCRCLo

                          AREA ||i.Modbus_01_Solve||, CODE, READONLY, ALIGN=2

                  Modbus_01_Solve PROC
;;;225    //读输出开关量
;;;226    void Modbus_01_Solve(u8 * _data_buf)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;227    {
000004  4606              MOV      r6,r0
;;;228    	u16 ByteNum;
;;;229    	u16 i;
;;;230    	u16 calCRC;
;;;231    	u16 RegNum;
;;;232    	u16 startRegAddr;
;;;233    	
;;;234    	startRegAddr=(((u16)_data_buf[2])<<8)|_data_buf[3];//获取寄存器起始地址
000006  78f0              LDRB     r0,[r6,#3]
000008  78b1              LDRB     r1,[r6,#2]
00000a  ea402901          ORR      r9,r0,r1,LSL #8
;;;235    	RegNum= (((u16)_data_buf[4])<<8)|_data_buf[5];//获取寄存器数量
00000e  7970              LDRB     r0,[r6,#5]
000010  7931              LDRB     r1,[r6,#4]
000012  ea402501          ORR      r5,r0,r1,LSL #8
;;;236    	if((startRegAddr+RegNum)<100)//寄存器地址+数量在范围内
000016  eb090005          ADD      r0,r9,r5
00001a  2864              CMP      r0,#0x64
00001c  da7e              BGE      |L2.284|
;;;237    	{
;;;238    		RS485_TX_BUFF[0]=_data_buf[0];
00001e  7830              LDRB     r0,[r6,#0]
000020  494d              LDR      r1,|L2.344|
000022  7008              STRB     r0,[r1,#0]
;;;239    		RS485_TX_BUFF[1]=_data_buf[1];
000024  7870              LDRB     r0,[r6,#1]
000026  7048              STRB     r0,[r1,#1]
;;;240    		ByteNum=RegNum/8;//字节数
000028  4628              MOV      r0,r5
00002a  17e9              ASRS     r1,r5,#31
00002c  eb057151          ADD      r1,r5,r1,LSR #29
000030  f3c107cf          UBFX     r7,r1,#3,#16
;;;241    		if(RegNum%8) ByteNum+=1;//如果位数还有余数，则字节数+1
000034  17e9              ASRS     r1,r5,#31
000036  eb057151          ADD      r1,r5,r1,LSR #29
00003a  10c9              ASRS     r1,r1,#3
00003c  eba501c1          SUB      r1,r5,r1,LSL #3
000040  b109              CBZ      r1,|L2.70|
000042  1c78              ADDS     r0,r7,#1
000044  b287              UXTH     r7,r0
                  |L2.70|
;;;242    		RS485_TX_BUFF[2]=ByteNum;//返回要读取的字节数
000046  4944              LDR      r1,|L2.344|
000048  708f              STRB     r7,[r1,#2]
;;;243    		for(i=0;i<RegNum;i++)
00004a  2400              MOVS     r4,#0
00004c  e05d              B        |L2.266|
                  |L2.78|
;;;244    		{
;;;245    			if(i%8==0) RS485_TX_BUFF[3+i/8]=0x00; //新字节开始
00004e  17e1              ASRS     r1,r4,#31
000050  eb047151          ADD      r1,r4,r1,LSR #29
000054  10c9              ASRS     r1,r1,#3
000056  eba401c1          SUB      r1,r4,r1,LSL #3
00005a  b941              CBNZ     r1,|L2.110|
00005c  2200              MOVS     r2,#0
00005e  4620              MOV      r0,r4
000060  17e1              ASRS     r1,r4,#31
000062  eb047151          ADD      r1,r4,r1,LSR #29
000066  10c9              ASRS     r1,r1,#3
000068  1cc9              ADDS     r1,r1,#3
00006a  4b3b              LDR      r3,|L2.344|
00006c  545a              STRB     r2,[r3,r1]
                  |L2.110|
;;;246    			RS485_TX_BUFF[3+i/8] >>= 1;//低位先发送
00006e  17e1              ASRS     r1,r4,#31
000070  eb047151          ADD      r1,r4,r1,LSR #29
000074  10c9              ASRS     r1,r1,#3
000076  1cc9              ADDS     r1,r1,#3
000078  4a37              LDR      r2,|L2.344|
00007a  5c51              LDRB     r1,[r2,r1]
00007c  104a              ASRS     r2,r1,#1
00007e  4620              MOV      r0,r4
000080  17e1              ASRS     r1,r4,#31
000082  eb047151          ADD      r1,r4,r1,LSR #29
000086  10c9              ASRS     r1,r1,#3
000088  1cc9              ADDS     r1,r1,#3
00008a  4b33              LDR      r3,|L2.344|
00008c  545a              STRB     r2,[r3,r1]
;;;247    			RS485_TX_BUFF[3+i/8] |= ((*Modbus_OutputIO[startRegAddr+i])<<7)&0x80;
00008e  17e1              ASRS     r1,r4,#31
000090  eb047151          ADD      r1,r4,r1,LSR #29
000094  10c9              ASRS     r1,r1,#3
000096  1cc9              ADDS     r1,r1,#3
000098  461a              MOV      r2,r3
00009a  5c51              LDRB     r1,[r2,r1]
00009c  eb090204          ADD      r2,r9,r4
0000a0  4b2e              LDR      r3,|L2.348|
0000a2  f8532022          LDR      r2,[r3,r2,LSL #2]
0000a6  6812              LDR      r2,[r2,#0]
0000a8  2380              MOVS     r3,#0x80
0000aa  ea0312c2          AND      r2,r3,r2,LSL #7
0000ae  4311              ORRS     r1,r1,r2
0000b0  17e2              ASRS     r2,r4,#31
0000b2  eb047252          ADD      r2,r4,r2,LSR #29
0000b6  10d2              ASRS     r2,r2,#3
0000b8  1cd2              ADDS     r2,r2,#3
0000ba  4b27              LDR      r3,|L2.344|
0000bc  5499              STRB     r1,[r3,r2]
;;;248    			if(i==RegNum-1)//发送到最后一个位了
0000be  1e68              SUBS     r0,r5,#1
0000c0  42a0              CMP      r0,r4
0000c2  d120              BNE      |L2.262|
;;;249    			{
;;;250    				if(RegNum%8) RS485_TX_BUFF[3+i/8] >>= 8-(RegNum%8);//如果最后一个字节还有余数，则剩余MSB填充0
0000c4  17e9              ASRS     r1,r5,#31
0000c6  eb057151          ADD      r1,r5,r1,LSR #29
0000ca  10c9              ASRS     r1,r1,#3
0000cc  eba501c1          SUB      r1,r5,r1,LSL #3
0000d0  b1c9              CBZ      r1,|L2.262|
0000d2  17e2              ASRS     r2,r4,#31
0000d4  eb047252          ADD      r2,r4,r2,LSR #29
0000d8  10d2              ASRS     r2,r2,#3
0000da  1cd2              ADDS     r2,r2,#3
0000dc  5c9a              LDRB     r2,[r3,r2]
0000de  4629              MOV      r1,r5
0000e0  17eb              ASRS     r3,r5,#31
0000e2  eb057353          ADD      r3,r5,r3,LSR #29
0000e6  10db              ASRS     r3,r3,#3
0000e8  eba503c3          SUB      r3,r5,r3,LSL #3
0000ec  f1c30308          RSB      r3,r3,#8
0000f0  411a              ASRS     r2,r2,r3
0000f2  4620              MOV      r0,r4
0000f4  17e3              ASRS     r3,r4,#31
0000f6  eb047353          ADD      r3,r4,r3,LSR #29
0000fa  10db              ASRS     r3,r3,#3
0000fc  1cdb              ADDS     r3,r3,#3
0000fe  f8dfc058          LDR      r12,|L2.344|
000102  f80c2003          STRB     r2,[r12,r3]
                  |L2.262|
000106  1c60              ADDS     r0,r4,#1              ;243
000108  b284              UXTH     r4,r0                 ;243
                  |L2.266|
00010a  42ac              CMP      r4,r5                 ;243
00010c  db9f              BLT      |L2.78|
;;;251    			}
;;;252    		}
;;;253    		calCRC=CRC16(RS485_TX_BUFF,ByteNum+3);
00010e  1cf8              ADDS     r0,r7,#3
000110  b281              UXTH     r1,r0
000112  4811              LDR      r0,|L2.344|
000114  f7fffffe          BL       CRC16
000118  4680              MOV      r8,r0
;;;254    		RS485_TX_BUFF[ByteNum+3]=(calCRC>>8)&0xFF;
00011a  e000              B        |L2.286|
                  |L2.284|
00011c  e00d              B        |L2.314|
                  |L2.286|
00011e  ea4f2118          LSR      r1,r8,#8
000122  4a0d              LDR      r2,|L2.344|
000124  1cf8              ADDS     r0,r7,#3
000126  5411              STRB     r1,[r2,r0]
;;;255    		RS485_TX_BUFF[ByteNum+4]=calCRC&0xFF;
000128  1d38              ADDS     r0,r7,#4
00012a  f8028000          STRB     r8,[r2,r0]
;;;256    		RS485_SendData(RS485_TX_BUFF,ByteNum+5);
00012e  1d78              ADDS     r0,r7,#5
000130  b2c1              UXTB     r1,r0
000132  4610              MOV      r0,r2
000134  f7fffffe          BL       RS485_SendData
000138  e00c              B        |L2.340|
                  |L2.314|
;;;257    	}
;;;258    	else//寄存器地址+数量超出范围
;;;259    	{
;;;260    		RS485_TX_BUFF[0]=_data_buf[0];
00013a  7830              LDRB     r0,[r6,#0]
00013c  4906              LDR      r1,|L2.344|
00013e  7008              STRB     r0,[r1,#0]
;;;261    		RS485_TX_BUFF[1]=_data_buf[1]|0x80;
000140  7870              LDRB     r0,[r6,#1]
000142  f0400080          ORR      r0,r0,#0x80
000146  7048              STRB     r0,[r1,#1]
;;;262    		RS485_TX_BUFF[2]=0x02; //异常码
000148  2002              MOVS     r0,#2
00014a  7088              STRB     r0,[r1,#2]
;;;263    		RS485_SendData(RS485_TX_BUFF,3);
00014c  2103              MOVS     r1,#3
00014e  4802              LDR      r0,|L2.344|
000150  f7fffffe          BL       RS485_SendData
                  |L2.340|
;;;264    	}
;;;265    }
000154  e8bd87f0          POP      {r4-r10,pc}
;;;266    
                          ENDP

                  |L2.344|
                          DCD      RS485_TX_BUFF
                  |L2.348|
                          DCD      Modbus_OutputIO

                          AREA ||i.Modbus_02_Solve||, CODE, READONLY, ALIGN=2

                  Modbus_02_Solve PROC
;;;269    //读输入开关量
;;;270    void Modbus_02_Solve(u8 * _data_buf)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;271    {
000004  4606              MOV      r6,r0
;;;272    	u16 ByteNum;
;;;273    	u16 i;
;;;274    	u16 calCRC;
;;;275    	u16 RegNum;
;;;276    	u16 startRegAddr;
;;;277    	
;;;278    	startRegAddr=(((u16)_data_buf[2])<<8)|_data_buf[3];//获取寄存器起始地址
000006  78f0              LDRB     r0,[r6,#3]
000008  78b1              LDRB     r1,[r6,#2]
00000a  ea402901          ORR      r9,r0,r1,LSL #8
;;;279    	RegNum= (((u16)_data_buf[4])<<8)|_data_buf[5];//获取寄存器数量
00000e  7970              LDRB     r0,[r6,#5]
000010  7931              LDRB     r1,[r6,#4]
000012  ea402501          ORR      r5,r0,r1,LSL #8
;;;280    	if((startRegAddr+RegNum)<100)//寄存器地址+数量在范围内
000016  eb090005          ADD      r0,r9,r5
00001a  2864              CMP      r0,#0x64
00001c  da7e              BGE      |L3.284|
;;;281    	{
;;;282    		RS485_TX_BUFF[0]=_data_buf[0];
00001e  7830              LDRB     r0,[r6,#0]
000020  494d              LDR      r1,|L3.344|
000022  7008              STRB     r0,[r1,#0]
;;;283    		RS485_TX_BUFF[1]=_data_buf[1];
000024  7870              LDRB     r0,[r6,#1]
000026  7048              STRB     r0,[r1,#1]
;;;284    		ByteNum=RegNum/8;//字节数
000028  4628              MOV      r0,r5
00002a  17e9              ASRS     r1,r5,#31
00002c  eb057151          ADD      r1,r5,r1,LSR #29
000030  f3c107cf          UBFX     r7,r1,#3,#16
;;;285    		if(RegNum%8) ByteNum+=1;//如果位数还有余数，则字节数+1
000034  17e9              ASRS     r1,r5,#31
000036  eb057151          ADD      r1,r5,r1,LSR #29
00003a  10c9              ASRS     r1,r1,#3
00003c  eba501c1          SUB      r1,r5,r1,LSL #3
000040  b109              CBZ      r1,|L3.70|
000042  1c78              ADDS     r0,r7,#1
000044  b287              UXTH     r7,r0
                  |L3.70|
;;;286    			RS485_TX_BUFF[2]=ByteNum;//返回要读取的字节数
000046  4944              LDR      r1,|L3.344|
000048  708f              STRB     r7,[r1,#2]
;;;287    		for(i=0;i<RegNum;i++)
00004a  2400              MOVS     r4,#0
00004c  e05d              B        |L3.266|
                  |L3.78|
;;;288    		{
;;;289    			if(i%8==0) RS485_TX_BUFF[3+i/8]=0x00;
00004e  17e1              ASRS     r1,r4,#31
000050  eb047151          ADD      r1,r4,r1,LSR #29
000054  10c9              ASRS     r1,r1,#3
000056  eba401c1          SUB      r1,r4,r1,LSL #3
00005a  b941              CBNZ     r1,|L3.110|
00005c  2200              MOVS     r2,#0
00005e  4620              MOV      r0,r4
000060  17e1              ASRS     r1,r4,#31
000062  eb047151          ADD      r1,r4,r1,LSR #29
000066  10c9              ASRS     r1,r1,#3
000068  1cc9              ADDS     r1,r1,#3
00006a  4b3b              LDR      r3,|L3.344|
00006c  545a              STRB     r2,[r3,r1]
                  |L3.110|
;;;290    			RS485_TX_BUFF[3+i/8]>>=1;//低位先发送
00006e  17e1              ASRS     r1,r4,#31
000070  eb047151          ADD      r1,r4,r1,LSR #29
000074  10c9              ASRS     r1,r1,#3
000076  1cc9              ADDS     r1,r1,#3
000078  4a37              LDR      r2,|L3.344|
00007a  5c51              LDRB     r1,[r2,r1]
00007c  104a              ASRS     r2,r1,#1
00007e  4620              MOV      r0,r4
000080  17e1              ASRS     r1,r4,#31
000082  eb047151          ADD      r1,r4,r1,LSR #29
000086  10c9              ASRS     r1,r1,#3
000088  1cc9              ADDS     r1,r1,#3
00008a  4b33              LDR      r3,|L3.344|
00008c  545a              STRB     r2,[r3,r1]
;;;291    			RS485_TX_BUFF[3+i/8]|=((*Modbus_InputIO[startRegAddr+i])<<7)&0x80;
00008e  17e1              ASRS     r1,r4,#31
000090  eb047151          ADD      r1,r4,r1,LSR #29
000094  10c9              ASRS     r1,r1,#3
000096  1cc9              ADDS     r1,r1,#3
000098  461a              MOV      r2,r3
00009a  5c51              LDRB     r1,[r2,r1]
00009c  eb090204          ADD      r2,r9,r4
0000a0  4b2e              LDR      r3,|L3.348|
0000a2  f8532022          LDR      r2,[r3,r2,LSL #2]
0000a6  6812              LDR      r2,[r2,#0]
0000a8  2380              MOVS     r3,#0x80
0000aa  ea0312c2          AND      r2,r3,r2,LSL #7
0000ae  4311              ORRS     r1,r1,r2
0000b0  17e2              ASRS     r2,r4,#31
0000b2  eb047252          ADD      r2,r4,r2,LSR #29
0000b6  10d2              ASRS     r2,r2,#3
0000b8  1cd2              ADDS     r2,r2,#3
0000ba  4b27              LDR      r3,|L3.344|
0000bc  5499              STRB     r1,[r3,r2]
;;;292    			if(i==RegNum-1)//发送到最后一个位了
0000be  1e68              SUBS     r0,r5,#1
0000c0  42a0              CMP      r0,r4
0000c2  d120              BNE      |L3.262|
;;;293    			{
;;;294    				if(RegNum%8) RS485_TX_BUFF[3+i/8]>>=8-(RegNum%8);//如果最后一个字节还有余数，则剩余MSB填充0
0000c4  17e9              ASRS     r1,r5,#31
0000c6  eb057151          ADD      r1,r5,r1,LSR #29
0000ca  10c9              ASRS     r1,r1,#3
0000cc  eba501c1          SUB      r1,r5,r1,LSL #3
0000d0  b1c9              CBZ      r1,|L3.262|
0000d2  17e2              ASRS     r2,r4,#31
0000d4  eb047252          ADD      r2,r4,r2,LSR #29
0000d8  10d2              ASRS     r2,r2,#3
0000da  1cd2              ADDS     r2,r2,#3
0000dc  5c9a              LDRB     r2,[r3,r2]
0000de  4629              MOV      r1,r5
0000e0  17eb              ASRS     r3,r5,#31
0000e2  eb057353          ADD      r3,r5,r3,LSR #29
0000e6  10db              ASRS     r3,r3,#3
0000e8  eba503c3          SUB      r3,r5,r3,LSL #3
0000ec  f1c30308          RSB      r3,r3,#8
0000f0  411a              ASRS     r2,r2,r3
0000f2  4620              MOV      r0,r4
0000f4  17e3              ASRS     r3,r4,#31
0000f6  eb047353          ADD      r3,r4,r3,LSR #29
0000fa  10db              ASRS     r3,r3,#3
0000fc  1cdb              ADDS     r3,r3,#3
0000fe  f8dfc058          LDR      r12,|L3.344|
000102  f80c2003          STRB     r2,[r12,r3]
                  |L3.262|
000106  1c60              ADDS     r0,r4,#1              ;287
000108  b284              UXTH     r4,r0                 ;287
                  |L3.266|
00010a  42ac              CMP      r4,r5                 ;287
00010c  db9f              BLT      |L3.78|
;;;295    			}
;;;296    		}
;;;297    		calCRC=CRC16(RS485_TX_BUFF,ByteNum+3);
00010e  1cf8              ADDS     r0,r7,#3
000110  b281              UXTH     r1,r0
000112  4811              LDR      r0,|L3.344|
000114  f7fffffe          BL       CRC16
000118  4680              MOV      r8,r0
;;;298    		RS485_TX_BUFF[ByteNum+3]=(calCRC>>8)&0xFF;
00011a  e000              B        |L3.286|
                  |L3.284|
00011c  e00d              B        |L3.314|
                  |L3.286|
00011e  ea4f2118          LSR      r1,r8,#8
000122  4a0d              LDR      r2,|L3.344|
000124  1cf8              ADDS     r0,r7,#3
000126  5411              STRB     r1,[r2,r0]
;;;299    		RS485_TX_BUFF[ByteNum+4]=calCRC&0xFF;
000128  1d38              ADDS     r0,r7,#4
00012a  f8028000          STRB     r8,[r2,r0]
;;;300    		RS485_SendData(RS485_TX_BUFF,ByteNum+5);
00012e  1d78              ADDS     r0,r7,#5
000130  b2c1              UXTB     r1,r0
000132  4610              MOV      r0,r2
000134  f7fffffe          BL       RS485_SendData
000138  e00c              B        |L3.340|
                  |L3.314|
;;;301    	}
;;;302    	else//寄存器地址+数量超出范围
;;;303    	{
;;;304    		RS485_TX_BUFF[0]=_data_buf[0];
00013a  7830              LDRB     r0,[r6,#0]
00013c  4906              LDR      r1,|L3.344|
00013e  7008              STRB     r0,[r1,#0]
;;;305    		RS485_TX_BUFF[1]=_data_buf[1]|0x80;
000140  7870              LDRB     r0,[r6,#1]
000142  f0400080          ORR      r0,r0,#0x80
000146  7048              STRB     r0,[r1,#1]
;;;306    		RS485_TX_BUFF[2]=0x02; //异常码
000148  2002              MOVS     r0,#2
00014a  7088              STRB     r0,[r1,#2]
;;;307    		RS485_SendData(RS485_TX_BUFF,3);
00014c  2103              MOVS     r1,#3
00014e  4802              LDR      r0,|L3.344|
000150  f7fffffe          BL       RS485_SendData
                  |L3.340|
;;;308    	}
;;;309    }
000154  e8bd87f0          POP      {r4-r10,pc}
;;;310    
                          ENDP

                  |L3.344|
                          DCD      RS485_TX_BUFF
                  |L3.348|
                          DCD      Modbus_InputIO

                          AREA ||i.Modbus_03_Solve||, CODE, READONLY, ALIGN=2

                  Modbus_03_Solve PROC
;;;313    //读保持寄存器
;;;314    void Modbus_03_Solve(u8 * _data_buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;315    {
000004  4605              MOV      r5,r0
;;;316    	u8 i;
;;;317    	u16 calCRC;
;;;318    	u16 RegNum;
;;;319    	u16 startRegAddr;
;;;320    	
;;;321    	startRegAddr=(((u16)_data_buf[2])<<8)|_data_buf[3];//获取寄存器起始地址
000006  78e8              LDRB     r0,[r5,#3]
000008  78a9              LDRB     r1,[r5,#2]
00000a  ea402801          ORR      r8,r0,r1,LSL #8
;;;322    	RegNum= (((u16)_data_buf[4])<<8)|_data_buf[5];//获取寄存器数量
00000e  7968              LDRB     r0,[r5,#5]
000010  7929              LDRB     r1,[r5,#4]
000012  ea402401          ORR      r4,r0,r1,LSL #8
;;;323    	if((startRegAddr+RegNum)<1000)//寄存器地址+数量在范围内
000016  eb080004          ADD      r0,r8,r4
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  da3b              BGE      |L4.152|
;;;324    	{
;;;325    		RS485_TX_BUFF[0]=_data_buf[0];
000020  7828              LDRB     r0,[r5,#0]
000022  4925              LDR      r1,|L4.184|
000024  7008              STRB     r0,[r1,#0]
;;;326    		RS485_TX_BUFF[1]=_data_buf[1];
000026  7868              LDRB     r0,[r5,#1]
000028  7048              STRB     r0,[r1,#1]
;;;327    		RS485_TX_BUFF[2]=RegNum * 2;
00002a  0660              LSLS     r0,r4,#25
00002c  0e00              LSRS     r0,r0,#24
00002e  7088              STRB     r0,[r1,#2]
;;;328    		for(i=0;i<RegNum;i++)
000030  2600              MOVS     r6,#0
000032  e015              B        |L4.96|
                  |L4.52|
;;;329    		{
;;;330    			RS485_TX_BUFF[3+i*2]=(Modbus_HoldReg[startRegAddr+i]>>8)&0xFF; //先发送高字节
000034  eb080006          ADD      r0,r8,r6
000038  4920              LDR      r1,|L4.188|
00003a  f8310010          LDRH     r0,[r1,r0,LSL #1]
00003e  0a00              LSRS     r0,r0,#8
000040  2103              MOVS     r1,#3
000042  eb010146          ADD      r1,r1,r6,LSL #1
000046  4a1c              LDR      r2,|L4.184|
000048  5450              STRB     r0,[r2,r1]
;;;331    			RS485_TX_BUFF[4+i*2]=Modbus_HoldReg[startRegAddr+i]&0xFF;//后发送低字节
00004a  eb080006          ADD      r0,r8,r6
00004e  491b              LDR      r1,|L4.188|
000050  f8110010          LDRB     r0,[r1,r0,LSL #1]
000054  2104              MOVS     r1,#4
000056  eb010146          ADD      r1,r1,r6,LSL #1
00005a  5450              STRB     r0,[r2,r1]
00005c  1c70              ADDS     r0,r6,#1              ;328
00005e  b2c6              UXTB     r6,r0                 ;328
                  |L4.96|
000060  42a6              CMP      r6,r4                 ;328
000062  dbe7              BLT      |L4.52|
;;;332    		}
;;;333    		calCRC=CRC16(RS485_TX_BUFF,RegNum*2+3);
000064  2003              MOVS     r0,#3
000066  eb000044          ADD      r0,r0,r4,LSL #1
00006a  b281              UXTH     r1,r0
00006c  4812              LDR      r0,|L4.184|
00006e  f7fffffe          BL       CRC16
000072  4607              MOV      r7,r0
;;;334    		
;;;335            RS485_TX_BUFF[RegNum*2+3]=(calCRC>>8)&0xFF;
000074  0a38              LSRS     r0,r7,#8
000076  2103              MOVS     r1,#3
000078  eb010144          ADD      r1,r1,r4,LSL #1
00007c  4a0e              LDR      r2,|L4.184|
00007e  5450              STRB     r0,[r2,r1]
;;;336            RS485_TX_BUFF[RegNum*2+4]=calCRC&0xFF;
000080  2104              MOVS     r1,#4
000082  eb010144          ADD      r1,r1,r4,LSL #1
000086  5457              STRB     r7,[r2,r1]
;;;337    		RS485_SendData(RS485_TX_BUFF,RegNum*2+5);
000088  2005              MOVS     r0,#5
00008a  eb000044          ADD      r0,r0,r4,LSL #1
00008e  b2c1              UXTB     r1,r0
000090  4610              MOV      r0,r2
000092  f7fffffe          BL       RS485_SendData
000096  e00c              B        |L4.178|
                  |L4.152|
;;;338    	}
;;;339    	else//寄存器地址+数量超出范围
;;;340    	{
;;;341    		RS485_TX_BUFF[0]=_data_buf[0];
000098  7828              LDRB     r0,[r5,#0]
00009a  4907              LDR      r1,|L4.184|
00009c  7008              STRB     r0,[r1,#0]
;;;342    		RS485_TX_BUFF[1]=_data_buf[1]|0x80;
00009e  7868              LDRB     r0,[r5,#1]
0000a0  f0400080          ORR      r0,r0,#0x80
0000a4  7048              STRB     r0,[r1,#1]
;;;343    		RS485_TX_BUFF[2]=0x02; //异常码
0000a6  2002              MOVS     r0,#2
0000a8  7088              STRB     r0,[r1,#2]
;;;344    		RS485_SendData(RS485_TX_BUFF,3);
0000aa  2103              MOVS     r1,#3
0000ac  4802              LDR      r0,|L4.184|
0000ae  f7fffffe          BL       RS485_SendData
                  |L4.178|
;;;345    	}
;;;346    }
0000b2  e8bd81f0          POP      {r4-r8,pc}
;;;347    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L4.184|
                          DCD      RS485_TX_BUFF
                  |L4.188|
                          DCD      Modbus_HoldReg

                          AREA ||i.Modbus_05_Solve||, CODE, READONLY, ALIGN=2

                  Modbus_05_Solve PROC
;;;351    //写单个输出开关量
;;;352    void Modbus_05_Solve(u8 * _data_buf)
000000  b570              PUSH     {r4-r6,lr}
;;;353    {
000002  4604              MOV      r4,r0
;;;354    	u16 calCRC;
;;;355    	u16 startRegAddr;
;;;356    	
;;;357    	startRegAddr=(((u16)_data_buf[2])<<8)|_data_buf[3];//获取寄存器起始地址
000004  78e0              LDRB     r0,[r4,#3]
000006  78a1              LDRB     r1,[r4,#2]
000008  ea402501          ORR      r5,r0,r1,LSL #8
;;;358    	if(startRegAddr<100)//寄存器地址在范围内
00000c  2d64              CMP      r5,#0x64
00000e  da2b              BGE      |L5.104|
;;;359    	{
;;;360    		if((_data_buf[4]==0xFF)||(_data_buf[5]==0xFF)) *Modbus_OutputIO[startRegAddr]=0x01;
000010  7920              LDRB     r0,[r4,#4]
000012  28ff              CMP      r0,#0xff
000014  d002              BEQ      |L5.28|
000016  7960              LDRB     r0,[r4,#5]
000018  28ff              CMP      r0,#0xff
00001a  d105              BNE      |L5.40|
                  |L5.28|
00001c  2001              MOVS     r0,#1
00001e  4919              LDR      r1,|L5.132|
000020  f8511025          LDR      r1,[r1,r5,LSL #2]
000024  6008              STR      r0,[r1,#0]
000026  e004              B        |L5.50|
                  |L5.40|
;;;361    		else *Modbus_OutputIO[startRegAddr]=0x00;
000028  2000              MOVS     r0,#0
00002a  4916              LDR      r1,|L5.132|
00002c  f8511025          LDR      r1,[r1,r5,LSL #2]
000030  6008              STR      r0,[r1,#0]
                  |L5.50|
;;;362                   
;;;363    		RS485_TX_BUFF[0]=_data_buf[0];
000032  7820              LDRB     r0,[r4,#0]
000034  4914              LDR      r1,|L5.136|
000036  7008              STRB     r0,[r1,#0]
;;;364    		RS485_TX_BUFF[1]=_data_buf[1];
000038  7860              LDRB     r0,[r4,#1]
00003a  7048              STRB     r0,[r1,#1]
;;;365    		RS485_TX_BUFF[2]=_data_buf[2];
00003c  78a0              LDRB     r0,[r4,#2]
00003e  7088              STRB     r0,[r1,#2]
;;;366    		RS485_TX_BUFF[3]=_data_buf[3];
000040  78e0              LDRB     r0,[r4,#3]
000042  70c8              STRB     r0,[r1,#3]
;;;367    		RS485_TX_BUFF[4]=_data_buf[4];
000044  7920              LDRB     r0,[r4,#4]
000046  7108              STRB     r0,[r1,#4]
;;;368    		RS485_TX_BUFF[5]=_data_buf[5];
000048  7960              LDRB     r0,[r4,#5]
00004a  7148              STRB     r0,[r1,#5]
;;;369                   
;;;370    		calCRC=CRC16(RS485_TX_BUFF,6);
00004c  2106              MOVS     r1,#6
00004e  480e              LDR      r0,|L5.136|
000050  f7fffffe          BL       CRC16
000054  4606              MOV      r6,r0
;;;371    		RS485_TX_BUFF[6]=(calCRC>>8)&0xFF;
000056  0a30              LSRS     r0,r6,#8
000058  490b              LDR      r1,|L5.136|
00005a  7188              STRB     r0,[r1,#6]
;;;372    		RS485_TX_BUFF[7]=calCRC&0xFF;
00005c  71ce              STRB     r6,[r1,#7]
;;;373    		RS485_SendData(RS485_TX_BUFF,8);
00005e  2108              MOVS     r1,#8
000060  4809              LDR      r0,|L5.136|
000062  f7fffffe          BL       RS485_SendData
000066  e00c              B        |L5.130|
                  |L5.104|
;;;374    	}
;;;375    	else//寄存器地址超出范围
;;;376    	{
;;;377    		RS485_TX_BUFF[0]=_data_buf[0];
000068  7820              LDRB     r0,[r4,#0]
00006a  4907              LDR      r1,|L5.136|
00006c  7008              STRB     r0,[r1,#0]
;;;378    		RS485_TX_BUFF[1]=_data_buf[1]|0x80;
00006e  7860              LDRB     r0,[r4,#1]
000070  f0400080          ORR      r0,r0,#0x80
000074  7048              STRB     r0,[r1,#1]
;;;379    		RS485_TX_BUFF[2]=0x02; //异常码
000076  2002              MOVS     r0,#2
000078  7088              STRB     r0,[r1,#2]
;;;380    		RS485_SendData(RS485_TX_BUFF,3);
00007a  2103              MOVS     r1,#3
00007c  4802              LDR      r0,|L5.136|
00007e  f7fffffe          BL       RS485_SendData
                  |L5.130|
;;;381    	}
;;;382    }
000082  bd70              POP      {r4-r6,pc}
;;;383    
                          ENDP

                  |L5.132|
                          DCD      Modbus_OutputIO
                  |L5.136|
                          DCD      RS485_TX_BUFF

                          AREA ||i.Modbus_06_Solve||, CODE, READONLY, ALIGN=2

                  Modbus_06_Solve PROC
;;;385    //写单个保持寄存器
;;;386    void Modbus_06_Solve(u8 * _data_buf)
000000  b570              PUSH     {r4-r6,lr}
;;;387    {
000002  4604              MOV      r4,r0
;;;388    	u16 calCRC;
;;;389    	u16 startRegAddr;
;;;390    	
;;;391    	startRegAddr=(((u16)_data_buf[2])<<8)|_data_buf[3];//获取寄存器起始地址
000004  78e0              LDRB     r0,[r4,#3]
000006  78a1              LDRB     r1,[r4,#2]
000008  ea402501          ORR      r5,r0,r1,LSL #8
;;;392    	Modbus_HoldReg[startRegAddr]=((u16)_data_buf[4])<<8;//高字节在前
00000c  7920              LDRB     r0,[r4,#4]
00000e  0200              LSLS     r0,r0,#8
000010  4912              LDR      r1,|L6.92|
000012  f8210015          STRH     r0,[r1,r5,LSL #1]
;;;393    	Modbus_HoldReg[startRegAddr]|=_data_buf[5];//低字节在后
000016  4608              MOV      r0,r1
000018  f8300015          LDRH     r0,[r0,r5,LSL #1]
00001c  7961              LDRB     r1,[r4,#5]
00001e  4308              ORRS     r0,r0,r1
000020  490e              LDR      r1,|L6.92|
000022  f8210015          STRH     r0,[r1,r5,LSL #1]
;;;394           
;;;395    	RS485_TX_BUFF[0]=_data_buf[0];
000026  7820              LDRB     r0,[r4,#0]
000028  490d              LDR      r1,|L6.96|
00002a  7008              STRB     r0,[r1,#0]
;;;396    	RS485_TX_BUFF[1]=_data_buf[1];
00002c  7860              LDRB     r0,[r4,#1]
00002e  7048              STRB     r0,[r1,#1]
;;;397    	RS485_TX_BUFF[2]=_data_buf[2];
000030  78a0              LDRB     r0,[r4,#2]
000032  7088              STRB     r0,[r1,#2]
;;;398    	RS485_TX_BUFF[3]=_data_buf[3];
000034  78e0              LDRB     r0,[r4,#3]
000036  70c8              STRB     r0,[r1,#3]
;;;399    	RS485_TX_BUFF[4]=_data_buf[4];
000038  7920              LDRB     r0,[r4,#4]
00003a  7108              STRB     r0,[r1,#4]
;;;400    	RS485_TX_BUFF[5]=_data_buf[5];
00003c  7960              LDRB     r0,[r4,#5]
00003e  7148              STRB     r0,[r1,#5]
;;;401           
;;;402    	calCRC=CRC16(RS485_TX_BUFF,6);
000040  2106              MOVS     r1,#6
000042  4807              LDR      r0,|L6.96|
000044  f7fffffe          BL       CRC16
000048  4606              MOV      r6,r0
;;;403    	RS485_TX_BUFF[6]=(calCRC>>8)&0xFF;
00004a  0a30              LSRS     r0,r6,#8
00004c  4904              LDR      r1,|L6.96|
00004e  7188              STRB     r0,[r1,#6]
;;;404    	RS485_TX_BUFF[7]=calCRC&0xFF;
000050  71ce              STRB     r6,[r1,#7]
;;;405    	RS485_SendData(RS485_TX_BUFF,8);
000052  2108              MOVS     r1,#8
000054  4802              LDR      r0,|L6.96|
000056  f7fffffe          BL       RS485_SendData
;;;406    }
00005a  bd70              POP      {r4-r6,pc}
;;;407    //Modbus功能码15处理程序
                          ENDP

                  |L6.92|
                          DCD      Modbus_HoldReg
                  |L6.96|
                          DCD      RS485_TX_BUFF

                          AREA ||i.Modbus_15_Solve||, CODE, READONLY, ALIGN=2

                  Modbus_15_Solve PROC
;;;408    //写多个输出开关量
;;;409    void Modbus_15_Solve(u8 * _data_buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;410    {
000004  4604              MOV      r4,r0
;;;411    	u16 i;
;;;412    	u16 calCRC;
;;;413    	u16 RegNum;
;;;414    	u16 startRegAddr;
;;;415    	
;;;416    	startRegAddr=(((u16)_data_buf[2])<<8)|_data_buf[3];//获取寄存器起始地址
000006  78e0              LDRB     r0,[r4,#3]
000008  78a1              LDRB     r1,[r4,#2]
00000a  ea402701          ORR      r7,r0,r1,LSL #8
;;;417    	RegNum=(((u16)_data_buf[4])<<8)|_data_buf[5];//获取寄存器数量
00000e  7960              LDRB     r0,[r4,#5]
000010  7921              LDRB     r1,[r4,#4]
000012  ea402801          ORR      r8,r0,r1,LSL #8
;;;418    	if((startRegAddr+RegNum)<100)//寄存器地址+数量在范围内
000016  eb070008          ADD      r0,r7,r8
00001a  2864              CMP      r0,#0x64
00001c  da44              BGE      |L7.168|
;;;419    	{       
;;;420    		for(i=0;i<RegNum;i++)
00001e  2500              MOVS     r5,#0
000020  e025              B        |L7.110|
                  |L7.34|
;;;421    		{
;;;422    		        if(_data_buf[7+i/8]&0x01) *Modbus_OutputIO[startRegAddr+i]=0x01;
000022  17e9              ASRS     r1,r5,#31
000024  eb057151          ADD      r1,r5,r1,LSR #29
000028  10c9              ASRS     r1,r1,#3
00002a  1dc9              ADDS     r1,r1,#7
00002c  5c61              LDRB     r1,[r4,r1]
00002e  f0010101          AND      r1,r1,#1
000032  b131              CBZ      r1,|L7.66|
000034  2001              MOVS     r0,#1
000036  1979              ADDS     r1,r7,r5
000038  4a23              LDR      r2,|L7.200|
00003a  f8521021          LDR      r1,[r2,r1,LSL #2]
00003e  6008              STR      r0,[r1,#0]
000040  e005              B        |L7.78|
                  |L7.66|
;;;423    		        else *Modbus_OutputIO[startRegAddr+i]=0x00;
000042  2000              MOVS     r0,#0
000044  1979              ADDS     r1,r7,r5
000046  4a20              LDR      r2,|L7.200|
000048  f8521021          LDR      r1,[r2,r1,LSL #2]
00004c  6008              STR      r0,[r1,#0]
                  |L7.78|
;;;424    		        _data_buf[7+i/8]>>=1;//从低位开始
00004e  17e9              ASRS     r1,r5,#31
000050  eb057151          ADD      r1,r5,r1,LSR #29
000054  10c9              ASRS     r1,r1,#3
000056  1dc9              ADDS     r1,r1,#7
000058  5c61              LDRB     r1,[r4,r1]
00005a  104a              ASRS     r2,r1,#1
00005c  4628              MOV      r0,r5
00005e  17e9              ASRS     r1,r5,#31
000060  eb057151          ADD      r1,r5,r1,LSR #29
000064  10c9              ASRS     r1,r1,#3
000066  1dc9              ADDS     r1,r1,#7
000068  5462              STRB     r2,[r4,r1]
00006a  1c68              ADDS     r0,r5,#1              ;420
00006c  b285              UXTH     r5,r0                 ;420
                  |L7.110|
00006e  4545              CMP      r5,r8                 ;420
000070  dbd7              BLT      |L7.34|
;;;425    		}
;;;426                   
;;;427    		RS485_TX_BUFF[0]=_data_buf[0];
000072  7820              LDRB     r0,[r4,#0]
000074  4915              LDR      r1,|L7.204|
000076  7008              STRB     r0,[r1,#0]
;;;428    		RS485_TX_BUFF[1]=_data_buf[1];
000078  7860              LDRB     r0,[r4,#1]
00007a  7048              STRB     r0,[r1,#1]
;;;429    		RS485_TX_BUFF[2]=_data_buf[2];
00007c  78a0              LDRB     r0,[r4,#2]
00007e  7088              STRB     r0,[r1,#2]
;;;430    		RS485_TX_BUFF[3]=_data_buf[3];
000080  78e0              LDRB     r0,[r4,#3]
000082  70c8              STRB     r0,[r1,#3]
;;;431    		RS485_TX_BUFF[4]=_data_buf[4];
000084  7920              LDRB     r0,[r4,#4]
000086  7108              STRB     r0,[r1,#4]
;;;432    		RS485_TX_BUFF[5]=_data_buf[5];
000088  7960              LDRB     r0,[r4,#5]
00008a  7148              STRB     r0,[r1,#5]
;;;433    		calCRC=CRC16(RS485_TX_BUFF,6);
00008c  2106              MOVS     r1,#6
00008e  480f              LDR      r0,|L7.204|
000090  f7fffffe          BL       CRC16
000094  4606              MOV      r6,r0
;;;434    		RS485_TX_BUFF[6]=(calCRC>>8)&0xFF;
000096  0a30              LSRS     r0,r6,#8
000098  490c              LDR      r1,|L7.204|
00009a  7188              STRB     r0,[r1,#6]
;;;435    		RS485_TX_BUFF[7]=calCRC&0xFF;
00009c  71ce              STRB     r6,[r1,#7]
;;;436    		RS485_SendData(RS485_TX_BUFF,8);
00009e  2108              MOVS     r1,#8
0000a0  480a              LDR      r0,|L7.204|
0000a2  f7fffffe          BL       RS485_SendData
0000a6  e00c              B        |L7.194|
                  |L7.168|
;;;437    	}
;;;438    	else//寄存器地址+数量超出范围
;;;439    	{
;;;440    		RS485_TX_BUFF[0]=_data_buf[0];
0000a8  7820              LDRB     r0,[r4,#0]
0000aa  4908              LDR      r1,|L7.204|
0000ac  7008              STRB     r0,[r1,#0]
;;;441    		RS485_TX_BUFF[1]=_data_buf[1]|0x80;
0000ae  7860              LDRB     r0,[r4,#1]
0000b0  f0400080          ORR      r0,r0,#0x80
0000b4  7048              STRB     r0,[r1,#1]
;;;442    		RS485_TX_BUFF[2]=0x02; //异常码
0000b6  2002              MOVS     r0,#2
0000b8  7088              STRB     r0,[r1,#2]
;;;443    		RS485_SendData(RS485_TX_BUFF,3);
0000ba  2103              MOVS     r1,#3
0000bc  4803              LDR      r0,|L7.204|
0000be  f7fffffe          BL       RS485_SendData
                  |L7.194|
;;;444    	}
;;;445    }
0000c2  e8bd81f0          POP      {r4-r8,pc}
;;;446    //Modbus功能码16处理程序
                          ENDP

0000c6  0000              DCW      0x0000
                  |L7.200|
                          DCD      Modbus_OutputIO
                  |L7.204|
                          DCD      RS485_TX_BUFF

                          AREA ||i.Modbus_16_Solve||, CODE, READONLY, ALIGN=2

                  Modbus_16_Solve PROC
;;;447    //写多个保持寄存器
;;;448    void Modbus_16_Solve(u8 * _data_buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;449    {
000004  4604              MOV      r4,r0
;;;450    	u8 i;
;;;451    	u16 calCRC;
;;;452    	u16 RegNum;
;;;453    	u16 startRegAddr;
;;;454    	
;;;455    	startRegAddr=(((u16)_data_buf[2])<<8)|_data_buf[3];//获取寄存器起始地址
000006  78e0              LDRB     r0,[r4,#3]
000008  78a1              LDRB     r1,[r4,#2]
00000a  ea402601          ORR      r6,r0,r1,LSL #8
;;;456    	RegNum= (((u16)_data_buf[4])<<8)|_data_buf[5];//获取寄存器数量
00000e  7960              LDRB     r0,[r4,#5]
000010  7921              LDRB     r1,[r4,#4]
000012  ea402801          ORR      r8,r0,r1,LSL #8
;;;457    	if((startRegAddr+RegNum)<1000)//寄存器地址+数量在范围内
000016  eb060008          ADD      r0,r6,r8
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  da35              BGE      |L8.140|
;;;458    	{
;;;459    		for(i=0;i<RegNum;i++)
000020  2500              MOVS     r5,#0
000022  e016              B        |L8.82|
                  |L8.36|
;;;460    		{
;;;461    			Modbus_HoldReg[startRegAddr+i]=((u16)_data_buf[7+i*2])<<8; //高字节在前
000024  2007              MOVS     r0,#7
000026  eb000045          ADD      r0,r0,r5,LSL #1
00002a  5c20              LDRB     r0,[r4,r0]
00002c  0200              LSLS     r0,r0,#8
00002e  1971              ADDS     r1,r6,r5
000030  4a1e              LDR      r2,|L8.172|
000032  f8220011          STRH     r0,[r2,r1,LSL #1]
;;;462    			Modbus_HoldReg[startRegAddr+i]|=_data_buf[8+i*2]; //低字节在后
000036  1970              ADDS     r0,r6,r5
000038  4611              MOV      r1,r2
00003a  f8310010          LDRH     r0,[r1,r0,LSL #1]
00003e  2108              MOVS     r1,#8
000040  eb010145          ADD      r1,r1,r5,LSL #1
000044  5c61              LDRB     r1,[r4,r1]
000046  4308              ORRS     r0,r0,r1
000048  1971              ADDS     r1,r6,r5
00004a  f8220011          STRH     r0,[r2,r1,LSL #1]
00004e  1c68              ADDS     r0,r5,#1              ;459
000050  b2c5              UXTB     r5,r0                 ;459
                  |L8.82|
000052  4545              CMP      r5,r8                 ;459
000054  dbe6              BLT      |L8.36|
;;;463    		}
;;;464                   
;;;465    		RS485_TX_BUFF[0]=_data_buf[0];
000056  7820              LDRB     r0,[r4,#0]
000058  4915              LDR      r1,|L8.176|
00005a  7008              STRB     r0,[r1,#0]
;;;466    		RS485_TX_BUFF[1]=_data_buf[1];
00005c  7860              LDRB     r0,[r4,#1]
00005e  7048              STRB     r0,[r1,#1]
;;;467    		RS485_TX_BUFF[2]=_data_buf[2];
000060  78a0              LDRB     r0,[r4,#2]
000062  7088              STRB     r0,[r1,#2]
;;;468    		RS485_TX_BUFF[3]=_data_buf[3];
000064  78e0              LDRB     r0,[r4,#3]
000066  70c8              STRB     r0,[r1,#3]
;;;469    		RS485_TX_BUFF[4]=_data_buf[4];
000068  7920              LDRB     r0,[r4,#4]
00006a  7108              STRB     r0,[r1,#4]
;;;470    		RS485_TX_BUFF[5]=_data_buf[5];
00006c  7960              LDRB     r0,[r4,#5]
00006e  7148              STRB     r0,[r1,#5]
;;;471                   
;;;472    		calCRC=CRC16(RS485_TX_BUFF,6);
000070  2106              MOVS     r1,#6
000072  480f              LDR      r0,|L8.176|
000074  f7fffffe          BL       CRC16
000078  4607              MOV      r7,r0
;;;473    		RS485_TX_BUFF[6]=(calCRC>>8)&0xFF;
00007a  0a38              LSRS     r0,r7,#8
00007c  490c              LDR      r1,|L8.176|
00007e  7188              STRB     r0,[r1,#6]
;;;474    		RS485_TX_BUFF[7]=calCRC&0xFF;
000080  71cf              STRB     r7,[r1,#7]
;;;475    		RS485_SendData(RS485_TX_BUFF,8);
000082  2108              MOVS     r1,#8
000084  480a              LDR      r0,|L8.176|
000086  f7fffffe          BL       RS485_SendData
00008a  e00c              B        |L8.166|
                  |L8.140|
;;;476    	}
;;;477    	else//寄存器地址+数量超出范围
;;;478    	{
;;;479    		RS485_TX_BUFF[0]=_data_buf[0];
00008c  7820              LDRB     r0,[r4,#0]
00008e  4908              LDR      r1,|L8.176|
000090  7008              STRB     r0,[r1,#0]
;;;480    		RS485_TX_BUFF[1]=_data_buf[1]|0x80;
000092  7860              LDRB     r0,[r4,#1]
000094  f0400080          ORR      r0,r0,#0x80
000098  7048              STRB     r0,[r1,#1]
;;;481    		RS485_TX_BUFF[2]=0x02; //异常码
00009a  2002              MOVS     r0,#2
00009c  7088              STRB     r0,[r1,#2]
;;;482    		RS485_SendData(RS485_TX_BUFF,3);
00009e  2103              MOVS     r1,#3
0000a0  4803              LDR      r0,|L8.176|
0000a2  f7fffffe          BL       RS485_SendData
                  |L8.166|
;;;483    	}
;;;484    }
0000a6  e8bd81f0          POP      {r4-r8,pc}
;;;485    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L8.172|
                          DCD      Modbus_HoldReg
                  |L8.176|
                          DCD      RS485_TX_BUFF

                          AREA ||i.Modbus_RegMap||, CODE, READONLY, ALIGN=2

                  Modbus_RegMap PROC
;;;76     
;;;77     void Modbus_RegMap(void) 
000000  490f              LDR      r1,|L9.64|
;;;78     {
;;;79     	int i;
;;;80     	//输入开关量寄存器指针指向
;;;81     	Modbus_InputIO[0]=(vu32*)&PCin(6);//KEY0
000002  4a10              LDR      r2,|L9.68|
000004  6011              STR      r1,[r2,#0]  ; Modbus_InputIO
;;;82     	Modbus_InputIO[1]=(vu32*)&PCin(7);//KEY1
000006  1d09              ADDS     r1,r1,#4
000008  6051              STR      r1,[r2,#4]  ; Modbus_InputIO
;;;83     	Modbus_InputIO[2]=(vu32*)&PAin(8);//KEY2
00000a  490f              LDR      r1,|L9.72|
00000c  6091              STR      r1,[r2,#8]  ; Modbus_InputIO
;;;84     	Modbus_InputIO[3]=(vu32*)&PGin(11);//KEY3
00000e  490f              LDR      r1,|L9.76|
000010  60d1              STR      r1,[r2,#0xc]  ; Modbus_InputIO
;;;85     	Modbus_InputIO[4]=(vu32*)&PCin(0);//KEY3
000012  490b              LDR      r1,|L9.64|
000014  3918              SUBS     r1,r1,#0x18
000016  6111              STR      r1,[r2,#0x10]  ; Modbus_InputIO
;;;86     	Modbus_InputIO[5]=(vu32*)&PGin(1);//KEY3
000018  490c              LDR      r1,|L9.76|
00001a  3928              SUBS     r1,r1,#0x28
00001c  6151              STR      r1,[r2,#0x14]  ; Modbus_InputIO
;;;87     	Modbus_InputIO[6]=(vu32*)&PGin(2);//KEY3
00001e  1d09              ADDS     r1,r1,#4
000020  6191              STR      r1,[r2,#0x18]  ; Modbus_InputIO
;;;88     	Modbus_InputIO[7]=(vu32*)&PGin(3);//KEY3
000022  1d09              ADDS     r1,r1,#4
000024  61d1              STR      r1,[r2,#0x1c]  ; Modbus_InputIO
;;;89           
;;;90     	//输出开关量寄存器指针指向
;;;91     	MAP_MODBUS_OUTPUT (0, F, 0);
000026  490a              LDR      r1,|L9.80|
000028  4a0a              LDR      r2,|L9.84|
00002a  6011              STR      r1,[r2,#0]  ; Modbus_OutputIO
;;;92     //	Modbus_OutputIO[0]=(vu32*)&PFout(0);//LED0
;;;93     //	Modbus_OutputIO[1]=(vu32*)&PFout(1);//LED1
;;;94     //	Modbus_OutputIO[2]=(vu32*)&PFout(1);//LED1
;;;95     //	Modbus_OutputIO[3]=(vu32*)&PFout(1);//LED1
;;;96     //	Modbus_OutputIO[4]=(vu32*)&PFout(1);//LED1
;;;97     //	Modbus_OutputIO[5]=(vu32*)&PFout(1);//LED1
;;;98     //	Modbus_OutputIO[6]=(vu32*)&PFout(1);//LED1
;;;99     //	Modbus_OutputIO[7]=(vu32*)&PFout(1);//LED1
;;;100    //	Modbus_OutputIO[8]=(vu32*)&PFout(1);//LED1
;;;101    //	Modbus_OutputIO[9]=(vu32*)&PFout(1);//LED1
;;;102    //	Modbus_OutputIO[10]=(vu32*)&PFout(1);//LED1
;;;103    //	Modbus_OutputIO[11]=(vu32*)&PFout(1);//LED1
;;;104    //	Modbus_OutputIO[12]=(vu32*)&PFout(1);//LED1
;;;105    //	Modbus_OutputIO[13]=(vu32*)&PFout(1);//LED1
;;;106    //	Modbus_OutputIO[14]=(vu32*)&PFout(1);//LED1
;;;107    //	Modbus_OutputIO[15]=(vu32*)&PFout(1);//LED1
;;;108           
;;;109    	//保持寄存器指针指向
;;;110    	 
;;;111    	//保持寄存器指针指向
;;;112    	for (i = 0; i < 1000; i++){
00002c  2000              MOVS     r0,#0
00002e  e003              B        |L9.56|
                  |L9.48|
;;;113    		Modbus_HoldReg[i] = i;
000030  4a09              LDR      r2,|L9.88|
000032  f8220010          STRH     r0,[r2,r0,LSL #1]
000036  1c40              ADDS     r0,r0,#1              ;112
                  |L9.56|
000038  f5b07f7a          CMP      r0,#0x3e8             ;112
00003c  dbf8              BLT      |L9.48|
;;;114    	}	
;;;115    }
00003e  4770              BX       lr
;;;116    
                          ENDP

                  |L9.64|
                          DCD      0x42220118
                  |L9.68|
                          DCD      Modbus_InputIO
                  |L9.72|
                          DCD      0x42210120
                  |L9.76|
                          DCD      0x4224012c
                  |L9.80|
                          DCD      0x42238180
                  |L9.84|
                          DCD      Modbus_OutputIO
                  |L9.88|
                          DCD      Modbus_HoldReg

                          AREA ||i.RS485_SendData||, CODE, READONLY, ALIGN=2

                  RS485_SendData PROC
;;;132    //len：发送的字节数
;;;133    void RS485_SendData(u8 *buff, u8 len)
000000  b570              PUSH     {r4-r6,lr}
;;;134    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;135    	//RS485_TX_EN=1;//切换为发送模式
;;;136    	while(len--){
000006  e00b              B        |L10.32|
                  |L10.8|
;;;137    	#if (MODBUS_RTU_USE_UART == 1)
;;;138    		while(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);//等待发送区为空
000008  bf00              NOP      
                  |L10.10|
00000a  2180              MOVS     r1,#0x80
00000c  480b              LDR      r0,|L10.60|
00000e  f7fffffe          BL       USART_GetFlagStatus
000012  2800              CMP      r0,#0
000014  d0f9              BEQ      |L10.10|
;;;139    		USART_SendData(USART1,*(buff++));
000016  f8141b01          LDRB     r1,[r4],#1
00001a  4808              LDR      r0,|L10.60|
00001c  f7fffffe          BL       USART_SendData
                  |L10.32|
000020  1e28              SUBS     r0,r5,#0              ;136
000022  f1a50101          SUB      r1,r5,#1              ;136
000026  b2cd              UXTB     r5,r1                 ;136
000028  d1ee              BNE      |L10.8|
;;;140    	#elif (MODBUS_RTU_USE_UART == 2)
;;;141    		while(USART_GetFlagStatus(USART2,USART_FLAG_TXE)==RESET);//等待发送区为空
;;;142    		USART_SendData(USART2,*(buff++));
;;;143    	#endif
;;;144    	}
;;;145    #if (MODBUS_RTU_USE_UART == 1)
;;;146    	while(USART_GetFlagStatus(USART1,USART_FLAG_TC)==RESET);//等待发送完成
00002a  bf00              NOP      
                  |L10.44|
00002c  2140              MOVS     r1,#0x40
00002e  4803              LDR      r0,|L10.60|
000030  f7fffffe          BL       USART_GetFlagStatus
000034  2800              CMP      r0,#0
000036  d0f9              BEQ      |L10.44|
;;;147    #elif (MODBUS_RTU_USE_UART == 2)
;;;148    	while(USART_GetFlagStatus(USART2,USART_FLAG_TC)==RESET);//等待发送完成
;;;149    #endif
;;;150    }
000038  bd70              POP      {r4-r6,pc}
;;;151    
                          ENDP

00003a  0000              DCW      0x0000
                  |L10.60|
                          DCD      0x40013800

                          AREA ||i.modbus_analyze||, CODE, READONLY, ALIGN=2

                  modbus_analyze PROC
;;;151    
;;;152    void modbus_analyze(u8 * _data_buf)
000000  b570              PUSH     {r4-r6,lr}
;;;153    {
000002  4604              MOV      r4,r0
;;;154    	u16 crc;
;;;155    	u16 startRegAddr;
;;;156    	if((_data_buf[1]==01)||(_data_buf[1]==02)||(_data_buf[1]==03)||(_data_buf[1]==05)||(_data_buf[1]==06)||(_data_buf[1]==15)||(_data_buf[1]==16))//功能码正确
000004  7860              LDRB     r0,[r4,#1]
000006  2801              CMP      r0,#1
000008  d011              BEQ      |L11.46|
00000a  7860              LDRB     r0,[r4,#1]
00000c  2802              CMP      r0,#2
00000e  d00e              BEQ      |L11.46|
000010  7860              LDRB     r0,[r4,#1]
000012  2803              CMP      r0,#3
000014  d00b              BEQ      |L11.46|
000016  7860              LDRB     r0,[r4,#1]
000018  2805              CMP      r0,#5
00001a  d008              BEQ      |L11.46|
00001c  7860              LDRB     r0,[r4,#1]
00001e  2806              CMP      r0,#6
000020  d005              BEQ      |L11.46|
000022  7860              LDRB     r0,[r4,#1]
000024  280f              CMP      r0,#0xf
000026  d002              BEQ      |L11.46|
000028  7860              LDRB     r0,[r4,#1]
00002a  2810              CMP      r0,#0x10
00002c  d166              BNE      |L11.252|
                  |L11.46|
;;;157    	{
;;;158    		startRegAddr=(((u16)_data_buf[2])<<8)|_data_buf[3];//获取寄存器起始地址
00002e  78e0              LDRB     r0,[r4,#3]
000030  78a1              LDRB     r1,[r4,#2]
000032  ea402601          ORR      r6,r0,r1,LSL #8
;;;159    		if(startRegAddr < 1000){//寄存器地址在范围内
000036  f5b67f7a          CMP      r6,#0x3e8
00003a  da51              BGE      |L11.224|
;;;160    			crc = cmd_analyze.rec_buf[rec_count - 2] << 8 | cmd_analyze.rec_buf[rec_count - 1];
00003c  4836              LDR      r0,|L11.280|
00003e  6800              LDR      r0,[r0,#0]  ; rec_count
000040  1e40              SUBS     r0,r0,#1
000042  4936              LDR      r1,|L11.284|
000044  5c09              LDRB     r1,[r1,r0]
000046  4834              LDR      r0,|L11.280|
000048  6800              LDR      r0,[r0,#0]  ; rec_count
00004a  1e80              SUBS     r0,r0,#2
00004c  4a33              LDR      r2,|L11.284|
00004e  5c10              LDRB     r0,[r2,r0]
000050  ea412500          ORR      r5,r1,r0,LSL #8
;;;161    			if (crc == CRC16 (cmd_analyze.rec_buf, rec_count - 2)){//CRC校验正确                           
000054  4830              LDR      r0,|L11.280|
000056  8800              LDRH     r0,[r0,#0]  ; rec_count
000058  1e80              SUBS     r0,r0,#2
00005a  b281              UXTH     r1,r0
00005c  4610              MOV      r0,r2
00005e  f7fffffe          BL       CRC16
000062  42a8              CMP      r0,r5
000064  d12e              BNE      |L11.196|
;;;162    			/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;163    				switch(_data_buf[1])//根据不同的功能码进行处理
000066  7860              LDRB     r0,[r4,#1]
000068  2805              CMP      r0,#5
00006a  d01a              BEQ      |L11.162|
00006c  dc06              BGT      |L11.124|
00006e  2801              CMP      r0,#1
000070  d00b              BEQ      |L11.138|
000072  2802              CMP      r0,#2
000074  d00d              BEQ      |L11.146|
000076  2803              CMP      r0,#3
000078  d123              BNE      |L11.194|
00007a  e00e              B        |L11.154|
                  |L11.124|
00007c  2806              CMP      r0,#6
00007e  d014              BEQ      |L11.170|
000080  280f              CMP      r0,#0xf
000082  d016              BEQ      |L11.178|
000084  2810              CMP      r0,#0x10
000086  d11c              BNE      |L11.194|
000088  e017              B        |L11.186|
                  |L11.138|
;;;164    				{
;;;165    					case 1:{//读输出开关量
;;;166    						Modbus_01_Solve(_data_buf);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       Modbus_01_Solve
;;;167    						break;
000090  e017              B        |L11.194|
                  |L11.146|
;;;168    					}
;;;169    					case 2:{//读输入开关量
;;;170    						Modbus_02_Solve(_data_buf);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       Modbus_02_Solve
;;;171    						break;
000098  e013              B        |L11.194|
                  |L11.154|
;;;172    					}
;;;173    					case 03:{//读多个寄存器
;;;174    						Modbus_03_Solve(_data_buf);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       Modbus_03_Solve
;;;175    						break;
0000a0  e00f              B        |L11.194|
                  |L11.162|
;;;176    					}
;;;177    					case 5:{//写单个输出开关量
;;;178    						Modbus_05_Solve(_data_buf);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       Modbus_05_Solve
;;;179    						break;
0000a8  e00b              B        |L11.194|
                  |L11.170|
;;;180    					}       
;;;181    					case 06: {//写单个寄存器
;;;182    						Modbus_06_Solve(_data_buf);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       Modbus_06_Solve
;;;183    						break;
0000b0  e007              B        |L11.194|
                  |L11.178|
;;;184    					}
;;;185    					case 15:{//写多个输出开关量
;;;186    						Modbus_15_Solve(_data_buf);
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       Modbus_15_Solve
;;;187    						break;
0000b8  e003              B        |L11.194|
                  |L11.186|
;;;188    					}    
;;;189    					case 16:{ //写多个寄存器
;;;190    						Modbus_16_Solve(_data_buf);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       Modbus_16_Solve
;;;191    						break;
0000c0  bf00              NOP      
                  |L11.194|
0000c2  e028              B        |L11.278|
                  |L11.196|
;;;192    					}		                               
;;;193    				}
;;;194    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;195    			}
;;;196    			else//CRC校验错误
;;;197    			{
;;;198    				RS485_TX_BUFF[0]=_data_buf[0];
0000c4  7820              LDRB     r0,[r4,#0]
0000c6  4916              LDR      r1,|L11.288|
0000c8  7008              STRB     r0,[r1,#0]
;;;199    				RS485_TX_BUFF[1]=_data_buf[1]| 0x80;
0000ca  7860              LDRB     r0,[r4,#1]
0000cc  f0400080          ORR      r0,r0,#0x80
0000d0  7048              STRB     r0,[r1,#1]
;;;200    				RS485_TX_BUFF[2]=0x04; //异常码
0000d2  2004              MOVS     r0,#4
0000d4  7088              STRB     r0,[r1,#2]
;;;201    				RS485_SendData(RS485_TX_BUFF,3);
0000d6  2103              MOVS     r1,#3
0000d8  4811              LDR      r0,|L11.288|
0000da  f7fffffe          BL       RS485_SendData
0000de  e01a              B        |L11.278|
                  |L11.224|
;;;202    			}       
;;;203    		}
;;;204    		else//寄存器地址超出范围
;;;205    		{
;;;206    			RS485_TX_BUFF[0]=_data_buf[0];
0000e0  7820              LDRB     r0,[r4,#0]
0000e2  490f              LDR      r1,|L11.288|
0000e4  7008              STRB     r0,[r1,#0]
;;;207    			RS485_TX_BUFF[1]=_data_buf[1]|0x80;
0000e6  7860              LDRB     r0,[r4,#1]
0000e8  f0400080          ORR      r0,r0,#0x80
0000ec  7048              STRB     r0,[r1,#1]
;;;208    			RS485_TX_BUFF[2]=0x02; //异常码
0000ee  2002              MOVS     r0,#2
0000f0  7088              STRB     r0,[r1,#2]
;;;209    			RS485_SendData(RS485_TX_BUFF,3);
0000f2  2103              MOVS     r1,#3
0000f4  480a              LDR      r0,|L11.288|
0000f6  f7fffffe          BL       RS485_SendData
0000fa  e00c              B        |L11.278|
                  |L11.252|
;;;210    		}                                               
;;;211    	}
;;;212    	else//功能码错误
;;;213    	{
;;;214    		RS485_TX_BUFF[0]=_data_buf[0];
0000fc  7820              LDRB     r0,[r4,#0]
0000fe  4908              LDR      r1,|L11.288|
000100  7008              STRB     r0,[r1,#0]
;;;215    		RS485_TX_BUFF[1]=_data_buf[1]|0x80;
000102  7860              LDRB     r0,[r4,#1]
000104  f0400080          ORR      r0,r0,#0x80
000108  7048              STRB     r0,[r1,#1]
;;;216    		RS485_TX_BUFF[2]=0x01; //异常码
00010a  2001              MOVS     r0,#1
00010c  7088              STRB     r0,[r1,#2]
;;;217    		RS485_SendData(RS485_TX_BUFF,3);
00010e  2103              MOVS     r1,#3
000110  4803              LDR      r0,|L11.288|
000112  f7fffffe          BL       RS485_SendData
                  |L11.278|
;;;218    	}
;;;219    	
;;;220    	//RS485_TX_EN=0;//开启接收模式  
;;;221    }
000116  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP

                  |L11.280|
                          DCD      rec_count
                  |L11.284|
                          DCD      cmd_analyze
                  |L11.288|
                          DCD      RS485_TX_BUFF

                          AREA ||i.modbus_init||, CODE, READONLY, ALIGN=1

                  modbus_init PROC
;;;116    
;;;117    void modbus_init(void)
000000  b500              PUSH     {lr}
;;;118    {
;;;119    	Modbus_RegMap ();
000002  f7fffffe          BL       Modbus_RegMap
;;;120    }
000006  bd00              POP      {pc}
;;;121    void Modbus_01_Solve(u8 * _data_buf);
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RS485_TX_BUFF
                          %        128
                  Modbus_InputIO
                          %        400
                  Modbus_OutputIO
                          %        400
                  Modbus_HoldReg
                          %        2000

                          AREA ||.data||, DATA, ALIGN=1

                  auchCRCHi
000000  00c18140          DCB      0x00,0xc1,0x81,0x40
000004  01c08041          DCB      0x01,0xc0,0x80,0x41
000008  01c08041          DCB      0x01,0xc0,0x80,0x41
00000c  00c18140          DCB      0x00,0xc1,0x81,0x40
000010  01c08041          DCB      0x01,0xc0,0x80,0x41
000014  00c18140          DCB      0x00,0xc1,0x81,0x40
000018  00c18140          DCB      0x00,0xc1,0x81,0x40
00001c  01c08041          DCB      0x01,0xc0,0x80,0x41
000020  01c08041          DCB      0x01,0xc0,0x80,0x41
000024  00c18140          DCB      0x00,0xc1,0x81,0x40
000028  00c18140          DCB      0x00,0xc1,0x81,0x40
00002c  01c08041          DCB      0x01,0xc0,0x80,0x41
000030  00c18140          DCB      0x00,0xc1,0x81,0x40
000034  01c08041          DCB      0x01,0xc0,0x80,0x41
000038  01c08041          DCB      0x01,0xc0,0x80,0x41
00003c  00c18140          DCB      0x00,0xc1,0x81,0x40
000040  01c08041          DCB      0x01,0xc0,0x80,0x41
000044  00c18140          DCB      0x00,0xc1,0x81,0x40
000048  00c18140          DCB      0x00,0xc1,0x81,0x40
00004c  01c08041          DCB      0x01,0xc0,0x80,0x41
000050  00c18140          DCB      0x00,0xc1,0x81,0x40
000054  01c08041          DCB      0x01,0xc0,0x80,0x41
000058  01c08041          DCB      0x01,0xc0,0x80,0x41
00005c  00c18140          DCB      0x00,0xc1,0x81,0x40
000060  00c18140          DCB      0x00,0xc1,0x81,0x40
000064  01c08041          DCB      0x01,0xc0,0x80,0x41
000068  01c08041          DCB      0x01,0xc0,0x80,0x41
00006c  00c18140          DCB      0x00,0xc1,0x81,0x40
000070  01c08041          DCB      0x01,0xc0,0x80,0x41
000074  00c18140          DCB      0x00,0xc1,0x81,0x40
000078  00c18140          DCB      0x00,0xc1,0x81,0x40
00007c  01c08041          DCB      0x01,0xc0,0x80,0x41
000080  01c08041          DCB      0x01,0xc0,0x80,0x41
000084  00c18140          DCB      0x00,0xc1,0x81,0x40
000088  00c18140          DCB      0x00,0xc1,0x81,0x40
00008c  01c08041          DCB      0x01,0xc0,0x80,0x41
000090  00c18140          DCB      0x00,0xc1,0x81,0x40
000094  01c08041          DCB      0x01,0xc0,0x80,0x41
000098  01c08041          DCB      0x01,0xc0,0x80,0x41
00009c  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  auchCRCLo
000100  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000104  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000108  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00010c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000110  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000114  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000118  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00011c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000120  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000124  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000128  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00012c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000130  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000134  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000138  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00013c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000140  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000144  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000148  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00014c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000150  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000154  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000158  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00015c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000160  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000164  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000168  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00016c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000170  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000174  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000178  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00017c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000180  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000184  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000188  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00018c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000190  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000194  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000198  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00019c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0001a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0001a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0001a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0001ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0001b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0001b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0001b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0001bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0001c0  50909151          DCB      0x50,0x90,0x91,0x51
0001c4  93535292          DCB      0x93,0x53,0x52,0x92
0001c8  96565797          DCB      0x96,0x56,0x57,0x97
0001cc  55959454          DCB      0x55,0x95,0x94,0x54
0001d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0001d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0001d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0001dc  99595898          DCB      0x99,0x59,0x58,0x98
0001e0  88484989          DCB      0x88,0x48,0x49,0x89
0001e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0001e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0001ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0001f0  44848545          DCB      0x44,0x84,0x85,0x45
0001f4  87474686          DCB      0x87,0x47,0x46,0x86
0001f8  82424383          DCB      0x82,0x42,0x43,0x83
0001fc  41818040          DCB      0x41,0x81,0x80,0x40
                  RS485_TX_CNT
000200  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "Protocol\\ModbusRTU.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_ModbusRTU_c_171d0f2a____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_ModbusRTU_c_171d0f2a____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_ModbusRTU_c_171d0f2a____REVSH|
#line 462
|__asm___11_ModbusRTU_c_171d0f2a____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_ModbusRTU_c_171d0f2a____RRX|
#line 649
|__asm___11_ModbusRTU_c_171d0f2a____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
