; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\os_q.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_q.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\os_q.crf UCOSII\CORE\os_q.c]
                          THUMB

                          AREA ||i.OSQAccept||, CODE, READONLY, ALIGN=1

                  OSQAccept PROC
;;;60     #if OS_Q_ACCEPT_EN > 0u
;;;61     void  *OSQAccept (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;62                       INT8U     *perr)
;;;63     {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;64         void      *pmsg;
;;;65         OS_Q      *pq;
;;;66     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;67         OS_CPU_SR  cpu_sr = 0u;
000008  f04f0800          MOV      r8,#0
;;;68     #endif
;;;69     
;;;70     
;;;71     
;;;72     #ifdef OS_SAFETY_CRITICAL
;;;73         if (perr == (INT8U *)0) {
;;;74             OS_SAFETY_CRITICAL_EXCEPTION();
;;;75         }
;;;76     #endif
;;;77     
;;;78     #if OS_ARG_CHK_EN > 0u
;;;79         if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
;;;80             *perr = OS_ERR_PEVENT_NULL;
;;;81             return ((void *)0);
;;;82         }
;;;83     #endif
;;;84         if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00000c  7830              LDRB     r0,[r6,#0]
00000e  2802              CMP      r0,#2
000010  d004              BEQ      |L1.28|
;;;85             *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7028              STRB     r0,[r5,#0]
;;;86             return ((void *)0);
000016  2000              MOVS     r0,#0
                  |L1.24|
;;;87         }
;;;88         OS_ENTER_CRITICAL();
;;;89         pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
;;;90         if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
;;;91             pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
;;;92             pq->OSQEntries--;                        /* Update the number of entries in the queue          */
;;;93             if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
;;;94                 pq->OSQOut = pq->OSQStart;
;;;95             }
;;;96             *perr = OS_ERR_NONE;
;;;97         } else {
;;;98             *perr = OS_ERR_Q_EMPTY;
;;;99             pmsg  = (void *)0;                       /* Queue is empty                                     */
;;;100        }
;;;101        OS_EXIT_CRITICAL();
;;;102        return (pmsg);                               /* Return message received (or NULL)                  */
;;;103    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L1.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4680              MOV      r8,r0                 ;88
000022  6874              LDR      r4,[r6,#4]            ;89
000024  8ae0              LDRH     r0,[r4,#0x16]         ;90
000026  b178              CBZ      r0,|L1.72|
000028  6921              LDR      r1,[r4,#0x10]         ;91
00002a  1d08              ADDS     r0,r1,#4              ;91
00002c  6120              STR      r0,[r4,#0x10]         ;91
00002e  680f              LDR      r7,[r1,#0]            ;91
000030  8ae0              LDRH     r0,[r4,#0x16]         ;92
000032  1e40              SUBS     r0,r0,#1              ;92
000034  82e0              STRH     r0,[r4,#0x16]         ;92
000036  68a1              LDR      r1,[r4,#8]            ;93
000038  6920              LDR      r0,[r4,#0x10]         ;93
00003a  4288              CMP      r0,r1                 ;93
00003c  d101              BNE      |L1.66|
00003e  6860              LDR      r0,[r4,#4]            ;94
000040  6120              STR      r0,[r4,#0x10]         ;94
                  |L1.66|
000042  2000              MOVS     r0,#0                 ;96
000044  7028              STRB     r0,[r5,#0]            ;96
000046  e002              B        |L1.78|
                  |L1.72|
000048  201f              MOVS     r0,#0x1f              ;98
00004a  7028              STRB     r0,[r5,#0]            ;98
00004c  2700              MOVS     r7,#0                 ;99
                  |L1.78|
00004e  4640              MOV      r0,r8                 ;101
000050  f7fffffe          BL       OS_CPU_SR_Restore
000054  4638              MOV      r0,r7                 ;102
000056  e7df              B        |L1.24|
;;;104    #endif
                          ENDP


                          AREA ||i.OSQCreate||, CODE, READONLY, ALIGN=2

                  OSQCreate PROC
;;;124    
;;;125    OS_EVENT  *OSQCreate (void    **start,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;126                          INT16U    size)
;;;127    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;128        OS_EVENT  *pevent;
;;;129        OS_Q      *pq;
;;;130    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;131        OS_CPU_SR  cpu_sr = 0u;
000008  f04f0800          MOV      r8,#0
;;;132    #endif
;;;133    
;;;134    
;;;135    
;;;136    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;137        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;138            OS_SAFETY_CRITICAL_EXCEPTION();
;;;139        }
;;;140    #endif
;;;141    
;;;142        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
00000c  481f              LDR      r0,|L2.140|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b110              CBZ      r0,|L2.24|
;;;143            return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000012  2000              MOVS     r0,#0
                  |L2.20|
;;;144        }
;;;145        OS_ENTER_CRITICAL();
;;;146        pevent = OSEventFreeList;                    /* Get next free event control block                  */
;;;147        if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
;;;148            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;149        }
;;;150        OS_EXIT_CRITICAL();
;;;151        if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
;;;152            OS_ENTER_CRITICAL();
;;;153            pq = OSQFreeList;                        /* Get a free queue control block                     */
;;;154            if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
;;;155                OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
;;;156                OS_EXIT_CRITICAL();
;;;157                pq->OSQStart           = start;               /*      Initialize the queue                 */
;;;158                pq->OSQEnd             = &start[size];
;;;159                pq->OSQIn              = start;
;;;160                pq->OSQOut             = start;
;;;161                pq->OSQSize            = size;
;;;162                pq->OSQEntries         = 0u;
;;;163                pevent->OSEventType    = OS_EVENT_TYPE_Q;
;;;164                pevent->OSEventCnt     = 0u;
;;;165                pevent->OSEventPtr     = pq;
;;;166    #if OS_EVENT_NAME_EN > 0u
;;;167                pevent->OSEventName    = (INT8U *)(void *)"?";
;;;168    #endif
;;;169                OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
;;;170            } else {
;;;171                pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
;;;172                OSEventFreeList    = pevent;
;;;173                OS_EXIT_CRITICAL();
;;;174                pevent = (OS_EVENT *)0;
;;;175            }
;;;176        }
;;;177        return (pevent);
;;;178    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L2.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4680              MOV      r8,r0                 ;145
00001e  481c              LDR      r0,|L2.144|
000020  6805              LDR      r5,[r0,#0]            ;146  ; OSEventFreeList
000022  6800              LDR      r0,[r0,#0]            ;147  ; OSEventFreeList
000024  b120              CBZ      r0,|L2.48|
000026  481a              LDR      r0,|L2.144|
000028  6800              LDR      r0,[r0,#0]            ;148  ; OSEventFreeList
00002a  6840              LDR      r0,[r0,#4]            ;148
00002c  4918              LDR      r1,|L2.144|
00002e  6008              STR      r0,[r1,#0]            ;148  ; OSEventFreeList
                  |L2.48|
000030  4640              MOV      r0,r8                 ;150
000032  f7fffffe          BL       OS_CPU_SR_Restore
000036  b33d              CBZ      r5,|L2.136|
000038  f7fffffe          BL       OS_CPU_SR_Save
00003c  4680              MOV      r8,r0                 ;152
00003e  4815              LDR      r0,|L2.148|
000040  6804              LDR      r4,[r0,#0]            ;153  ; OSQFreeList
000042  b1c4              CBZ      r4,|L2.118|
000044  6800              LDR      r0,[r0,#0]            ;155  ; OSQFreeList
000046  6800              LDR      r0,[r0,#0]            ;155
000048  4912              LDR      r1,|L2.148|
00004a  6008              STR      r0,[r1,#0]            ;155  ; OSQFreeList
00004c  4640              MOV      r0,r8                 ;156
00004e  f7fffffe          BL       OS_CPU_SR_Restore
000052  6066              STR      r6,[r4,#4]            ;157
000054  eb060087          ADD      r0,r6,r7,LSL #2       ;158
000058  60a0              STR      r0,[r4,#8]            ;158
00005a  60e6              STR      r6,[r4,#0xc]          ;159
00005c  6126              STR      r6,[r4,#0x10]         ;160
00005e  82a7              STRH     r7,[r4,#0x14]         ;161
000060  2000              MOVS     r0,#0                 ;162
000062  82e0              STRH     r0,[r4,#0x16]         ;162
000064  2002              MOVS     r0,#2                 ;163
000066  7028              STRB     r0,[r5,#0]            ;163
000068  2000              MOVS     r0,#0                 ;164
00006a  8128              STRH     r0,[r5,#8]            ;164
00006c  606c              STR      r4,[r5,#4]            ;165
00006e  4628              MOV      r0,r5                 ;169
000070  f7fffffe          BL       OS_EventWaitListInit
000074  e008              B        |L2.136|
                  |L2.118|
000076  4806              LDR      r0,|L2.144|
000078  6800              LDR      r0,[r0,#0]            ;171  ; OSEventFreeList
00007a  6068              STR      r0,[r5,#4]            ;171
00007c  4804              LDR      r0,|L2.144|
00007e  6005              STR      r5,[r0,#0]            ;172  ; OSEventFreeList
000080  4640              MOV      r0,r8                 ;173
000082  f7fffffe          BL       OS_CPU_SR_Restore
000086  2500              MOVS     r5,#0                 ;174
                  |L2.136|
000088  4628              MOV      r0,r5                 ;177
00008a  e7c3              B        |L2.20|
;;;179    /*$PAGE*/
                          ENDP

                  |L2.140|
                          DCD      OSIntNesting
                  |L2.144|
                          DCD      OSEventFreeList
                  |L2.148|
                          DCD      OSQFreeList

                          AREA ||i.OSQDel||, CODE, READONLY, ALIGN=2

                  OSQDel PROC
;;;221    #if OS_Q_DEL_EN > 0u
;;;222    OS_EVENT  *OSQDel (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;223                       INT8U      opt,
;;;224                       INT8U     *perr)
;;;225    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;226        BOOLEAN    tasks_waiting;
;;;227        OS_EVENT  *pevent_return;
;;;228        OS_Q      *pq;
;;;229    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;230        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;231    #endif
;;;232    
;;;233    
;;;234    
;;;235    #ifdef OS_SAFETY_CRITICAL
;;;236        if (perr == (INT8U *)0) {
;;;237            OS_SAFETY_CRITICAL_EXCEPTION();
;;;238        }
;;;239    #endif
;;;240    
;;;241    #if OS_ARG_CHK_EN > 0u
;;;242        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;243            *perr = OS_ERR_PEVENT_NULL;
;;;244            return (pevent);
;;;245        }
;;;246    #endif
;;;247        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2802              CMP      r0,#2
000012  d004              BEQ      |L3.30|
;;;248            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;249            return (pevent);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;250        }
;;;251        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;252            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;253            return (pevent);
;;;254        }
;;;255        OS_ENTER_CRITICAL();
;;;256        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
;;;257            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;258        } else {
;;;259            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;260        }
;;;261        switch (opt) {
;;;262            case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
;;;263                 if (tasks_waiting == OS_FALSE) {
;;;264    #if OS_EVENT_NAME_EN > 0u
;;;265                     pevent->OSEventName    = (INT8U *)(void *)"?";
;;;266    #endif
;;;267                     pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
;;;268                     pq->OSQPtr             = OSQFreeList;
;;;269                     OSQFreeList            = pq;
;;;270                     pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;271                     pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
;;;272                     pevent->OSEventCnt     = 0u;
;;;273                     OSEventFreeList        = pevent;          /* Get next free event control block        */
;;;274                     OS_EXIT_CRITICAL();
;;;275                     *perr                  = OS_ERR_NONE;
;;;276                     pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
;;;277                 } else {
;;;278                     OS_EXIT_CRITICAL();
;;;279                     *perr                  = OS_ERR_TASK_WAITING;
;;;280                     pevent_return          = pevent;
;;;281                 }
;;;282                 break;
;;;283    
;;;284            case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
;;;285                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
;;;286                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
;;;287                 }
;;;288    #if OS_EVENT_NAME_EN > 0u
;;;289                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;290    #endif
;;;291                 pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
;;;292                 pq->OSQPtr             = OSQFreeList;
;;;293                 OSQFreeList            = pq;
;;;294                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;295                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;296                 pevent->OSEventCnt     = 0u;
;;;297                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;298                 OS_EXIT_CRITICAL();
;;;299                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;300                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;301                 }
;;;302                 *perr                  = OS_ERR_NONE;
;;;303                 pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
;;;304                 break;
;;;305    
;;;306            default:
;;;307                 OS_EXIT_CRITICAL();
;;;308                 *perr                  = OS_ERR_INVALID_OPT;
;;;309                 pevent_return          = pevent;
;;;310                 break;
;;;311        }
;;;312        return (pevent_return);
;;;313    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  4833              LDR      r0,|L3.236|
000020  7800              LDRB     r0,[r0,#0]            ;251  ; OSIntNesting
000022  b118              CBZ      r0,|L3.44|
000024  200f              MOVS     r0,#0xf               ;252
000026  7028              STRB     r0,[r5,#0]            ;252
000028  4620              MOV      r0,r4                 ;253
00002a  e7f6              B        |L3.26|
                  |L3.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4682              MOV      r10,r0                ;255
000032  7aa0              LDRB     r0,[r4,#0xa]          ;256
000034  b110              CBZ      r0,|L3.60|
000036  f04f0801          MOV      r8,#1                 ;257
00003a  e001              B        |L3.64|
                  |L3.60|
00003c  f04f0800          MOV      r8,#0                 ;259
                  |L3.64|
000040  f1b90f00          CMP      r9,#0                 ;261
000044  d003              BEQ      |L3.78|
000046  f1b90f01          CMP      r9,#1                 ;261
00004a  d145              BNE      |L3.216|
00004c  e01f              B        |L3.142|
                  |L3.78|
00004e  f1b80f00          CMP      r8,#0                 ;263
000052  d115              BNE      |L3.128|
000054  6866              LDR      r6,[r4,#4]            ;267
000056  4826              LDR      r0,|L3.240|
000058  6800              LDR      r0,[r0,#0]            ;268  ; OSQFreeList
00005a  6030              STR      r0,[r6,#0]            ;268
00005c  4824              LDR      r0,|L3.240|
00005e  6006              STR      r6,[r0,#0]            ;269  ; OSQFreeList
000060  2000              MOVS     r0,#0                 ;270
000062  7020              STRB     r0,[r4,#0]            ;270
000064  4823              LDR      r0,|L3.244|
000066  6800              LDR      r0,[r0,#0]            ;271  ; OSEventFreeList
000068  6060              STR      r0,[r4,#4]            ;271
00006a  2000              MOVS     r0,#0                 ;272
00006c  8120              STRH     r0,[r4,#8]            ;272
00006e  4821              LDR      r0,|L3.244|
000070  6004              STR      r4,[r0,#0]            ;273  ; OSEventFreeList
000072  4650              MOV      r0,r10                ;274
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;275
00007a  7028              STRB     r0,[r5,#0]            ;275
00007c  2700              MOVS     r7,#0                 ;276
00007e  e005              B        |L3.140|
                  |L3.128|
000080  4650              MOV      r0,r10                ;278
000082  f7fffffe          BL       OS_CPU_SR_Restore
000086  2049              MOVS     r0,#0x49              ;279
000088  7028              STRB     r0,[r5,#0]            ;279
00008a  4627              MOV      r7,r4                 ;280
                  |L3.140|
00008c  e02b              B        |L3.230|
                  |L3.142|
00008e  e005              B        |L3.156|
                  |L3.144|
000090  2300              MOVS     r3,#0                 ;286
000092  2204              MOVS     r2,#4                 ;286
000094  4619              MOV      r1,r3                 ;286
000096  4620              MOV      r0,r4                 ;286
000098  f7fffffe          BL       OS_EventTaskRdy
                  |L3.156|
00009c  7aa0              LDRB     r0,[r4,#0xa]          ;285
00009e  2800              CMP      r0,#0                 ;285
0000a0  d1f6              BNE      |L3.144|
0000a2  6866              LDR      r6,[r4,#4]            ;291
0000a4  4812              LDR      r0,|L3.240|
0000a6  6800              LDR      r0,[r0,#0]            ;292  ; OSQFreeList
0000a8  6030              STR      r0,[r6,#0]            ;292
0000aa  4811              LDR      r0,|L3.240|
0000ac  6006              STR      r6,[r0,#0]            ;293  ; OSQFreeList
0000ae  2000              MOVS     r0,#0                 ;294
0000b0  7020              STRB     r0,[r4,#0]            ;294
0000b2  4810              LDR      r0,|L3.244|
0000b4  6800              LDR      r0,[r0,#0]            ;295  ; OSEventFreeList
0000b6  6060              STR      r0,[r4,#4]            ;295
0000b8  2000              MOVS     r0,#0                 ;296
0000ba  8120              STRH     r0,[r4,#8]            ;296
0000bc  480d              LDR      r0,|L3.244|
0000be  6004              STR      r4,[r0,#0]            ;297  ; OSEventFreeList
0000c0  4650              MOV      r0,r10                ;298
0000c2  f7fffffe          BL       OS_CPU_SR_Restore
0000c6  f1b80f01          CMP      r8,#1                 ;299
0000ca  d101              BNE      |L3.208|
0000cc  f7fffffe          BL       OS_Sched
                  |L3.208|
0000d0  2000              MOVS     r0,#0                 ;302
0000d2  7028              STRB     r0,[r5,#0]            ;302
0000d4  2700              MOVS     r7,#0                 ;303
0000d6  e006              B        |L3.230|
                  |L3.216|
0000d8  4650              MOV      r0,r10                ;307
0000da  f7fffffe          BL       OS_CPU_SR_Restore
0000de  2007              MOVS     r0,#7                 ;308
0000e0  7028              STRB     r0,[r5,#0]            ;308
0000e2  4627              MOV      r7,r4                 ;309
0000e4  bf00              NOP                            ;310
                  |L3.230|
0000e6  bf00              NOP                            ;282
0000e8  4638              MOV      r0,r7                 ;312
0000ea  e796              B        |L3.26|
;;;314    #endif
                          ENDP

                  |L3.236|
                          DCD      OSIntNesting
                  |L3.240|
                          DCD      OSQFreeList
                  |L3.244|
                          DCD      OSEventFreeList

                          AREA ||i.OSQFlush||, CODE, READONLY, ALIGN=1

                  OSQFlush PROC
;;;336    #if OS_Q_FLUSH_EN > 0u
;;;337    INT8U  OSQFlush (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;338    {
000002  4605              MOV      r5,r0
;;;339        OS_Q      *pq;
;;;340    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;341        OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;342    #endif
;;;343    
;;;344    
;;;345    
;;;346    #if OS_ARG_CHK_EN > 0u
;;;347        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;348            return (OS_ERR_PEVENT_NULL);
;;;349        }
;;;350        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
;;;351            return (OS_ERR_EVENT_TYPE);
;;;352        }
;;;353    #endif
;;;354        OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4606              MOV      r6,r0
;;;355        pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
00000c  686c              LDR      r4,[r5,#4]
;;;356        pq->OSQIn      = pq->OSQStart;
00000e  6860              LDR      r0,[r4,#4]
000010  60e0              STR      r0,[r4,#0xc]
;;;357        pq->OSQOut     = pq->OSQStart;
000012  6860              LDR      r0,[r4,#4]
000014  6120              STR      r0,[r4,#0x10]
;;;358        pq->OSQEntries = 0u;
000016  2000              MOVS     r0,#0
000018  82e0              STRH     r0,[r4,#0x16]
;;;359        OS_EXIT_CRITICAL();
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       OS_CPU_SR_Restore
;;;360        return (OS_ERR_NONE);
000020  2000              MOVS     r0,#0
;;;361    }
000022  bd70              POP      {r4-r6,pc}
;;;362    #endif
                          ENDP


                          AREA ||i.OSQPend||, CODE, READONLY, ALIGN=2

                  OSQPend PROC
;;;400    
;;;401    void  *OSQPend (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;402                    INT32U     timeout,
;;;403                    INT8U     *perr)
;;;404    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;405        void      *pmsg;
;;;406        OS_Q      *pq;
;;;407    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;408        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;409    #endif
;;;410    
;;;411    
;;;412    
;;;413    #ifdef OS_SAFETY_CRITICAL
;;;414        if (perr == (INT8U *)0) {
;;;415            OS_SAFETY_CRITICAL_EXCEPTION();
;;;416        }
;;;417    #endif
;;;418    
;;;419    #if OS_ARG_CHK_EN > 0u
;;;420        if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
;;;421            *perr = OS_ERR_PEVENT_NULL;
;;;422            return ((void *)0);
;;;423        }
;;;424    #endif
;;;425        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00000e  7838              LDRB     r0,[r7,#0]
000010  2802              CMP      r0,#2
000012  d004              BEQ      |L5.30|
;;;426            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;427            return ((void *)0);
000018  2000              MOVS     r0,#0
                  |L5.26|
;;;428        }
;;;429        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
;;;430            *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
;;;431            return ((void *)0);
;;;432        }
;;;433        if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
;;;434            *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
;;;435            return ((void *)0);
;;;436        }
;;;437        OS_ENTER_CRITICAL();
;;;438        pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
;;;439        if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
;;;440            pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
;;;441            pq->OSQEntries--;                        /* Update the number of entries in the queue          */
;;;442            if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
;;;443                pq->OSQOut = pq->OSQStart;
;;;444            }
;;;445            OS_EXIT_CRITICAL();
;;;446            *perr = OS_ERR_NONE;
;;;447            return (pmsg);                           /* Return message received                            */
;;;448        }
;;;449        OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
;;;450        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;451        OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
;;;452        OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
;;;453        OS_EXIT_CRITICAL();
;;;454        OS_Sched();                                  /* Find next highest priority task ready to run       */
;;;455        OS_ENTER_CRITICAL();
;;;456        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;457            case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
;;;458                 pmsg =  OSTCBCur->OSTCBMsg;
;;;459                *perr =  OS_ERR_NONE;
;;;460                 break;
;;;461    
;;;462            case OS_STAT_PEND_ABORT:
;;;463                 pmsg = (void *)0;
;;;464                *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;465                 break;
;;;466    
;;;467            case OS_STAT_PEND_TO:
;;;468            default:
;;;469                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;470                 pmsg = (void *)0;
;;;471                *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;472                 break;
;;;473        }
;;;474        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;475        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;476        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;477    #if (OS_EVENT_MULTI_EN > 0u)
;;;478        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;479    #endif
;;;480        OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
;;;481        OS_EXIT_CRITICAL();
;;;482        return (pmsg);                                    /* Return received message                       */
;;;483    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L5.30|
00001e  483c              LDR      r0,|L5.272|
000020  7800              LDRB     r0,[r0,#0]            ;429  ; OSIntNesting
000022  b118              CBZ      r0,|L5.44|
000024  2002              MOVS     r0,#2                 ;430
000026  7028              STRB     r0,[r5,#0]            ;430
000028  2000              MOVS     r0,#0                 ;431
00002a  e7f6              B        |L5.26|
                  |L5.44|
00002c  4839              LDR      r0,|L5.276|
00002e  7800              LDRB     r0,[r0,#0]            ;433  ; OSLockNesting
000030  b118              CBZ      r0,|L5.58|
000032  200d              MOVS     r0,#0xd               ;434
000034  7028              STRB     r0,[r5,#0]            ;434
000036  2000              MOVS     r0,#0                 ;435
000038  e7ef              B        |L5.26|
                  |L5.58|
00003a  f7fffffe          BL       OS_CPU_SR_Save
00003e  4681              MOV      r9,r0                 ;437
000040  687c              LDR      r4,[r7,#4]            ;438
000042  8ae0              LDRH     r0,[r4,#0x16]         ;439
000044  b198              CBZ      r0,|L5.110|
000046  6921              LDR      r1,[r4,#0x10]         ;440
000048  1d08              ADDS     r0,r1,#4              ;440
00004a  6120              STR      r0,[r4,#0x10]         ;440
00004c  680e              LDR      r6,[r1,#0]            ;440
00004e  8ae0              LDRH     r0,[r4,#0x16]         ;441
000050  1e40              SUBS     r0,r0,#1              ;441
000052  82e0              STRH     r0,[r4,#0x16]         ;441
000054  68a1              LDR      r1,[r4,#8]            ;442
000056  6920              LDR      r0,[r4,#0x10]         ;442
000058  4288              CMP      r0,r1                 ;442
00005a  d101              BNE      |L5.96|
00005c  6860              LDR      r0,[r4,#4]            ;443
00005e  6120              STR      r0,[r4,#0x10]         ;443
                  |L5.96|
000060  4648              MOV      r0,r9                 ;445
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  2000              MOVS     r0,#0                 ;446
000068  7028              STRB     r0,[r5,#0]            ;446
00006a  4630              MOV      r0,r6                 ;447
00006c  e7d5              B        |L5.26|
                  |L5.110|
00006e  482a              LDR      r0,|L5.280|
000070  6800              LDR      r0,[r0,#0]            ;449  ; OSTCBCur
000072  f8900030          LDRB     r0,[r0,#0x30]         ;449
000076  f0400004          ORR      r0,r0,#4              ;449
00007a  4927              LDR      r1,|L5.280|
00007c  6809              LDR      r1,[r1,#0]            ;449  ; OSTCBCur
00007e  f8810030          STRB     r0,[r1,#0x30]         ;449
000082  2000              MOVS     r0,#0                 ;450
000084  4924              LDR      r1,|L5.280|
000086  6809              LDR      r1,[r1,#0]            ;450  ; OSTCBCur
000088  f8810031          STRB     r0,[r1,#0x31]         ;450
00008c  4822              LDR      r0,|L5.280|
00008e  6800              LDR      r0,[r0,#0]            ;451  ; OSTCBCur
000090  f8c0802c          STR      r8,[r0,#0x2c]         ;451
000094  4638              MOV      r0,r7                 ;452
000096  f7fffffe          BL       OS_EventTaskWait
00009a  4648              MOV      r0,r9                 ;453
00009c  f7fffffe          BL       OS_CPU_SR_Restore
0000a0  f7fffffe          BL       OS_Sched
0000a4  f7fffffe          BL       OS_CPU_SR_Save
0000a8  4681              MOV      r9,r0                 ;455
0000aa  481b              LDR      r0,|L5.280|
0000ac  6800              LDR      r0,[r0,#0]            ;456  ; OSTCBCur
0000ae  f8900031          LDRB     r0,[r0,#0x31]         ;456
0000b2  b120              CBZ      r0,|L5.190|
0000b4  2801              CMP      r0,#1                 ;456
0000b6  d00d              BEQ      |L5.212|
0000b8  2802              CMP      r0,#2                 ;456
0000ba  d10a              BNE      |L5.210|
0000bc  e005              B        |L5.202|
                  |L5.190|
0000be  4816              LDR      r0,|L5.280|
0000c0  6800              LDR      r0,[r0,#0]            ;458  ; OSTCBCur
0000c2  6a06              LDR      r6,[r0,#0x20]         ;458
0000c4  2000              MOVS     r0,#0                 ;459
0000c6  7028              STRB     r0,[r5,#0]            ;459
0000c8  e00d              B        |L5.230|
                  |L5.202|
0000ca  2600              MOVS     r6,#0                 ;463
0000cc  200e              MOVS     r0,#0xe               ;464
0000ce  7028              STRB     r0,[r5,#0]            ;464
0000d0  e009              B        |L5.230|
                  |L5.210|
0000d2  bf00              NOP                            ;467
                  |L5.212|
0000d4  4639              MOV      r1,r7                 ;469
0000d6  4810              LDR      r0,|L5.280|
0000d8  6800              LDR      r0,[r0,#0]            ;469  ; OSTCBCur
0000da  f7fffffe          BL       OS_EventTaskRemove
0000de  2600              MOVS     r6,#0                 ;470
0000e0  200a              MOVS     r0,#0xa               ;471
0000e2  7028              STRB     r0,[r5,#0]            ;471
0000e4  bf00              NOP                            ;472
                  |L5.230|
0000e6  bf00              NOP                            ;460
0000e8  2000              MOVS     r0,#0                 ;474
0000ea  490b              LDR      r1,|L5.280|
0000ec  6809              LDR      r1,[r1,#0]            ;474  ; OSTCBCur
0000ee  f8810030          STRB     r0,[r1,#0x30]         ;474
0000f2  4909              LDR      r1,|L5.280|
0000f4  6809              LDR      r1,[r1,#0]            ;475  ; OSTCBCur
0000f6  f8810031          STRB     r0,[r1,#0x31]         ;475
0000fa  4907              LDR      r1,|L5.280|
0000fc  6809              LDR      r1,[r1,#0]            ;476  ; OSTCBCur
0000fe  61c8              STR      r0,[r1,#0x1c]         ;476
000100  4905              LDR      r1,|L5.280|
000102  6809              LDR      r1,[r1,#0]            ;480  ; OSTCBCur
000104  6208              STR      r0,[r1,#0x20]         ;480
000106  4648              MOV      r0,r9                 ;481
000108  f7fffffe          BL       OS_CPU_SR_Restore
00010c  4630              MOV      r0,r6                 ;482
00010e  e784              B        |L5.26|
;;;484    /*$PAGE*/
                          ENDP

                  |L5.272|
                          DCD      OSIntNesting
                  |L5.276|
                          DCD      OSLockNesting
                  |L5.280|
                          DCD      OSTCBCur

                          AREA ||i.OSQPendAbort||, CODE, READONLY, ALIGN=1

                  OSQPendAbort PROC
;;;517    #if OS_Q_PEND_ABORT_EN > 0u
;;;518    INT8U  OSQPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;519                         INT8U      opt,
;;;520                         INT8U     *perr)
;;;521    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;522        INT8U      nbr_tasks;
;;;523    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;524        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;525    #endif
;;;526    
;;;527    
;;;528    
;;;529    #ifdef OS_SAFETY_CRITICAL
;;;530        if (perr == (INT8U *)0) {
;;;531            OS_SAFETY_CRITICAL_EXCEPTION();
;;;532        }
;;;533    #endif
;;;534    
;;;535    #if OS_ARG_CHK_EN > 0u
;;;536        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;537            *perr = OS_ERR_PEVENT_NULL;
;;;538            return (0u);
;;;539        }
;;;540    #endif
;;;541        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2802              CMP      r0,#2
000012  d004              BEQ      |L6.30|
;;;542            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;543            return (0u);
000018  2000              MOVS     r0,#0
                  |L6.26|
;;;544        }
;;;545        OS_ENTER_CRITICAL();
;;;546        if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
;;;547            nbr_tasks = 0u;
;;;548            switch (opt) {
;;;549                case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
;;;550                     while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
;;;551                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
;;;552                         nbr_tasks++;
;;;553                     }
;;;554                     break;
;;;555    
;;;556                case OS_PEND_OPT_NONE:
;;;557                default:                                       /* No,  ready HPT       waiting on queue    */
;;;558                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
;;;559                     nbr_tasks++;
;;;560                     break;
;;;561            }
;;;562            OS_EXIT_CRITICAL();
;;;563            OS_Sched();                                        /* Find HPT ready to run                    */
;;;564            *perr = OS_ERR_PEND_ABORT;
;;;565            return (nbr_tasks);
;;;566        }
;;;567        OS_EXIT_CRITICAL();
;;;568        *perr = OS_ERR_NONE;
;;;569        return (0u);                                           /* No tasks waiting on queue                */
;;;570    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;545
000024  7aa0              LDRB     r0,[r4,#0xa]          ;546
000026  b320              CBZ      r0,|L6.114|
000028  2600              MOVS     r6,#0                 ;547
00002a  b17f              CBZ      r7,|L6.76|
00002c  2f01              CMP      r7,#1                 ;548
00002e  d10c              BNE      |L6.74|
000030  e007              B        |L6.66|
                  |L6.50|
000032  2302              MOVS     r3,#2                 ;551
000034  2204              MOVS     r2,#4                 ;551
000036  2100              MOVS     r1,#0                 ;551
000038  4620              MOV      r0,r4                 ;551
00003a  f7fffffe          BL       OS_EventTaskRdy
00003e  1c70              ADDS     r0,r6,#1              ;552
000040  b2c6              UXTB     r6,r0                 ;552
                  |L6.66|
000042  7aa0              LDRB     r0,[r4,#0xa]          ;550
000044  2800              CMP      r0,#0                 ;550
000046  d1f4              BNE      |L6.50|
000048  e009              B        |L6.94|
                  |L6.74|
00004a  bf00              NOP                            ;556
                  |L6.76|
00004c  2302              MOVS     r3,#2                 ;558
00004e  2204              MOVS     r2,#4                 ;558
000050  2100              MOVS     r1,#0                 ;558
000052  4620              MOV      r0,r4                 ;558
000054  f7fffffe          BL       OS_EventTaskRdy
000058  1c70              ADDS     r0,r6,#1              ;559
00005a  b2c6              UXTB     r6,r0                 ;559
00005c  bf00              NOP                            ;560
                  |L6.94|
00005e  bf00              NOP                            ;554
000060  4640              MOV      r0,r8                 ;562
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  f7fffffe          BL       OS_Sched
00006a  200e              MOVS     r0,#0xe               ;564
00006c  7028              STRB     r0,[r5,#0]            ;564
00006e  4630              MOV      r0,r6                 ;565
000070  e7d3              B        |L6.26|
                  |L6.114|
000072  4640              MOV      r0,r8                 ;567
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;568
00007a  7028              STRB     r0,[r5,#0]            ;568
00007c  bf00              NOP                            ;569
00007e  e7cc              B        |L6.26|
;;;571    #endif
                          ENDP


                          AREA ||i.OSQPost||, CODE, READONLY, ALIGN=1

                  OSQPost PROC
;;;593    #if OS_Q_POST_EN > 0u
;;;594    INT8U  OSQPost (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;595                    void      *pmsg)
;;;596    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;597        OS_Q      *pq;
;;;598    #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;599        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;600    #endif
;;;601    
;;;602    
;;;603    
;;;604    #if OS_ARG_CHK_EN > 0u
;;;605        if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
;;;606            return (OS_ERR_PEVENT_NULL);
;;;607        }
;;;608    #endif
;;;609        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00000a  7828              LDRB     r0,[r5,#0]
00000c  2802              CMP      r0,#2
00000e  d002              BEQ      |L7.22|
;;;610            return (OS_ERR_EVENT_TYPE);
000010  2001              MOVS     r0,#1
                  |L7.18|
;;;611        }
;;;612        OS_ENTER_CRITICAL();
;;;613        if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
;;;614                                                           /* Ready highest priority task waiting on event */
;;;615            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;616            OS_EXIT_CRITICAL();
;;;617            OS_Sched();                                    /* Find highest priority task ready to run      */
;;;618            return (OS_ERR_NONE);
;;;619        }
;;;620        pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
;;;621        if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
;;;622            OS_EXIT_CRITICAL();
;;;623            return (OS_ERR_Q_FULL);
;;;624        }
;;;625        *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
;;;626        pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
;;;627        if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
;;;628            pq->OSQIn = pq->OSQStart;
;;;629        }
;;;630        OS_EXIT_CRITICAL();
;;;631        return (OS_ERR_NONE);
;;;632    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L7.22|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4607              MOV      r7,r0                 ;612
00001c  7aa8              LDRB     r0,[r5,#0xa]          ;613
00001e  b160              CBZ      r0,|L7.58|
000020  2300              MOVS     r3,#0                 ;615
000022  2204              MOVS     r2,#4                 ;615
000024  4631              MOV      r1,r6                 ;615
000026  4628              MOV      r0,r5                 ;615
000028  f7fffffe          BL       OS_EventTaskRdy
00002c  4638              MOV      r0,r7                 ;616
00002e  f7fffffe          BL       OS_CPU_SR_Restore
000032  f7fffffe          BL       OS_Sched
000036  2000              MOVS     r0,#0                 ;618
000038  e7eb              B        |L7.18|
                  |L7.58|
00003a  686c              LDR      r4,[r5,#4]            ;620
00003c  8ae0              LDRH     r0,[r4,#0x16]         ;621
00003e  8aa1              LDRH     r1,[r4,#0x14]         ;621
000040  4288              CMP      r0,r1                 ;621
000042  db04              BLT      |L7.78|
000044  4638              MOV      r0,r7                 ;622
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  201e              MOVS     r0,#0x1e              ;623
00004c  e7e1              B        |L7.18|
                  |L7.78|
00004e  68e1              LDR      r1,[r4,#0xc]          ;625
000050  1d08              ADDS     r0,r1,#4              ;625
000052  60e0              STR      r0,[r4,#0xc]          ;625
000054  600e              STR      r6,[r1,#0]            ;625
000056  8ae0              LDRH     r0,[r4,#0x16]         ;626
000058  1c40              ADDS     r0,r0,#1              ;626
00005a  82e0              STRH     r0,[r4,#0x16]         ;626
00005c  e9d41002          LDRD     r1,r0,[r4,#8]         ;627
000060  4288              CMP      r0,r1                 ;627
000062  d101              BNE      |L7.104|
000064  6860              LDR      r0,[r4,#4]            ;628
000066  60e0              STR      r0,[r4,#0xc]          ;628
                  |L7.104|
000068  4638              MOV      r0,r7                 ;630
00006a  f7fffffe          BL       OS_CPU_SR_Restore
00006e  2000              MOVS     r0,#0                 ;631
000070  e7cf              B        |L7.18|
;;;633    #endif
                          ENDP


                          AREA ||i.OSQPostFront||, CODE, READONLY, ALIGN=1

                  OSQPostFront PROC
;;;656    #if OS_Q_POST_FRONT_EN > 0u
;;;657    INT8U  OSQPostFront (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;658                         void      *pmsg)
;;;659    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;660        OS_Q      *pq;
;;;661    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;662        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;663    #endif
;;;664    
;;;665    
;;;666    
;;;667    #if OS_ARG_CHK_EN > 0u
;;;668        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;669            return (OS_ERR_PEVENT_NULL);
;;;670        }
;;;671    #endif
;;;672        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00000a  7828              LDRB     r0,[r5,#0]
00000c  2802              CMP      r0,#2
00000e  d002              BEQ      |L8.22|
;;;673            return (OS_ERR_EVENT_TYPE);
000010  2001              MOVS     r0,#1
                  |L8.18|
;;;674        }
;;;675        OS_ENTER_CRITICAL();
;;;676        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
;;;677                                                          /* Ready highest priority task waiting on event  */
;;;678            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;679            OS_EXIT_CRITICAL();
;;;680            OS_Sched();                                   /* Find highest priority task ready to run       */
;;;681            return (OS_ERR_NONE);
;;;682        }
;;;683        pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
;;;684        if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
;;;685            OS_EXIT_CRITICAL();
;;;686            return (OS_ERR_Q_FULL);
;;;687        }
;;;688        if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
;;;689            pq->OSQOut = pq->OSQEnd;
;;;690        }
;;;691        pq->OSQOut--;
;;;692        *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
;;;693        pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
;;;694        OS_EXIT_CRITICAL();
;;;695        return (OS_ERR_NONE);
;;;696    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L8.22|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4607              MOV      r7,r0                 ;675
00001c  7aa8              LDRB     r0,[r5,#0xa]          ;676
00001e  b160              CBZ      r0,|L8.58|
000020  2300              MOVS     r3,#0                 ;678
000022  2204              MOVS     r2,#4                 ;678
000024  4631              MOV      r1,r6                 ;678
000026  4628              MOV      r0,r5                 ;678
000028  f7fffffe          BL       OS_EventTaskRdy
00002c  4638              MOV      r0,r7                 ;679
00002e  f7fffffe          BL       OS_CPU_SR_Restore
000032  f7fffffe          BL       OS_Sched
000036  2000              MOVS     r0,#0                 ;681
000038  e7eb              B        |L8.18|
                  |L8.58|
00003a  686c              LDR      r4,[r5,#4]            ;683
00003c  8ae0              LDRH     r0,[r4,#0x16]         ;684
00003e  8aa1              LDRH     r1,[r4,#0x14]         ;684
000040  4288              CMP      r0,r1                 ;684
000042  db04              BLT      |L8.78|
000044  4638              MOV      r0,r7                 ;685
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  201e              MOVS     r0,#0x1e              ;686
00004c  e7e1              B        |L8.18|
                  |L8.78|
00004e  6861              LDR      r1,[r4,#4]            ;688
000050  6920              LDR      r0,[r4,#0x10]         ;688
000052  4288              CMP      r0,r1                 ;688
000054  d101              BNE      |L8.90|
000056  68a0              LDR      r0,[r4,#8]            ;689
000058  6120              STR      r0,[r4,#0x10]         ;689
                  |L8.90|
00005a  6920              LDR      r0,[r4,#0x10]         ;691
00005c  1f00              SUBS     r0,r0,#4              ;691
00005e  6120              STR      r0,[r4,#0x10]         ;691
000060  6920              LDR      r0,[r4,#0x10]         ;692
000062  6006              STR      r6,[r0,#0]            ;692
000064  8ae0              LDRH     r0,[r4,#0x16]         ;693
000066  1c40              ADDS     r0,r0,#1              ;693
000068  82e0              STRH     r0,[r4,#0x16]         ;693
00006a  4638              MOV      r0,r7                 ;694
00006c  f7fffffe          BL       OS_CPU_SR_Restore
000070  2000              MOVS     r0,#0                 ;695
000072  e7ce              B        |L8.18|
;;;697    #endif
                          ENDP


                          AREA ||i.OSQPostOpt||, CODE, READONLY, ALIGN=1

                  OSQPostOpt PROC
;;;728    #if OS_Q_POST_OPT_EN > 0u
;;;729    INT8U  OSQPostOpt (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;730                       void      *pmsg,
;;;731                       INT8U      opt)
;;;732    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;733        OS_Q      *pq;
;;;734    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;735        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;736    #endif
;;;737    
;;;738    
;;;739    
;;;740    #if OS_ARG_CHK_EN > 0u
;;;741        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;742            return (OS_ERR_PEVENT_NULL);
;;;743        }
;;;744    #endif
;;;745        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00000e  7828              LDRB     r0,[r5,#0]
000010  2802              CMP      r0,#2
000012  d002              BEQ      |L9.26|
;;;746            return (OS_ERR_EVENT_TYPE);
000014  2001              MOVS     r0,#1
                  |L9.22|
;;;747        }
;;;748        OS_ENTER_CRITICAL();
;;;749        if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
;;;750            if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
;;;751                while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
;;;752                    (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;753                }
;;;754            } else {                                      /* No,  Post to HPT waiting on queue             */
;;;755                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;756            }
;;;757            OS_EXIT_CRITICAL();
;;;758            if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {	  /* See if scheduler needs to be invoked          */
;;;759                OS_Sched();                               /* Find highest priority task ready to run       */
;;;760            }
;;;761            return (OS_ERR_NONE);
;;;762        }
;;;763        pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
;;;764        if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
;;;765            OS_EXIT_CRITICAL();
;;;766            return (OS_ERR_Q_FULL);
;;;767        }
;;;768        if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
;;;769            if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
;;;770                pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
;;;771            }
;;;772            pq->OSQOut--;
;;;773            *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
;;;774        } else {                                          /* No,  Post as FIFO                             */
;;;775            *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
;;;776            if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
;;;777                pq->OSQIn = pq->OSQStart;
;;;778            }
;;;779        }
;;;780        pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
;;;781        OS_EXIT_CRITICAL();
;;;782        return (OS_ERR_NONE);
;;;783    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L9.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4680              MOV      r8,r0                 ;748
000020  7aa8              LDRB     r0,[r5,#0xa]          ;749
000022  b1e8              CBZ      r0,|L9.96|
000024  f0060001          AND      r0,r6,#1              ;750
000028  b150              CBZ      r0,|L9.64|
00002a  e005              B        |L9.56|
                  |L9.44|
00002c  2300              MOVS     r3,#0                 ;752
00002e  2204              MOVS     r2,#4                 ;752
000030  4639              MOV      r1,r7                 ;752
000032  4628              MOV      r0,r5                 ;752
000034  f7fffffe          BL       OS_EventTaskRdy
                  |L9.56|
000038  7aa8              LDRB     r0,[r5,#0xa]          ;751
00003a  2800              CMP      r0,#0                 ;751
00003c  d1f6              BNE      |L9.44|
00003e  e005              B        |L9.76|
                  |L9.64|
000040  2300              MOVS     r3,#0                 ;755
000042  2204              MOVS     r2,#4                 ;755
000044  4639              MOV      r1,r7                 ;755
000046  4628              MOV      r0,r5                 ;755
000048  f7fffffe          BL       OS_EventTaskRdy
                  |L9.76|
00004c  4640              MOV      r0,r8                 ;757
00004e  f7fffffe          BL       OS_CPU_SR_Restore
000052  f0060004          AND      r0,r6,#4              ;758
000056  b908              CBNZ     r0,|L9.92|
000058  f7fffffe          BL       OS_Sched
                  |L9.92|
00005c  2000              MOVS     r0,#0                 ;761
00005e  e7da              B        |L9.22|
                  |L9.96|
000060  686c              LDR      r4,[r5,#4]            ;763
000062  8ae0              LDRH     r0,[r4,#0x16]         ;764
000064  8aa1              LDRH     r1,[r4,#0x14]         ;764
000066  4288              CMP      r0,r1                 ;764
000068  db04              BLT      |L9.116|
00006a  4640              MOV      r0,r8                 ;765
00006c  f7fffffe          BL       OS_CPU_SR_Restore
000070  201e              MOVS     r0,#0x1e              ;766
000072  e7d0              B        |L9.22|
                  |L9.116|
000074  f0060002          AND      r0,r6,#2              ;768
000078  b158              CBZ      r0,|L9.146|
00007a  6861              LDR      r1,[r4,#4]            ;769
00007c  6920              LDR      r0,[r4,#0x10]         ;769
00007e  4288              CMP      r0,r1                 ;769
000080  d101              BNE      |L9.134|
000082  68a0              LDR      r0,[r4,#8]            ;770
000084  6120              STR      r0,[r4,#0x10]         ;770
                  |L9.134|
000086  6920              LDR      r0,[r4,#0x10]         ;772
000088  1f00              SUBS     r0,r0,#4              ;772
00008a  6120              STR      r0,[r4,#0x10]         ;772
00008c  6920              LDR      r0,[r4,#0x10]         ;773
00008e  6007              STR      r7,[r0,#0]            ;773
000090  e009              B        |L9.166|
                  |L9.146|
000092  68e1              LDR      r1,[r4,#0xc]          ;775
000094  1d08              ADDS     r0,r1,#4              ;775
000096  60e0              STR      r0,[r4,#0xc]          ;775
000098  600f              STR      r7,[r1,#0]            ;775
00009a  e9d41002          LDRD     r1,r0,[r4,#8]         ;776
00009e  4288              CMP      r0,r1                 ;776
0000a0  d101              BNE      |L9.166|
0000a2  6860              LDR      r0,[r4,#4]            ;777
0000a4  60e0              STR      r0,[r4,#0xc]          ;777
                  |L9.166|
0000a6  8ae0              LDRH     r0,[r4,#0x16]         ;780
0000a8  1c40              ADDS     r0,r0,#1              ;780
0000aa  82e0              STRH     r0,[r4,#0x16]         ;780
0000ac  4640              MOV      r0,r8                 ;781
0000ae  f7fffffe          BL       OS_CPU_SR_Restore
0000b2  2000              MOVS     r0,#0                 ;782
0000b4  e7af              B        |L9.22|
;;;784    #endif
                          ENDP


                          AREA ||i.OSQQuery||, CODE, READONLY, ALIGN=1

                  OSQQuery PROC
;;;804    #if OS_Q_QUERY_EN > 0u
;;;805    INT8U  OSQQuery (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;806                     OS_Q_DATA *p_q_data)
;;;807    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;808        OS_Q       *pq;
;;;809        INT8U       i;
;;;810        OS_PRIO    *psrc;
;;;811        OS_PRIO    *pdest;
;;;812    #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;813        OS_CPU_SR   cpu_sr = 0u;
000008  f04f0a00          MOV      r10,#0
;;;814    #endif
;;;815    
;;;816    
;;;817    
;;;818    #if OS_ARG_CHK_EN > 0u
;;;819        if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
;;;820            return (OS_ERR_PEVENT_NULL);
;;;821        }
;;;822        if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
;;;823            return (OS_ERR_PDATA_NULL);
;;;824        }
;;;825    #endif
;;;826        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2802              CMP      r0,#2
000010  d002              BEQ      |L10.24|
;;;827            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L10.20|
;;;828        }
;;;829        OS_ENTER_CRITICAL();
;;;830        p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
;;;831        psrc                 = &pevent->OSEventTbl[0];
;;;832        pdest                = &p_q_data->OSEventTbl[0];
;;;833        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;834            *pdest++ = *psrc++;
;;;835        }
;;;836        pq = (OS_Q *)pevent->OSEventPtr;
;;;837        if (pq->OSQEntries > 0u) {
;;;838            p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
;;;839        } else {
;;;840            p_q_data->OSMsg = (void *)0;
;;;841        }
;;;842        p_q_data->OSNMsgs = pq->OSQEntries;
;;;843        p_q_data->OSQSize = pq->OSQSize;
;;;844        OS_EXIT_CRITICAL();
;;;845        return (OS_ERR_NONE);
;;;846    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L10.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4682              MOV      r10,r0                ;829
00001e  7aa8              LDRB     r0,[r5,#0xa]          ;830
000020  7420              STRB     r0,[r4,#0x10]         ;830
000022  f105080b          ADD      r8,r5,#0xb            ;831
000026  f1040908          ADD      r9,r4,#8              ;832
00002a  2700              MOVS     r7,#0                 ;833
00002c  e005              B        |L10.58|
                  |L10.46|
00002e  f8180b01          LDRB     r0,[r8],#1            ;834
000032  f8090b01          STRB     r0,[r9],#1            ;834
000036  1c78              ADDS     r0,r7,#1              ;833
000038  b2c7              UXTB     r7,r0                 ;833
                  |L10.58|
00003a  2f08              CMP      r7,#8                 ;833
00003c  d3f7              BCC      |L10.46|
00003e  686e              LDR      r6,[r5,#4]            ;836
000040  8af0              LDRH     r0,[r6,#0x16]         ;837
000042  b118              CBZ      r0,|L10.76|
000044  6930              LDR      r0,[r6,#0x10]         ;838
000046  6800              LDR      r0,[r0,#0]            ;838
000048  6020              STR      r0,[r4,#0]            ;838
00004a  e001              B        |L10.80|
                  |L10.76|
00004c  2000              MOVS     r0,#0                 ;840
00004e  6020              STR      r0,[r4,#0]            ;840
                  |L10.80|
000050  8af0              LDRH     r0,[r6,#0x16]         ;842
000052  80a0              STRH     r0,[r4,#4]            ;842
000054  8ab0              LDRH     r0,[r6,#0x14]         ;843
000056  80e0              STRH     r0,[r4,#6]            ;843
000058  4650              MOV      r0,r10                ;844
00005a  f7fffffe          BL       OS_CPU_SR_Restore
00005e  2000              MOVS     r0,#0                 ;845
000060  e7d8              B        |L10.20|
;;;847    #endif                                                 /* OS_Q_QUERY_EN                                */
                          ENDP


                          AREA ||i.OS_QInit||, CODE, READONLY, ALIGN=2

                  OS_QInit PROC
;;;864    
;;;865    void  OS_QInit (void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;866    {
;;;867    #if OS_MAX_QS == 1u
;;;868        OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
;;;869        OSQFreeList->OSQPtr = (OS_Q *)0;
;;;870    #endif
;;;871    
;;;872    #if OS_MAX_QS >= 2u
;;;873        INT16U   ix;
;;;874        INT16U   ix_next;
;;;875        OS_Q    *pq1;
;;;876        OS_Q    *pq2;
;;;877    
;;;878    
;;;879    
;;;880        OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
000004  2178              MOVS     r1,#0x78
000006  4810              LDR      r0,|L11.72|
000008  f7fffffe          BL       OS_MemClr
;;;881        for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
00000c  2400              MOVS     r4,#0
00000e  e00d              B        |L11.44|
                  |L11.16|
;;;882            ix_next = ix + 1u;
000010  1c60              ADDS     r0,r4,#1
000012  b286              UXTH     r6,r0
;;;883            pq1 = &OSQTbl[ix];
000014  eb040044          ADD      r0,r4,r4,LSL #1
000018  490b              LDR      r1,|L11.72|
00001a  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;884            pq2 = &OSQTbl[ix_next];
00001e  eb060046          ADD      r0,r6,r6,LSL #1
000022  eb0107c0          ADD      r7,r1,r0,LSL #3
;;;885            pq1->OSQPtr = pq2;
000026  602f              STR      r7,[r5,#0]
000028  1c60              ADDS     r0,r4,#1              ;881
00002a  b284              UXTH     r4,r0                 ;881
                  |L11.44|
00002c  2c04              CMP      r4,#4                 ;881
00002e  d3ef              BCC      |L11.16|
;;;886        }
;;;887        pq1         = &OSQTbl[ix];
000030  eb040044          ADD      r0,r4,r4,LSL #1
000034  4904              LDR      r1,|L11.72|
000036  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;888        pq1->OSQPtr = (OS_Q *)0;
00003a  2000              MOVS     r0,#0
00003c  6028              STR      r0,[r5,#0]
;;;889        OSQFreeList = &OSQTbl[0];
00003e  4608              MOV      r0,r1
000040  4902              LDR      r1,|L11.76|
000042  6008              STR      r0,[r1,#0]  ; OSQFreeList
;;;890    #endif
;;;891    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;892    #endif                                               /* OS_Q_EN                                        */
                          ENDP

                  |L11.72|
                          DCD      OSQTbl
                  |L11.76|
                          DCD      OSQFreeList
