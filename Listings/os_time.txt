; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\os_time.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_time.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\os_time.crf UCOSII\CORE\os_time.c]
                          THUMB

                          AREA ||i.OSTimeDly||, CODE, READONLY, ALIGN=2

                  OSTimeDly PROC
;;;43     
;;;44     void  OSTimeDly (INT32U ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;45     {
000002  4605              MOV      r5,r0
;;;46         INT8U      y;
;;;47     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;48         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;49     #endif
;;;50     
;;;51     
;;;52     
;;;53         if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000006  4817              LDR      r0,|L1.100|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  b100              CBZ      r0,|L1.14|
                  |L1.12|
;;;54             return;
;;;55         }
;;;56         if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
;;;57             return;
;;;58         }
;;;59         if (ticks > 0u) {                            /* 0 means no delay!                                  */
;;;60             OS_ENTER_CRITICAL();
;;;61             y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
;;;62             OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
;;;63             if (OSRdyTbl[y] == 0u) {
;;;64                 OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
;;;65             }
;;;66             OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
;;;67             OS_EXIT_CRITICAL();
;;;68             OS_Sched();                              /* Find next task to run!                             */
;;;69         }
;;;70     }
00000c  bd70              POP      {r4-r6,pc}
                  |L1.14|
00000e  4816              LDR      r0,|L1.104|
000010  7800              LDRB     r0,[r0,#0]            ;56  ; OSLockNesting
000012  b100              CBZ      r0,|L1.22|
000014  e7fa              B        |L1.12|
                  |L1.22|
000016  b31d              CBZ      r5,|L1.96|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4606              MOV      r6,r0                 ;60
00001e  4813              LDR      r0,|L1.108|
000020  6800              LDR      r0,[r0,#0]            ;61  ; OSTCBCur
000022  f8904034          LDRB     r4,[r0,#0x34]         ;61
000026  4812              LDR      r0,|L1.112|
000028  5d00              LDRB     r0,[r0,r4]            ;62
00002a  4910              LDR      r1,|L1.108|
00002c  6809              LDR      r1,[r1,#0]            ;62  ; OSTCBCur
00002e  f8911035          LDRB     r1,[r1,#0x35]         ;62
000032  4388              BICS     r0,r0,r1              ;62
000034  490e              LDR      r1,|L1.112|
000036  5508              STRB     r0,[r1,r4]            ;62
000038  4608              MOV      r0,r1                 ;63
00003a  5d00              LDRB     r0,[r0,r4]            ;63
00003c  b940              CBNZ     r0,|L1.80|
00003e  480b              LDR      r0,|L1.108|
000040  6800              LDR      r0,[r0,#0]            ;64  ; OSTCBCur
000042  f8901036          LDRB     r1,[r0,#0x36]         ;64
000046  480b              LDR      r0,|L1.116|
000048  7800              LDRB     r0,[r0,#0]            ;64  ; OSRdyGrp
00004a  4388              BICS     r0,r0,r1              ;64
00004c  4909              LDR      r1,|L1.116|
00004e  7008              STRB     r0,[r1,#0]            ;64
                  |L1.80|
000050  4806              LDR      r0,|L1.108|
000052  6800              LDR      r0,[r0,#0]            ;66  ; OSTCBCur
000054  62c5              STR      r5,[r0,#0x2c]         ;66
000056  4630              MOV      r0,r6                 ;67
000058  f7fffffe          BL       OS_CPU_SR_Restore
00005c  f7fffffe          BL       OS_Sched
                  |L1.96|
000060  bf00              NOP      
000062  e7d3              B        |L1.12|
;;;71     /*$PAGE*/
                          ENDP

                  |L1.100|
                          DCD      OSIntNesting
                  |L1.104|
                          DCD      OSLockNesting
                  |L1.108|
                          DCD      OSTCBCur
                  |L1.112|
                          DCD      OSRdyTbl
                  |L1.116|
                          DCD      OSRdyGrp

                          AREA ||i.OSTimeDlyHMSM||, CODE, READONLY, ALIGN=2

                  OSTimeDlyHMSM PROC
;;;98     #if OS_TIME_DLY_HMSM_EN > 0u
;;;99     INT8U  OSTimeDlyHMSM (INT8U   hours,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;100                          INT8U   minutes,
;;;101                          INT8U   seconds,
;;;102                          INT16U  ms)
;;;103    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;104        INT32U ticks;
;;;105    
;;;106    
;;;107        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4812              LDR      r0,|L2.88|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b110              CBZ      r0,|L2.24|
;;;108            return (OS_ERR_TIME_DLY_ISR);
000012  2055              MOVS     r0,#0x55
                  |L2.20|
;;;109        }
;;;110        if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
;;;111            return (OS_ERR_SCHED_LOCKED);
;;;112        }
;;;113    #if OS_ARG_CHK_EN > 0u
;;;114        if (hours == 0u) {
;;;115            if (minutes == 0u) {
;;;116                if (seconds == 0u) {
;;;117                    if (ms == 0u) {
;;;118                        return (OS_ERR_TIME_ZERO_DLY);
;;;119                    }
;;;120                }
;;;121            }
;;;122        }
;;;123        if (minutes > 59u) {
;;;124            return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
;;;125        }
;;;126        if (seconds > 59u) {
;;;127            return (OS_ERR_TIME_INVALID_SECONDS);
;;;128        }
;;;129        if (ms > 999u) {
;;;130            return (OS_ERR_TIME_INVALID_MS);
;;;131        }
;;;132    #endif
;;;133                                                     /* Compute the total number of clock ticks required.. */
;;;134                                                     /* .. (rounded to the nearest tick)                   */
;;;135        ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
;;;136              + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
;;;137        OSTimeDly(ticks);
;;;138        return (OS_ERR_NONE);
;;;139    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L2.24|
000018  4810              LDR      r0,|L2.92|
00001a  7800              LDRB     r0,[r0,#0]            ;110  ; OSLockNesting
00001c  b108              CBZ      r0,|L2.34|
00001e  2032              MOVS     r0,#0x32              ;111
000020  e7f8              B        |L2.20|
                  |L2.34|
000022  1cb8              ADDS     r0,r7,#2              ;135
000024  21c8              MOVS     r1,#0xc8              ;135
000026  4348              MULS     r0,r1,r0              ;135
000028  f44f717a          MOV      r1,#0x3e8             ;135
00002c  fbb0f1f1          UDIV     r1,r0,r1              ;135
000030  f44f6061          MOV      r0,#0xe10             ;135
000034  4360              MULS     r0,r4,r0              ;135
000036  ebc51205          RSB      r2,r5,r5,LSL #4       ;135
00003a  eb000082          ADD      r0,r0,r2,LSL #2       ;135
00003e  4430              ADD      r0,r0,r6              ;135
000040  eb0002c0          ADD      r2,r0,r0,LSL #3       ;135
000044  eb021000          ADD      r0,r2,r0,LSL #4       ;135
000048  eb0108c0          ADD      r8,r1,r0,LSL #3       ;135
00004c  4640              MOV      r0,r8                 ;137
00004e  f7fffffe          BL       OSTimeDly
000052  2000              MOVS     r0,#0                 ;138
000054  e7de              B        |L2.20|
;;;140    #endif
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      OSIntNesting
                  |L2.92|
                          DCD      OSLockNesting

                          AREA ||i.OSTimeDlyResume||, CODE, READONLY, ALIGN=2

                  OSTimeDlyResume PROC
;;;161    #if OS_TIME_DLY_RESUME_EN > 0u
;;;162    INT8U  OSTimeDlyResume (INT8U prio)
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
000002  4605              MOV      r5,r0
;;;164        OS_TCB    *ptcb;
;;;165    #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
;;;166        OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;167    #endif
;;;168    
;;;169    
;;;170    
;;;171        if (prio >= OS_LOWEST_PRIO) {
000006  2d3f              CMP      r5,#0x3f
000008  d301              BCC      |L3.14|
;;;172            return (OS_ERR_PRIO_INVALID);
00000a  202a              MOVS     r0,#0x2a
                  |L3.12|
;;;173        }
;;;174        OS_ENTER_CRITICAL();
;;;175        ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
;;;176        if (ptcb == (OS_TCB *)0) {
;;;177            OS_EXIT_CRITICAL();
;;;178            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;179        }
;;;180        if (ptcb == OS_TCB_RESERVED) {
;;;181            OS_EXIT_CRITICAL();
;;;182            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;183        }
;;;184        if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
;;;185            OS_EXIT_CRITICAL();
;;;186            return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
;;;187        }
;;;188    
;;;189        ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
;;;190        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;191            ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
;;;192            ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
;;;193        } else {
;;;194            ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
;;;195        }
;;;196        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
;;;197            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
;;;198            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;199            OS_EXIT_CRITICAL();
;;;200            OS_Sched();                                            /* See if this is new highest priority  */
;;;201        } else {
;;;202            OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
;;;203        }
;;;204        return (OS_ERR_NONE);
;;;205    }
00000c  bd70              POP      {r4-r6,pc}
                  |L3.14|
00000e  f7fffffe          BL       OS_CPU_SR_Save
000012  4606              MOV      r6,r0                 ;174
000014  4824              LDR      r0,|L3.168|
000016  f8504025          LDR      r4,[r0,r5,LSL #2]     ;175
00001a  b924              CBNZ     r4,|L3.38|
00001c  4630              MOV      r0,r6                 ;177
00001e  f7fffffe          BL       OS_CPU_SR_Restore
000022  2043              MOVS     r0,#0x43              ;178
000024  e7f2              B        |L3.12|
                  |L3.38|
000026  2c01              CMP      r4,#1                 ;180
000028  d104              BNE      |L3.52|
00002a  4630              MOV      r0,r6                 ;181
00002c  f7fffffe          BL       OS_CPU_SR_Restore
000030  2043              MOVS     r0,#0x43              ;182
000032  e7eb              B        |L3.12|
                  |L3.52|
000034  6ae0              LDR      r0,[r4,#0x2c]         ;184
000036  b920              CBNZ     r0,|L3.66|
000038  4630              MOV      r0,r6                 ;185
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  2050              MOVS     r0,#0x50              ;186
000040  e7e4              B        |L3.12|
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;189
000044  62e0              STR      r0,[r4,#0x2c]         ;189
000046  f8940030          LDRB     r0,[r4,#0x30]         ;190
00004a  f0000037          AND      r0,r0,#0x37           ;190
00004e  b140              CBZ      r0,|L3.98|
000050  f8140f30          LDRB     r0,[r4,#0x30]!        ;191
000054  f0200037          BIC      r0,r0,#0x37           ;191
000058  7020              STRB     r0,[r4,#0]            ;191
00005a  2001              MOVS     r0,#1                 ;192
00005c  7060              STRB     r0,[r4,#1]            ;192
00005e  3c30              SUBS     r4,r4,#0x30           ;192
000060  e002              B        |L3.104|
                  |L3.98|
000062  2000              MOVS     r0,#0                 ;194
000064  f8840031          STRB     r0,[r4,#0x31]         ;194
                  |L3.104|
000068  f8940030          LDRB     r0,[r4,#0x30]         ;196
00006c  f0000008          AND      r0,r0,#8              ;196
000070  b9a8              CBNZ     r0,|L3.158|
000072  3434              ADDS     r4,r4,#0x34           ;197
000074  78a0              LDRB     r0,[r4,#2]            ;197
000076  490d              LDR      r1,|L3.172|
000078  7809              LDRB     r1,[r1,#0]            ;197  ; OSRdyGrp
00007a  4308              ORRS     r0,r0,r1              ;197
00007c  490b              LDR      r1,|L3.172|
00007e  7008              STRB     r0,[r1,#0]            ;197
000080  7820              LDRB     r0,[r4,#0]            ;198
000082  490b              LDR      r1,|L3.176|
000084  5c08              LDRB     r0,[r1,r0]            ;198
000086  7861              LDRB     r1,[r4,#1]            ;198
000088  4308              ORRS     r0,r0,r1              ;198
00008a  f8141934          LDRB     r1,[r4],#-0x34        ;198
00008e  4a08              LDR      r2,|L3.176|
000090  5450              STRB     r0,[r2,r1]            ;198
000092  4630              MOV      r0,r6                 ;199
000094  f7fffffe          BL       OS_CPU_SR_Restore
000098  f7fffffe          BL       OS_Sched
00009c  e002              B        |L3.164|
                  |L3.158|
00009e  4630              MOV      r0,r6                 ;202
0000a0  f7fffffe          BL       OS_CPU_SR_Restore
                  |L3.164|
0000a4  2000              MOVS     r0,#0                 ;204
0000a6  e7b1              B        |L3.12|
;;;206    #endif
                          ENDP

                  |L3.168|
                          DCD      OSTCBPrioTbl
                  |L3.172|
                          DCD      OSRdyGrp
                  |L3.176|
                          DCD      OSRdyTbl

                          AREA ||i.OSTimeGet||, CODE, READONLY, ALIGN=2

                  OSTimeGet PROC
;;;221    #if OS_TIME_GET_SET_EN > 0u
;;;222    INT32U  OSTimeGet (void)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
;;;224        INT32U     ticks;
;;;225    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;226        OS_CPU_SR  cpu_sr = 0u;
000002  2500              MOVS     r5,#0
;;;227    #endif
;;;228    
;;;229    
;;;230    
;;;231        OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4605              MOV      r5,r0
;;;232        ticks = OSTime;
00000a  4803              LDR      r0,|L4.24|
00000c  6804              LDR      r4,[r0,#0]  ; OSTime
;;;233        OS_EXIT_CRITICAL();
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       OS_CPU_SR_Restore
;;;234        return (ticks);
000014  4620              MOV      r0,r4
;;;235    }
000016  bd70              POP      {r4-r6,pc}
;;;236    #endif
                          ENDP

                  |L4.24|
                          DCD      OSTime

                          AREA ||i.OSTimeSet||, CODE, READONLY, ALIGN=2

                  OSTimeSet PROC
;;;250    #if OS_TIME_GET_SET_EN > 0u
;;;251    void  OSTimeSet (INT32U ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;252    {
000002  4604              MOV      r4,r0
;;;253    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;254        OS_CPU_SR  cpu_sr = 0u;
000004  2500              MOVS     r5,#0
;;;255    #endif
;;;256    
;;;257    
;;;258    
;;;259        OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4605              MOV      r5,r0
;;;260        OSTime = ticks;
00000c  4802              LDR      r0,|L5.24|
00000e  6004              STR      r4,[r0,#0]  ; OSTime
;;;261        OS_EXIT_CRITICAL();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;262    }
000016  bd70              POP      {r4-r6,pc}
;;;263    #endif
                          ENDP

                  |L5.24|
                          DCD      OSTime
