; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\ad_sample.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ad_sample.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\ad_sample.crf AD_Sample\AD_Sample.c]
                          THUMB

                          AREA ||i.AD1_DMA_Configuration||, CODE, READONLY, ALIGN=2

                  AD1_DMA_Configuration PROC
;;;160    
;;;161    void AD1_DMA_Configuration(void)
000000  b500              PUSH     {lr}
;;;162    {
000002  b08d              SUB      sp,sp,#0x34
;;;163    
;;;164    	DMA_InitTypeDef DMA_InitStructure;
;;;165    	NVIC_InitTypeDef NVIC_InitStructure;
;;;166    	
;;;167    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); //使能DMA传输
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;168    	DMA_DeInit(DMA1_Channel1); //将DMA的通道1寄存器重设为缺省值
00000c  4819              LDR      r0,|L1.116|
00000e  f7fffffe          BL       DMA_DeInit
;;;169    	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC1->DR; //DMA外设ADC基地址
000012  4819              LDR      r0,|L1.120|
000014  9002              STR      r0,[sp,#8]
;;;170    	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&AD_Value_0; //DMA内存基地址
000016  4819              LDR      r0,|L1.124|
000018  9003              STR      r0,[sp,#0xc]
;;;171    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; //内存作为数据传输的目的地
00001a  2000              MOVS     r0,#0
00001c  9004              STR      r0,[sp,#0x10]
;;;172    	DMA_InitStructure.DMA_BufferSize = SAMPLE_NUM * CHANEL_NUM; //DMA通道的DMA缓存的大小
00001e  2060              MOVS     r0,#0x60
000020  9005              STR      r0,[sp,#0x14]
;;;173    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; //外设地址寄存器不变
000022  2000              MOVS     r0,#0
000024  9006              STR      r0,[sp,#0x18]
;;;174    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; //内存地址寄存器递增
000026  2080              MOVS     r0,#0x80
000028  9007              STR      r0,[sp,#0x1c]
;;;175    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; //数据宽度为16位
00002a  0040              LSLS     r0,r0,#1
00002c  9008              STR      r0,[sp,#0x20]
;;;176    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; //数据宽度为16位
00002e  0080              LSLS     r0,r0,#2
000030  9009              STR      r0,[sp,#0x24]
;;;177    	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;// DMA_Mode_Normal; //工作在循环缓存模式
000032  2020              MOVS     r0,#0x20
000034  900a              STR      r0,[sp,#0x28]
;;;178    	DMA_InitStructure.DMA_Priority = DMA_Priority_High; //DMA通道 x拥有高优先级
000036  0200              LSLS     r0,r0,#8
000038  900b              STR      r0,[sp,#0x2c]
;;;179    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; //DMA通道x没有设置为内存到内存传输
00003a  2000              MOVS     r0,#0
00003c  900c              STR      r0,[sp,#0x30]
;;;180    	DMA_Init(DMA1_Channel1, &DMA_InitStructure); //根据DMA_InitStruct中指定的参数初始化DMA的通道
00003e  a902              ADD      r1,sp,#8
000040  480c              LDR      r0,|L1.116|
000042  f7fffffe          BL       DMA_Init
;;;181    	
;;;182    	DMA_ITConfig(DMA1_Channel1, DMA_IT_TC,ENABLE); //传输结束中断
000046  2201              MOVS     r2,#1
000048  2102              MOVS     r1,#2
00004a  480a              LDR      r0,|L1.116|
00004c  f7fffffe          BL       DMA_ITConfig
;;;183         
;;;184    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = DMA1_1_INT_PREEM;
000050  2001              MOVS     r0,#1
000052  f88d0005          STRB     r0,[sp,#5]
;;;185    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = DMA1_1_INT_SUB;
000056  2003              MOVS     r0,#3
000058  f88d0006          STRB     r0,[sp,#6]
;;;186    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00005c  2001              MOVS     r0,#1
00005e  f88d0007          STRB     r0,[sp,#7]
;;;187    
;;;188    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel1_IRQn;
000062  200b              MOVS     r0,#0xb
000064  f88d0004          STRB     r0,[sp,#4]
;;;189    	NVIC_Init(&NVIC_InitStructure);   
000068  a801              ADD      r0,sp,#4
00006a  f7fffffe          BL       NVIC_Init
;;;190    
;;;191    }
00006e  b00d              ADD      sp,sp,#0x34
000070  bd00              POP      {pc}
;;;192    int counter_process_state;
                          ENDP

000072  0000              DCW      0x0000
                  |L1.116|
                          DCD      0x40020008
                  |L1.120|
                          DCD      0x4001244c
                  |L1.124|
                          DCD      AD_Value_0

                          AREA ||i.ADC1_2_IRQHandler||, CODE, READONLY, ALIGN=2

                  ADC1_2_IRQHandler PROC
;;;132    //ADC中断服务函数
;;;133    void ADC1_2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;134    {              
;;;135    	if (ADC_GetITStatus(ADC1, ADC_IT_AWD) != RESET) 
000002  f44f71a0          MOV      r1,#0x140
000006  481e              LDR      r0,|L2.128|
000008  f7fffffe          BL       ADC_GetITStatus
00000c  b1a8              CBZ      r0,|L2.58|
;;;136    	{
;;;137    		//电眼故障时进这里
;;;138    		detect_chanel_index = CHANEL_NUM - (DMA_GetCurrDataCounter (DMA1_Channel1) % CHANEL_NUM);
00000e  481d              LDR      r0,|L2.132|
000010  f7fffffe          BL       DMA_GetCurrDataCounter
000014  210c              MOVS     r1,#0xc
000016  fb90f2f1          SDIV     r2,r0,r1
00001a  fb010012          MLS      r0,r1,r2,r0
00001e  f1c0000c          RSB      r0,r0,#0xc
000022  4919              LDR      r1,|L2.136|
000024  8008              STRH     r0,[r1,#0]
;;;139    		ADC_ClearFlag(ADC1, ADC_FLAG_AWD);
000026  2101              MOVS     r1,#1
000028  4815              LDR      r0,|L2.128|
00002a  f7fffffe          BL       ADC_ClearFlag
;;;140    		ADC_ClearITPendingBit(ADC1, ADC_IT_AWD); 
00002e  f44f71a0          MOV      r1,#0x140
000032  4813              LDR      r0,|L2.128|
000034  f7fffffe          BL       ADC_ClearITPendingBit
000038  e020              B        |L2.124|
                  |L2.58|
;;;141    	}
;;;142    	else
;;;143    	{
;;;144    		chanel_pos_index++; //采样处理下一个光敏二极管
00003a  4814              LDR      r0,|L2.140|
00003c  8800              LDRH     r0,[r0,#0]  ; chanel_pos_index
00003e  1c40              ADDS     r0,r0,#1
000040  4912              LDR      r1,|L2.140|
000042  8008              STRH     r0,[r1,#0]
;;;145    		if (chanel_pos_index < CHANEL_SENSOR_NUM){
000044  4608              MOV      r0,r1
000046  8800              LDRH     r0,[r0,#0]  ; chanel_pos_index
000048  2808              CMP      r0,#8
00004a  db01              BLT      |L2.80|
;;;146    		}
;;;147    		else{
;;;148    			chanel_pos_index = 0;
00004c  2000              MOVS     r0,#0
00004e  8008              STRH     r0,[r1,#0]
                  |L2.80|
;;;149    		}
;;;150    		ADC_sync_signal++;
000050  480f              LDR      r0,|L2.144|
000052  8800              LDRH     r0,[r0,#0]  ; ADC_sync_signal
000054  1c40              ADDS     r0,r0,#1
000056  490e              LDR      r1,|L2.144|
000058  8008              STRH     r0,[r1,#0]
;;;151    		if ( ADC_sync_signal < SAMPLE_NUM){
00005a  4608              MOV      r0,r1
00005c  8800              LDRH     r0,[r0,#0]  ; ADC_sync_signal
00005e  2808              CMP      r0,#8
000060  da04              BGE      |L2.108|
;;;152    			ADC_SoftwareStartConvCmd(ADC1, ENABLE);
000062  2101              MOVS     r1,#1
000064  4806              LDR      r0,|L2.128|
000066  f7fffffe          BL       ADC_SoftwareStartConvCmd
00006a  e002              B        |L2.114|
                  |L2.108|
;;;153    		}else{
;;;154    			chanel_pos_index = 0;
00006c  2000              MOVS     r0,#0
00006e  4907              LDR      r1,|L2.140|
000070  8008              STRH     r0,[r1,#0]
                  |L2.114|
;;;155    		}
;;;156    		ADC_ClearITPendingBit(ADC1, ADC_IT_EOC);      //清除ADCx的中断待处理位
000072  f44f7108          MOV      r1,#0x220
000076  4802              LDR      r0,|L2.128|
000078  f7fffffe          BL       ADC_ClearITPendingBit
                  |L2.124|
;;;157    	}
;;;158    }
00007c  bd10              POP      {r4,pc}
;;;159    
                          ENDP

00007e  0000              DCW      0x0000
                  |L2.128|
                          DCD      0x40012400
                  |L2.132|
                          DCD      0x40020008
                  |L2.136|
                          DCD      detect_chanel_index
                  |L2.140|
                          DCD      chanel_pos_index
                  |L2.144|
                          DCD      ADC_sync_signal

                          AREA ||i.ADC1_Configuration||, CODE, READONLY, ALIGN=2

                  ADC1_Configuration PROC
;;;60     
;;;61     void ADC1_Configuration(void)
000000  b500              PUSH     {lr}
;;;62     {
000002  b087              SUB      sp,sp,#0x1c
;;;63     	#define SAMPLE_TIME ADC_SampleTime_28Cycles5 //ADC_SampleTime_7Cycles5
;;;64     	ADC_InitTypeDef ADC_InitStructure;
;;;65     	NVIC_InitTypeDef NVIC_InitStructure;
;;;66     	
;;;67     	
;;;68     
;;;69     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE ); //使能ADC1通道时钟，各个管脚时钟
000004  2101              MOVS     r1,#1
000006  0248              LSLS     r0,r1,#9
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;70     
;;;71     	RCC_ADCCLKConfig(RCC_PCLK2_Div6); //72M/6=12,ADC最大时间不能超过14M
00000c  f44f4000          MOV      r0,#0x8000
000010  f7fffffe          BL       RCC_ADCCLKConfig
;;;72     
;;;73     	ADC_DeInit(ADC1); //将外设 ADC1 的全部寄存器重设为缺省值
000014  484f              LDR      r0,|L3.340|
000016  f7fffffe          BL       ADC_DeInit
;;;74     
;;;75     	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //ADC工作模式:ADC1和ADC2工作在独立模式
00001a  2000              MOVS     r0,#0
00001c  9002              STR      r0,[sp,#8]
;;;76     	ADC_InitStructure.ADC_ScanConvMode =ENABLE; //模数转换工作在扫描模式
00001e  2001              MOVS     r0,#1
000020  f88d000c          STRB     r0,[sp,#0xc]
;;;77     	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //模数转换工作在连续转换模式
000024  2000              MOVS     r0,#0
000026  f88d000d          STRB     r0,[sp,#0xd]
;;;78     	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //外部触发转换关闭
00002a  f44f2060          MOV      r0,#0xe0000
00002e  9004              STR      r0,[sp,#0x10]
;;;79     	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; //ADC数据右对齐
000030  2000              MOVS     r0,#0
000032  9005              STR      r0,[sp,#0x14]
;;;80     	ADC_InitStructure.ADC_NbrOfChannel = CHANEL_NUM; //顺序进行规则转换的ADC通道的数目
000034  200c              MOVS     r0,#0xc
000036  f88d0018          STRB     r0,[sp,#0x18]
;;;81     	ADC_Init(ADC1, &ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器
00003a  a902              ADD      r1,sp,#8
00003c  4845              LDR      r0,|L3.340|
00003e  f7fffffe          BL       ADC_Init
;;;82     
;;;83     
;;;84     	//设置指定ADC的规则组通道，设置它们的转化顺序和采样时间
;;;85     	//ADC1,ADC通道x,规则采样顺序值为y,采样时间为239.5周期
;;;86     	ADC_RegularChannelConfig(ADC1, CH0, 1, SAMPLE_TIME );
000042  2303              MOVS     r3,#3
000044  2201              MOVS     r2,#1
000046  2100              MOVS     r1,#0
000048  4842              LDR      r0,|L3.340|
00004a  f7fffffe          BL       ADC_RegularChannelConfig
;;;87     	ADC_RegularChannelConfig(ADC1, CH1, 2, SAMPLE_TIME );
00004e  2303              MOVS     r3,#3
000050  2202              MOVS     r2,#2
000052  2101              MOVS     r1,#1
000054  483f              LDR      r0,|L3.340|
000056  f7fffffe          BL       ADC_RegularChannelConfig
;;;88     	ADC_RegularChannelConfig(ADC1, CH2, 3, SAMPLE_TIME );
00005a  2303              MOVS     r3,#3
00005c  461a              MOV      r2,r3
00005e  2102              MOVS     r1,#2
000060  483c              LDR      r0,|L3.340|
000062  f7fffffe          BL       ADC_RegularChannelConfig
;;;89     	ADC_RegularChannelConfig(ADC1, CH3, 4, SAMPLE_TIME );
000066  2303              MOVS     r3,#3
000068  2204              MOVS     r2,#4
00006a  4619              MOV      r1,r3
00006c  4839              LDR      r0,|L3.340|
00006e  f7fffffe          BL       ADC_RegularChannelConfig
;;;90     	ADC_RegularChannelConfig(ADC1, CH4, 5, SAMPLE_TIME );
000072  2303              MOVS     r3,#3
000074  2205              MOVS     r2,#5
000076  210e              MOVS     r1,#0xe
000078  4836              LDR      r0,|L3.340|
00007a  f7fffffe          BL       ADC_RegularChannelConfig
;;;91     	ADC_RegularChannelConfig(ADC1, CH5, 6, SAMPLE_TIME );
00007e  2303              MOVS     r3,#3
000080  2206              MOVS     r2,#6
000082  210f              MOVS     r1,#0xf
000084  4833              LDR      r0,|L3.340|
000086  f7fffffe          BL       ADC_RegularChannelConfig
;;;92     	ADC_RegularChannelConfig(ADC1, CH6, 7, SAMPLE_TIME );
00008a  2303              MOVS     r3,#3
00008c  2207              MOVS     r2,#7
00008e  2106              MOVS     r1,#6
000090  4830              LDR      r0,|L3.340|
000092  f7fffffe          BL       ADC_RegularChannelConfig
;;;93     	ADC_RegularChannelConfig(ADC1, CH7, 8, SAMPLE_TIME );
000096  2303              MOVS     r3,#3
000098  2208              MOVS     r2,#8
00009a  2107              MOVS     r1,#7
00009c  482d              LDR      r0,|L3.340|
00009e  f7fffffe          BL       ADC_RegularChannelConfig
;;;94     	ADC_RegularChannelConfig(ADC1, CH8, 9, SAMPLE_TIME );
0000a2  2303              MOVS     r3,#3
0000a4  2209              MOVS     r2,#9
0000a6  2108              MOVS     r1,#8
0000a8  482a              LDR      r0,|L3.340|
0000aa  f7fffffe          BL       ADC_RegularChannelConfig
;;;95     	ADC_RegularChannelConfig(ADC1, CH9, 10, SAMPLE_TIME );
0000ae  2303              MOVS     r3,#3
0000b0  220a              MOVS     r2,#0xa
0000b2  2109              MOVS     r1,#9
0000b4  4827              LDR      r0,|L3.340|
0000b6  f7fffffe          BL       ADC_RegularChannelConfig
;;;96     	ADC_RegularChannelConfig(ADC1, CH10, 11, SAMPLE_TIME );
0000ba  2303              MOVS     r3,#3
0000bc  220b              MOVS     r2,#0xb
0000be  210a              MOVS     r1,#0xa
0000c0  4824              LDR      r0,|L3.340|
0000c2  f7fffffe          BL       ADC_RegularChannelConfig
;;;97     	ADC_RegularChannelConfig(ADC1, CH11, 12, SAMPLE_TIME );
0000c6  2303              MOVS     r3,#3
0000c8  220c              MOVS     r2,#0xc
0000ca  210b              MOVS     r1,#0xb
0000cc  4821              LDR      r0,|L3.340|
0000ce  f7fffffe          BL       ADC_RegularChannelConfig
;;;98     
;;;99     	// 开启ADC的DMA支持（要实现DMA功能，还需独立配置DMA通道等参数）
;;;100    	ADC_DMACmd(ADC1, ENABLE);
0000d2  2101              MOVS     r1,#1
0000d4  481f              LDR      r0,|L3.340|
0000d6  f7fffffe          BL       ADC_DMACmd
;;;101    	
;;;102    	//开启模拟看门狗
;;;103    	ADC_AnalogWatchdogThresholdsConfig(ADC1,0xfff,0);
0000da  2200              MOVS     r2,#0
0000dc  f64071ff          MOV      r1,#0xfff
0000e0  481c              LDR      r0,|L3.340|
0000e2  f7fffffe          BL       ADC_AnalogWatchdogThresholdsConfig
;;;104    	ADC_AnalogWatchdogCmd(ADC1,ADC_AnalogWatchdog_AllRegEnable);
0000e6  f44f0100          MOV      r1,#0x800000
0000ea  481a              LDR      r0,|L3.340|
0000ec  f7fffffe          BL       ADC_AnalogWatchdogCmd
;;;105    	ADC_ITConfig(ADC1, ADC_IT_AWD, ENABLE);//允许模拟看门狗中断
0000f0  2201              MOVS     r2,#1
0000f2  f44f71a0          MOV      r1,#0x140
0000f6  4817              LDR      r0,|L3.340|
0000f8  f7fffffe          BL       ADC_ITConfig
;;;106    
;;;107    	//使能ADC中断
;;;108    	ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
0000fc  2201              MOVS     r2,#1
0000fe  f44f7108          MOV      r1,#0x220
000102  4814              LDR      r0,|L3.340|
000104  f7fffffe          BL       ADC_ITConfig
;;;109    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = ADC1_2_INT_PREEM;
000108  2000              MOVS     r0,#0
00010a  f88d0005          STRB     r0,[sp,#5]
;;;110    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = ADC1_2_INT_SUB;
00010e  2001              MOVS     r0,#1
000110  f88d0006          STRB     r0,[sp,#6]
;;;111    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000114  f88d0007          STRB     r0,[sp,#7]
;;;112    
;;;113    	NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn;
000118  2012              MOVS     r0,#0x12
00011a  f88d0004          STRB     r0,[sp,#4]
;;;114    	NVIC_Init(&NVIC_InitStructure);  
00011e  a801              ADD      r0,sp,#4
000120  f7fffffe          BL       NVIC_Init
;;;115    	
;;;116    	ADC_Cmd(ADC1, ENABLE); //使能指定的ADC1
000124  2101              MOVS     r1,#1
000126  480b              LDR      r0,|L3.340|
000128  f7fffffe          BL       ADC_Cmd
;;;117    
;;;118    	ADC_ResetCalibration(ADC1); //复位指定的ADC1的校准寄存器
00012c  4809              LDR      r0,|L3.340|
00012e  f7fffffe          BL       ADC_ResetCalibration
;;;119    
;;;120    	while(ADC_GetResetCalibrationStatus(ADC1)); //获取ADC1复位校准寄存器的状态,设置状态则等待
000132  bf00              NOP      
                  |L3.308|
000134  4807              LDR      r0,|L3.340|
000136  f7fffffe          BL       ADC_GetResetCalibrationStatus
00013a  2800              CMP      r0,#0
00013c  d1fa              BNE      |L3.308|
;;;121    
;;;122    
;;;123    	ADC_StartCalibration(ADC1); //开始指定ADC1的校准状态
00013e  4805              LDR      r0,|L3.340|
000140  f7fffffe          BL       ADC_StartCalibration
;;;124    
;;;125    	while(ADC_GetCalibrationStatus(ADC1)); //获取指定ADC1的校准程序,设置状态则等待
000144  bf00              NOP      
                  |L3.326|
000146  4803              LDR      r0,|L3.340|
000148  f7fffffe          BL       ADC_GetCalibrationStatus
00014c  2800              CMP      r0,#0
00014e  d1fa              BNE      |L3.326|
;;;126    }
000150  b007              ADD      sp,sp,#0x1c
000152  bd00              POP      {pc}
;;;127    
                          ENDP

                  |L3.340|
                          DCD      0x40012400

                          AREA ||i.AD_GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  AD_GPIO_Configuration PROC
;;;37     
;;;38     void AD_GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;39     {
;;;40     	GPIO_InitTypeDef GPIO_InitStructure;
;;;41     
;;;42     	/*开启GPIOB和GPIOF的外设时钟*/
;;;43     	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE); 
000002  2101              MOVS     r1,#1
000004  201c              MOVS     r0,#0x1c
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;44     	//PA0/1/2/3 作为模拟通道输入引脚
;;;45     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0| GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;
00000a  200f              MOVS     r0,#0xf
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;46     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚
000010  2000              MOVS     r0,#0
000012  f88d0003          STRB     r0,[sp,#3]
;;;47     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  480b              LDR      r0,|L4.72|
00001a  f7fffffe          BL       GPIO_Init
;;;48     
;;;49     	//PB0/1 作为模拟通道输入引脚
;;;50     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1;
00001e  2003              MOVS     r0,#3
000020  f8ad0000          STRH     r0,[sp,#0]
;;;51     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚
000024  2000              MOVS     r0,#0
000026  f88d0003          STRB     r0,[sp,#3]
;;;52     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4807              LDR      r0,|L4.76|
00002e  f7fffffe          BL       GPIO_Init
;;;53     
;;;54     	//PC0/1/2/3/4/5 作为模拟通道输入引脚
;;;55     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;
000032  203f              MOVS     r0,#0x3f
000034  f8ad0000          STRH     r0,[sp,#0]
;;;56     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚
000038  2000              MOVS     r0,#0
00003a  f88d0003          STRB     r0,[sp,#3]
;;;57     	GPIO_Init(GPIOC, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  4803              LDR      r0,|L4.80|
000042  f7fffffe          BL       GPIO_Init
;;;58     }
000046  bd08              POP      {r3,pc}
;;;59     
                          ENDP

                  |L4.72|
                          DCD      0x40010800
                  |L4.76|
                          DCD      0x40010c00
                  |L4.80|
                          DCD      0x40011000

                          AREA ||i.AD_Sample_init||, CODE, READONLY, ALIGN=2

                  AD_Sample_init PROC
;;;259    
;;;260    int AD_Sample_init (void)
000000  b510              PUSH     {r4,lr}
;;;261    {
;;;262    	AD_GPIO_Configuration ();
000002  f7fffffe          BL       AD_GPIO_Configuration
;;;263    	AD1_DMA_Configuration ();
000006  f7fffffe          BL       AD1_DMA_Configuration
;;;264    	ADC1_Configuration ();
00000a  f7fffffe          BL       ADC1_Configuration
;;;265    
;;;266    	DMA_Cmd(DMA1_Channel1, ENABLE); //启动DMA通道
00000e  2101              MOVS     r1,#1
000010  4804              LDR      r0,|L5.36|
000012  f7fffffe          BL       DMA_Cmd
;;;267    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
000016  2101              MOVS     r1,#1
000018  4803              LDR      r0,|L5.40|
00001a  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;268    	return 0;
00001e  2000              MOVS     r0,#0
;;;269    }
000020  bd10              POP      {r4,pc}
;;;270    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x40020008
                  |L5.40|
                          DCD      0x40012400

                          AREA ||i.AD_Start_Sample||, CODE, READONLY, ALIGN=2

                  AD_Start_Sample PROC
;;;270    
;;;271    void AD_Start_Sample (u32 _memBaseAddr)
000000  b510              PUSH     {r4,lr}
;;;272    {
000002  4604              MOV      r4,r0
;;;273    	ADC_sync_signal = 0;//AD 信号清零 采样同步
000004  2000              MOVS     r0,#0
000006  4904              LDR      r1,|L6.24|
000008  8008              STRH     r0,[r1,#0]
;;;274    	/* Write to DMA1 Channel4 CMAR */
;;;275    	DMA1_Channel1->CMAR = _memBaseAddr;
00000a  4804              LDR      r0,|L6.28|
00000c  6144              STR      r4,[r0,#0x14]
;;;276    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);//滤波完就开启转换
00000e  2101              MOVS     r1,#1
000010  4803              LDR      r0,|L6.32|
000012  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;277    }
000016  bd10              POP      {r4,pc}
;;;278    
                          ENDP

                  |L6.24|
                          DCD      ADC_sync_signal
                  |L6.28|
                          DCD      0x40020000
                  |L6.32|
                          DCD      0x40012400

                          AREA ||i.AD_filter||, CODE, READONLY, ALIGN=2

                  AD_filter PROC
;;;241    
;;;242    void AD_filter(U16 _detect_chanel_index, U16 _chanel_pos_index)
000000  b5f0              PUSH     {r4-r7,lr}
;;;243    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;244    	
;;;245    	int sum = 0, i;
000006  2000              MOVS     r0,#0
;;;246    	u8 count;
;;;247    	for(i=0;i<CHANEL_NUM;i++)
000008  2100              MOVS     r1,#0
00000a  e018              B        |L7.62|
                  |L7.12|
;;;248    	{
;;;249    		for ( count=0;count<SAMPLE_NUM;count++)
00000c  2200              MOVS     r2,#0
00000e  e009              B        |L7.36|
                  |L7.16|
;;;250    		{
;;;251    			sum += AD_Value_0[count][i];
000010  eb020342          ADD      r3,r2,r2,LSL #1
000014  4e0b              LDR      r6,|L7.68|
000016  eb0603c3          ADD      r3,r6,r3,LSL #3
00001a  f8333011          LDRH     r3,[r3,r1,LSL #1]
00001e  4418              ADD      r0,r0,r3
000020  1c53              ADDS     r3,r2,#1              ;249
000022  b2da              UXTB     r2,r3                 ;249
                  |L7.36|
000024  2a08              CMP      r2,#8                 ;249
000026  dbf3              BLT      |L7.16|
;;;252    		}
;;;253    		After_filter[i]=sum/SAMPLE_NUM;
000028  4603              MOV      r3,r0
00002a  17c6              ASRS     r6,r0,#31
00002c  eb007656          ADD      r6,r0,r6,LSR #29
000030  f3c606cf          UBFX     r6,r6,#3,#16
000034  4f04              LDR      r7,|L7.72|
000036  f8276011          STRH     r6,[r7,r1,LSL #1]
;;;254    		sum=0;
00003a  2000              MOVS     r0,#0
00003c  1c49              ADDS     r1,r1,#1              ;247
                  |L7.62|
00003e  290c              CMP      r1,#0xc               ;247
000040  dbe4              BLT      |L7.12|
;;;255    	}
;;;256    
;;;257    }
000042  bdf0              POP      {r4-r7,pc}
;;;258    
                          ENDP

                  |L7.68|
                          DCD      AD_Value_0
                  |L7.72|
                          DCD      After_filter

                          AREA ||i.DMA1_Channel1_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Channel1_IRQHandler PROC
;;;201    
;;;202    void DMA1_Channel1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;203    {     
;;;204    //	int sum = 0;
;;;205    //	u8 count;
;;;206    	if(DMA_GetITStatus(DMA1_IT_TC1)){
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       DMA_GetITStatus
000008  b1c0              CBZ      r0,|L8.60|
;;;207    		DMA_ClearITPendingBit(DMA1_IT_GL1); //清除全部中断标志
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       DMA_ClearITPendingBit
;;;208    		if (process_rdy < PROCESS_RDY){
000010  480b              LDR      r0,|L8.64|
000012  6800              LDR      r0,[r0,#0]  ; process_rdy
000014  f5b07f7a          CMP      r0,#0x3e8
000018  da0e              BGE      |L8.56|
;;;209    			refresh_dma1_cycle (); //先统计DMA中断周期
00001a  f7fffffe          BL       refresh_dma1_cycle
;;;210    			process_rdy++;
00001e  4808              LDR      r0,|L8.64|
000020  6800              LDR      r0,[r0,#0]  ; process_rdy
000022  1c40              ADDS     r0,r0,#1
000024  4906              LDR      r1,|L8.64|
000026  6008              STR      r0,[r1,#0]  ; process_rdy
;;;211    			ADC_sync_signal = 0;//同步信号清零
000028  2000              MOVS     r0,#0
00002a  4906              LDR      r1,|L8.68|
00002c  8008              STRH     r0,[r1,#0]
;;;212    			ADC_SoftwareStartConvCmd(ADC1, ENABLE);
00002e  2101              MOVS     r1,#1
000030  4805              LDR      r0,|L8.72|
000032  f7fffffe          BL       ADC_SoftwareStartConvCmd
000036  e001              B        |L8.60|
                  |L8.56|
;;;213    		}else{
;;;214    			counter_process ();
000038  f7fffffe          BL       counter_process
                  |L8.60|
;;;215    		}
;;;216    	}   	
;;;217    }
00003c  bd10              POP      {r4,pc}
;;;218    
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      process_rdy
                  |L8.68|
                          DCD      ADC_sync_signal
                  |L8.72|
                          DCD      0x40012400

                          AREA ||i.GetVolt||, CODE, READONLY, ALIGN=1

                  GetVolt PROC
;;;219    
;;;220    u16 GetVolt(u16 advalue)
000000  4770              BX       lr
;;;221    {
;;;222    	return (u16)(advalue); //求的结果扩大了100倍，方便下面求出小数
;;;223    }
;;;224    
                          ENDP


                          AREA ||i.count_piece||, CODE, READONLY, ALIGN=1

                  count_piece PROC
;;;294    
;;;295    int count_piece(s_chanel_info * _ch, U16 ad_value, U16 _ch_id)
000000  b5f0              PUSH     {r4-r7,lr}
;;;296    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;297    	int r_code = 0;
000008  2700              MOVS     r7,#0
;;;298    	switch(_ch->process_step)
00000a  8820              LDRH     r0,[r4,#0]
00000c  b130              CBZ      r0,|L10.28|
00000e  2806              CMP      r0,#6
000010  d01f              BEQ      |L10.82|
000012  2810              CMP      r0,#0x10
000014  d03c              BEQ      |L10.144|
000016  281f              CMP      r0,#0x1f
000018  d11a              BNE      |L10.80|
00001a  e063              B        |L10.228|
                  |L10.28|
;;;299    	{ 
;;;300    /*预制延迟,初始赋值*/
;;;301    		case 0: {
;;;302    			
;;;303    			_ch->wave_down_flag = 0;
00001c  2000              MOVS     r0,#0
00001e  8060              STRH     r0,[r4,#2]
;;;304    			_ch->wave_up_flag = 0;
000020  80a0              STRH     r0,[r4,#4]
;;;305    			_ch->ad_value_min = AD_MAX_V;
000022  f44f4000          MOV      r0,#0x8000
000026  80e0              STRH     r0,[r4,#6]
;;;306    			_ch->ad_value_min_temp = AD_MAX_V;
000028  8120              STRH     r0,[r4,#8]
;;;307    			
;;;308    			_ch->std_down_v = STD_DOWN_V;
00002a  f24610a8          MOV      r0,#0x61a8
00002e  8320              STRH     r0,[r4,#0x18]
;;;309    			_ch->std_up_v = STD_UP_V;
000030  8360              STRH     r0,[r4,#0x1a]
;;;310    			
;;;311    			_ch->cur_count = 0;
000032  2000              MOVS     r0,#0
000034  81e0              STRH     r0,[r4,#0xe]
;;;312    			_ch->pre_count = 0;
000036  8220              STRH     r0,[r4,#0x10]
;;;313    			_ch->piece_in = 0;
000038  8160              STRH     r0,[r4,#0xa]
;;;314    			_ch->piece_out = 1;
00003a  2001              MOVS     r0,#1
00003c  81a0              STRH     r0,[r4,#0xc]
;;;315    			_ch->piece_stay_t = 0;
00003e  2000              MOVS     r0,#0
000040  8260              STRH     r0,[r4,#0x12]
;;;316    			_ch->piece_stay_t_min = 0;
000042  82a0              STRH     r0,[r4,#0x14]
;;;317    			_ch->piece_stay_t_max = 0;
000044  82e0              STRH     r0,[r4,#0x16]
;;;318    			_ch->sample_index = 0;
000046  83a0              STRH     r0,[r4,#0x1c]
;;;319    			
;;;320    			_ch->process_step = 6;
000048  2006              MOVS     r0,#6
00004a  8020              STRH     r0,[r4,#0]
;;;321    			_ch->state = CH_IDLE;
00004c  2000              MOVS     r0,#0
00004e  8420              STRH     r0,[r4,#0x20]
                  |L10.80|
;;;322    			
;;;323    			break;
000050  e066              B        |L10.288|
                  |L10.82|
;;;324    		}
;;;325    		case 6:{ /*获取均值与参考值对比及变化的步骤执行*/	//read in ad value ADSAMPNUM times 
;;;326    			
;;;327    			if (ad_value < _ch->std_down_v){
000052  8b20              LDRH     r0,[r4,#0x18]
000054  42a8              CMP      r0,r5
000056  dd0c              BLE      |L10.114|
;;;328    				r_code = save_detect_data (_ch_id, &_ch->sample_index, ad_value);
000058  462a              MOV      r2,r5
00005a  f104011c          ADD      r1,r4,#0x1c
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       save_detect_data
000064  4607              MOV      r7,r0
;;;329    				_ch->state = CH_BUSY;
000066  2001              MOVS     r0,#1
000068  8420              STRH     r0,[r4,#0x20]
;;;330    				_ch->wave_down_flag++;
00006a  8860              LDRH     r0,[r4,#2]
00006c  1c40              ADDS     r0,r0,#1
00006e  8060              STRH     r0,[r4,#2]
000070  e003              B        |L10.122|
                  |L10.114|
;;;331    			}else{
;;;332    				_ch->wave_down_flag = 0;
000072  2000              MOVS     r0,#0
000074  8060              STRH     r0,[r4,#2]
;;;333    				_ch->sample_index = 0;
000076  83a0              STRH     r0,[r4,#0x1c]
;;;334    				_ch->state = CH_IDLE;
000078  8420              STRH     r0,[r4,#0x20]
                  |L10.122|
;;;335    			}
;;;336    			
;;;337    			if (_ch->wave_down_flag > WAVE_DOWN){
00007a  8860              LDRH     r0,[r4,#2]
00007c  2804              CMP      r0,#4
00007e  dd06              BLE      |L10.142|
;;;338    				_ch->wave_down_flag = 0;
000080  2000              MOVS     r0,#0
000082  8060              STRH     r0,[r4,#2]
;;;339    				_ch->ad_value_min_temp = ad_value;
000084  8125              STRH     r5,[r4,#8]
;;;340    				_ch->piece_in = 1;
000086  2001              MOVS     r0,#1
000088  8160              STRH     r0,[r4,#0xa]
;;;341    				_ch->process_step = 16;
00008a  2010              MOVS     r0,#0x10
00008c  8020              STRH     r0,[r4,#0]
                  |L10.142|
;;;342    			}else{
;;;343    			}
;;;344    			
;;;345    			break;
00008e  e047              B        |L10.288|
                  |L10.144|
;;;346    		} 
;;;347    		case 16:{	/*确定最小值,波形回升*/					//read in ad value ADSAMPNUM times 
;;;348    			
;;;349    			r_code = save_detect_data (_ch_id, &_ch->sample_index, ad_value);
000090  462a              MOV      r2,r5
000092  f104011c          ADD      r1,r4,#0x1c
000096  4630              MOV      r0,r6
000098  f7fffffe          BL       save_detect_data
00009c  4607              MOV      r7,r0
;;;350    			
;;;351    			if (ad_value < _ch->ad_value_min_temp){
00009e  8920              LDRH     r0,[r4,#8]
0000a0  42a8              CMP      r0,r5
0000a2  dd03              BLE      |L10.172|
;;;352    				_ch->ad_value_min_temp = ad_value;
0000a4  8125              STRH     r5,[r4,#8]
;;;353    				_ch->wave_up_flag = 0;
0000a6  2000              MOVS     r0,#0
0000a8  80a0              STRH     r0,[r4,#4]
0000aa  e006              B        |L10.186|
                  |L10.172|
;;;354    			}else if (ad_value > _ch->ad_value_min_temp + WAVE_UP_V){
0000ac  8920              LDRH     r0,[r4,#8]
0000ae  3032              ADDS     r0,r0,#0x32
0000b0  42a8              CMP      r0,r5
0000b2  da02              BGE      |L10.186|
;;;355    				_ch->wave_up_flag++;
0000b4  88a0              LDRH     r0,[r4,#4]
0000b6  1c40              ADDS     r0,r0,#1
0000b8  80a0              STRH     r0,[r4,#4]
                  |L10.186|
;;;356    			}
;;;357    			
;;;358    			if (_ch->wave_up_flag > WAVE_UP){//经过了波谷后
0000ba  88a0              LDRH     r0,[r4,#4]
0000bc  2808              CMP      r0,#8
0000be  dd10              BLE      |L10.226|
;;;359    				_ch->ad_value_min = _ch->ad_value_min_temp;
0000c0  8920              LDRH     r0,[r4,#8]
0000c2  80e0              STRH     r0,[r4,#6]
;;;360    				_ch->ad_value_min_temp = AD_MAX_V;
0000c4  f44f4000          MOV      r0,#0x8000
0000c8  8120              STRH     r0,[r4,#8]
;;;361    				_ch->wave_up_flag = 0;
0000ca  2000              MOVS     r0,#0
0000cc  80a0              STRH     r0,[r4,#4]
;;;362    				
;;;363    				if (_ch->piece_out == 1)
0000ce  89a0              LDRH     r0,[r4,#0xc]
0000d0  2801              CMP      r0,#1
0000d2  d104              BNE      |L10.222|
;;;364    				{
;;;365    					_ch->cur_count++;
0000d4  89e0              LDRH     r0,[r4,#0xe]
0000d6  1c40              ADDS     r0,r0,#1
0000d8  81e0              STRH     r0,[r4,#0xe]
;;;366    					_ch->piece_out = 0;
0000da  2000              MOVS     r0,#0
0000dc  81a0              STRH     r0,[r4,#0xc]
                  |L10.222|
;;;367    				}
;;;368    				_ch->process_step = 31;
0000de  201f              MOVS     r0,#0x1f
0000e0  8020              STRH     r0,[r4,#0]
                  |L10.226|
;;;369    			}
;;;370    			
;;;371    			break;
0000e2  e01d              B        |L10.288|
                  |L10.228|
;;;372    		}
;;;373    		case 31:{		/*判断是否跟参考值相同或相近,确定最大采样值,波形恢复到参考值*/				//ad0 value get
;;;374    			
;;;375    			r_code = save_detect_data (_ch_id, &_ch->sample_index, ad_value);
0000e4  462a              MOV      r2,r5
0000e6  f104011c          ADD      r1,r4,#0x1c
0000ea  4630              MOV      r0,r6
0000ec  f7fffffe          BL       save_detect_data
0000f0  4607              MOV      r7,r0
;;;376    			
;;;377    			if (ad_value >= _ch->std_up_v){
0000f2  8b60              LDRH     r0,[r4,#0x1a]
0000f4  42a8              CMP      r0,r5
0000f6  dc02              BGT      |L10.254|
;;;378    				_ch->wave_up_flag++;
0000f8  88a0              LDRH     r0,[r4,#4]
0000fa  1c40              ADDS     r0,r0,#1
0000fc  80a0              STRH     r0,[r4,#4]
                  |L10.254|
;;;379    			}
;;;380    			
;;;381    			if (_ch->wave_up_flag > WAVE_UP){
0000fe  88a0              LDRH     r0,[r4,#4]
000100  2808              CMP      r0,#8
000102  dd0c              BLE      |L10.286|
;;;382    				_ch->piece_in = 0;
000104  2000              MOVS     r0,#0
000106  8160              STRH     r0,[r4,#0xa]
;;;383    				_ch->piece_out = 1;
000108  2001              MOVS     r0,#1
00010a  81a0              STRH     r0,[r4,#0xc]
;;;384    				_ch->process_step = 6;
00010c  2006              MOVS     r0,#6
00010e  8020              STRH     r0,[r4,#0]
;;;385    				_ch->sample_size = _ch->sample_index;
000110  8ba0              LDRH     r0,[r4,#0x1c]
000112  83e0              STRH     r0,[r4,#0x1e]
;;;386    				_ch->state = CH_DATA_RDY;
000114  2002              MOVS     r0,#2
000116  8420              STRH     r0,[r4,#0x20]
;;;387    				_ch->sample_index = 0;
000118  2000              MOVS     r0,#0
00011a  83a0              STRH     r0,[r4,#0x1c]
;;;388    				_ch->wave_up_flag = 0;
00011c  80a0              STRH     r0,[r4,#4]
                  |L10.286|
;;;389    			}
;;;390    			break;
00011e  bf00              NOP      
                  |L10.288|
000120  bf00              NOP                            ;323
;;;391    		}
;;;392    	}
;;;393    	return r_code;
000122  4638              MOV      r0,r7
;;;394    }
000124  bdf0              POP      {r4-r7,pc}
;;;395    
                          ENDP


                          AREA ||i.counter_init||, CODE, READONLY, ALIGN=2

                  counter_init PROC
;;;18     
;;;19     void counter_init (void)
000000  b570              PUSH     {r4-r6,lr}
;;;20     {
;;;21     	int i;
;;;22     	S8 *p = (S8 *) &g_counter;
000002  4d0e              LDR      r5,|L11.60|
;;;23     	for (i = 0; i < sizeof(s_counter_info); i++)
000004  2400              MOVS     r4,#0
000006  e003              B        |L11.16|
                  |L11.8|
;;;24     	{
;;;25     		*(p++) = 0;
000008  2000              MOVS     r0,#0
00000a  f8050b01          STRB     r0,[r5],#1
00000e  1c64              ADDS     r4,r4,#1              ;23
                  |L11.16|
000010  f5b47fd6          CMP      r4,#0x1ac             ;23
000014  d3f8              BCC      |L11.8|
;;;26     	}	
;;;27     	
;;;28     	memset ((void *)Detect_Buf, 0, sizeof(Detect_Buf));
000016  f44f4180          MOV      r1,#0x4000
00001a  4809              LDR      r0,|L11.64|
00001c  f7fffffe          BL       __aeabi_memclr
;;;29     	memset ((void *)After_filter, 0, sizeof(After_filter));
000020  2118              MOVS     r1,#0x18
000022  4808              LDR      r0,|L11.68|
000024  f7fffffe          BL       __aeabi_memclr
;;;30     	memset ((void *)AD_Value_0, 0, sizeof(AD_Value_0));
000028  21c0              MOVS     r1,#0xc0
00002a  4807              LDR      r0,|L11.72|
00002c  f7fffffe          BL       __aeabi_memclr
;;;31     	memset ((void *)AD_Value_1, 0, sizeof(AD_Value_1));
000030  21c0              MOVS     r1,#0xc0
000032  4806              LDR      r0,|L11.76|
000034  f7fffffe          BL       __aeabi_memclr
;;;32     	
;;;33     //	for (i = 0; i < CHANEL_NUM; i++){
;;;34     //		g_counter.ch[i].process_step = 0;
;;;35     //	}
;;;36     }
000038  bd70              POP      {r4-r6,pc}
;;;37     
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
                          DCD      g_counter
                  |L11.64|
                          DCD      Detect_Buf
                  |L11.68|
                          DCD      After_filter
                  |L11.72|
                          DCD      AD_Value_0
                  |L11.76|
                          DCD      AD_Value_1

                          AREA ||i.counter_process||, CODE, READONLY, ALIGN=2

                  counter_process PROC
;;;398    vu16 counter_process_cycle = 0;
;;;399    void counter_process (void)
000000  b570              PUSH     {r4-r6,lr}
;;;400    {
;;;401    	int r_code = 0;
000002  2400              MOVS     r4,#0
;;;402    	unsigned long long tick_old;
;;;403    	tick_old = get_tim5_ticks();
000004  f7fffffe          BL       get_tim5_ticks
000008  4605              MOV      r5,r0
;;;404    //////////////////////////////////////////////////////////////////////////////////
;;;405    //////////////////////////////// process begin ///////////////////////////////////
;;;406    //////////////////////////////////////////////////////////////////////////////////
;;;407    	//AD_filter (detect_chanel_index, chanel_pos_index);
;;;408    	if (g_counter.buf_index == 0){
00000a  48fe              LDR      r0,|L12.1028|
00000c  f8b001a0          LDRH     r0,[r0,#0x1a0]  ; g_counter
000010  b970              CBNZ     r0,|L12.48|
;;;409    		g_counter.AD_Value_p = AD_Value_0;
000012  48fd              LDR      r0,|L12.1032|
000014  49fb              LDR      r1,|L12.1028|
000016  f8c101a8          STR      r0,[r1,#0x1a8]  ; g_counter
;;;410    		AD_Start_Sample ((u32) AD_Value_1);
00001a  48fc              LDR      r0,|L12.1036|
00001c  f7fffffe          BL       AD_Start_Sample
;;;411    		g_counter.buf_index++;
000020  48f8              LDR      r0,|L12.1028|
000022  f8b001a0          LDRH     r0,[r0,#0x1a0]  ; g_counter
000026  1c40              ADDS     r0,r0,#1
000028  49f6              LDR      r1,|L12.1028|
00002a  f8a101a0          STRH     r0,[r1,#0x1a0]
00002e  e00a              B        |L12.70|
                  |L12.48|
;;;412    	}else {
;;;413    		g_counter.AD_Value_p = AD_Value_1;
000030  48f6              LDR      r0,|L12.1036|
000032  49f4              LDR      r1,|L12.1028|
000034  f8c101a8          STR      r0,[r1,#0x1a8]  ; g_counter
;;;414    		AD_Start_Sample ((u32) AD_Value_0);
000038  48f3              LDR      r0,|L12.1032|
00003a  f7fffffe          BL       AD_Start_Sample
;;;415    		g_counter.buf_index = 0;
00003e  2000              MOVS     r0,#0
000040  49f0              LDR      r1,|L12.1028|
000042  f8a101a0          STRH     r0,[r1,#0x1a0]
                  |L12.70|
;;;416    	}
;;;417    
;;;418    	AD_FILTER (After_filter, g_counter.AD_Value_p, 0, SAMPLE_NUM);
000046  48ef              LDR      r0,|L12.1028|
000048  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00004c  8800              LDRH     r0,[r0,#0]
00004e  49ed              LDR      r1,|L12.1028|
000050  f8d111a8          LDR      r1,[r1,#0x1a8]  ; g_counter
000054  8b09              LDRH     r1,[r1,#0x18]
000056  4408              ADD      r0,r0,r1
000058  49ea              LDR      r1,|L12.1028|
00005a  f8d111a8          LDR      r1,[r1,#0x1a8]  ; g_counter
00005e  8e09              LDRH     r1,[r1,#0x30]
000060  4408              ADD      r0,r0,r1
000062  49e8              LDR      r1,|L12.1028|
000064  f8d111a8          LDR      r1,[r1,#0x1a8]  ; g_counter
000068  f8b11048          LDRH     r1,[r1,#0x48]
00006c  4408              ADD      r0,r0,r1
00006e  49e5              LDR      r1,|L12.1028|
000070  f8d111a8          LDR      r1,[r1,#0x1a8]  ; g_counter
000074  f8b11060          LDRH     r1,[r1,#0x60]
000078  4408              ADD      r0,r0,r1
00007a  49e2              LDR      r1,|L12.1028|
00007c  f8d111a8          LDR      r1,[r1,#0x1a8]  ; g_counter
000080  f8b11078          LDRH     r1,[r1,#0x78]
000084  4408              ADD      r0,r0,r1
000086  49df              LDR      r1,|L12.1028|
000088  f8d111a8          LDR      r1,[r1,#0x1a8]  ; g_counter
00008c  f8b11090          LDRH     r1,[r1,#0x90]
000090  4408              ADD      r0,r0,r1
000092  49dc              LDR      r1,|L12.1028|
000094  f8d111a8          LDR      r1,[r1,#0x1a8]  ; g_counter
000098  f8b110a8          LDRH     r1,[r1,#0xa8]
00009c  4408              ADD      r0,r0,r1
00009e  49dc              LDR      r1,|L12.1040|
0000a0  8008              STRH     r0,[r1,#0]
;;;419    	AD_FILTER (After_filter, g_counter.AD_Value_p, 1, SAMPLE_NUM);
0000a2  48d8              LDR      r0,|L12.1028|
0000a4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0000a8  8841              LDRH     r1,[r0,#2]
0000aa  48d6              LDR      r0,|L12.1028|
0000ac  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0000b0  8b40              LDRH     r0,[r0,#0x1a]
0000b2  4401              ADD      r1,r1,r0
0000b4  48d3              LDR      r0,|L12.1028|
0000b6  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0000ba  8e40              LDRH     r0,[r0,#0x32]
0000bc  4401              ADD      r1,r1,r0
0000be  48d1              LDR      r0,|L12.1028|
0000c0  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0000c4  f8b0004a          LDRH     r0,[r0,#0x4a]
0000c8  4401              ADD      r1,r1,r0
0000ca  48ce              LDR      r0,|L12.1028|
0000cc  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0000d0  f8b00062          LDRH     r0,[r0,#0x62]
0000d4  4401              ADD      r1,r1,r0
0000d6  48cb              LDR      r0,|L12.1028|
0000d8  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0000dc  f8b0007a          LDRH     r0,[r0,#0x7a]
0000e0  4401              ADD      r1,r1,r0
0000e2  48c8              LDR      r0,|L12.1028|
0000e4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0000e8  f8b00092          LDRH     r0,[r0,#0x92]
0000ec  4401              ADD      r1,r1,r0
0000ee  48c5              LDR      r0,|L12.1028|
0000f0  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0000f4  f8b000aa          LDRH     r0,[r0,#0xaa]
0000f8  4408              ADD      r0,r0,r1
0000fa  49c5              LDR      r1,|L12.1040|
0000fc  8048              STRH     r0,[r1,#2]
;;;420    	AD_FILTER (After_filter, g_counter.AD_Value_p, 2, SAMPLE_NUM);
0000fe  48c1              LDR      r0,|L12.1028|
000100  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000104  8881              LDRH     r1,[r0,#4]
000106  48bf              LDR      r0,|L12.1028|
000108  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00010c  8b80              LDRH     r0,[r0,#0x1c]
00010e  4401              ADD      r1,r1,r0
000110  48bc              LDR      r0,|L12.1028|
000112  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000116  8e80              LDRH     r0,[r0,#0x34]
000118  4401              ADD      r1,r1,r0
00011a  48ba              LDR      r0,|L12.1028|
00011c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000120  f8b0004c          LDRH     r0,[r0,#0x4c]
000124  4401              ADD      r1,r1,r0
000126  48b7              LDR      r0,|L12.1028|
000128  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00012c  f8b00064          LDRH     r0,[r0,#0x64]
000130  4401              ADD      r1,r1,r0
000132  48b4              LDR      r0,|L12.1028|
000134  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000138  f8b0007c          LDRH     r0,[r0,#0x7c]
00013c  4401              ADD      r1,r1,r0
00013e  48b1              LDR      r0,|L12.1028|
000140  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000144  f8b00094          LDRH     r0,[r0,#0x94]
000148  4401              ADD      r1,r1,r0
00014a  48ae              LDR      r0,|L12.1028|
00014c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000150  f8b000ac          LDRH     r0,[r0,#0xac]
000154  4408              ADD      r0,r0,r1
000156  49ae              LDR      r1,|L12.1040|
000158  8088              STRH     r0,[r1,#4]
;;;421    	AD_FILTER (After_filter, g_counter.AD_Value_p, 3, SAMPLE_NUM);
00015a  48aa              LDR      r0,|L12.1028|
00015c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000160  88c1              LDRH     r1,[r0,#6]
000162  48a8              LDR      r0,|L12.1028|
000164  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000168  8bc0              LDRH     r0,[r0,#0x1e]
00016a  4401              ADD      r1,r1,r0
00016c  48a5              LDR      r0,|L12.1028|
00016e  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000172  8ec0              LDRH     r0,[r0,#0x36]
000174  4401              ADD      r1,r1,r0
000176  48a3              LDR      r0,|L12.1028|
000178  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00017c  f8b0004e          LDRH     r0,[r0,#0x4e]
000180  4401              ADD      r1,r1,r0
000182  48a0              LDR      r0,|L12.1028|
000184  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000188  f8b00066          LDRH     r0,[r0,#0x66]
00018c  4401              ADD      r1,r1,r0
00018e  489d              LDR      r0,|L12.1028|
000190  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000194  f8b0007e          LDRH     r0,[r0,#0x7e]
000198  4401              ADD      r1,r1,r0
00019a  489a              LDR      r0,|L12.1028|
00019c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001a0  f8b00096          LDRH     r0,[r0,#0x96]
0001a4  4401              ADD      r1,r1,r0
0001a6  4897              LDR      r0,|L12.1028|
0001a8  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001ac  f8b000ae          LDRH     r0,[r0,#0xae]
0001b0  4408              ADD      r0,r0,r1
0001b2  4997              LDR      r1,|L12.1040|
0001b4  80c8              STRH     r0,[r1,#6]
;;;422    	AD_FILTER (After_filter, g_counter.AD_Value_p, 4, SAMPLE_NUM);
0001b6  4893              LDR      r0,|L12.1028|
0001b8  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001bc  8901              LDRH     r1,[r0,#8]
0001be  4891              LDR      r0,|L12.1028|
0001c0  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001c4  8c00              LDRH     r0,[r0,#0x20]
0001c6  4401              ADD      r1,r1,r0
0001c8  488e              LDR      r0,|L12.1028|
0001ca  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001ce  8f00              LDRH     r0,[r0,#0x38]
0001d0  4401              ADD      r1,r1,r0
0001d2  488c              LDR      r0,|L12.1028|
0001d4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001d8  f8b00050          LDRH     r0,[r0,#0x50]
0001dc  4401              ADD      r1,r1,r0
0001de  4889              LDR      r0,|L12.1028|
0001e0  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001e4  f8b00068          LDRH     r0,[r0,#0x68]
0001e8  4401              ADD      r1,r1,r0
0001ea  4886              LDR      r0,|L12.1028|
0001ec  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001f0  f8b00080          LDRH     r0,[r0,#0x80]
0001f4  4401              ADD      r1,r1,r0
0001f6  4883              LDR      r0,|L12.1028|
0001f8  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0001fc  f8b00098          LDRH     r0,[r0,#0x98]
000200  4401              ADD      r1,r1,r0
000202  4880              LDR      r0,|L12.1028|
000204  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000208  f8b000b0          LDRH     r0,[r0,#0xb0]
00020c  4408              ADD      r0,r0,r1
00020e  4980              LDR      r1,|L12.1040|
000210  8108              STRH     r0,[r1,#8]
;;;423    	AD_FILTER (After_filter, g_counter.AD_Value_p, 5, SAMPLE_NUM);
000212  487c              LDR      r0,|L12.1028|
000214  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000218  8941              LDRH     r1,[r0,#0xa]
00021a  487a              LDR      r0,|L12.1028|
00021c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000220  8c40              LDRH     r0,[r0,#0x22]
000222  4401              ADD      r1,r1,r0
000224  4877              LDR      r0,|L12.1028|
000226  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00022a  8f40              LDRH     r0,[r0,#0x3a]
00022c  4401              ADD      r1,r1,r0
00022e  4875              LDR      r0,|L12.1028|
000230  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000234  f8b00052          LDRH     r0,[r0,#0x52]
000238  4401              ADD      r1,r1,r0
00023a  4872              LDR      r0,|L12.1028|
00023c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000240  f8b0006a          LDRH     r0,[r0,#0x6a]
000244  4401              ADD      r1,r1,r0
000246  486f              LDR      r0,|L12.1028|
000248  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00024c  f8b00082          LDRH     r0,[r0,#0x82]
000250  4401              ADD      r1,r1,r0
000252  486c              LDR      r0,|L12.1028|
000254  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000258  f8b0009a          LDRH     r0,[r0,#0x9a]
00025c  4401              ADD      r1,r1,r0
00025e  4869              LDR      r0,|L12.1028|
000260  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000264  f8b000b2          LDRH     r0,[r0,#0xb2]
000268  4408              ADD      r0,r0,r1
00026a  4969              LDR      r1,|L12.1040|
00026c  8148              STRH     r0,[r1,#0xa]
;;;424    	AD_FILTER (After_filter, g_counter.AD_Value_p, 6, SAMPLE_NUM);
00026e  4865              LDR      r0,|L12.1028|
000270  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000274  8981              LDRH     r1,[r0,#0xc]
000276  4863              LDR      r0,|L12.1028|
000278  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00027c  8c80              LDRH     r0,[r0,#0x24]
00027e  4401              ADD      r1,r1,r0
000280  4860              LDR      r0,|L12.1028|
000282  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000286  8f80              LDRH     r0,[r0,#0x3c]
000288  4401              ADD      r1,r1,r0
00028a  485e              LDR      r0,|L12.1028|
00028c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000290  f8b00054          LDRH     r0,[r0,#0x54]
000294  4401              ADD      r1,r1,r0
000296  485b              LDR      r0,|L12.1028|
000298  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00029c  f8b0006c          LDRH     r0,[r0,#0x6c]
0002a0  4401              ADD      r1,r1,r0
0002a2  4858              LDR      r0,|L12.1028|
0002a4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0002a8  f8b00084          LDRH     r0,[r0,#0x84]
0002ac  4401              ADD      r1,r1,r0
0002ae  4855              LDR      r0,|L12.1028|
0002b0  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0002b4  f8b0009c          LDRH     r0,[r0,#0x9c]
0002b8  4401              ADD      r1,r1,r0
0002ba  4852              LDR      r0,|L12.1028|
0002bc  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0002c0  f8b000b4          LDRH     r0,[r0,#0xb4]
0002c4  4408              ADD      r0,r0,r1
0002c6  4952              LDR      r1,|L12.1040|
0002c8  8188              STRH     r0,[r1,#0xc]
;;;425    	AD_FILTER (After_filter, g_counter.AD_Value_p, 7, SAMPLE_NUM);
0002ca  484e              LDR      r0,|L12.1028|
0002cc  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0002d0  89c1              LDRH     r1,[r0,#0xe]
0002d2  484c              LDR      r0,|L12.1028|
0002d4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0002d8  8cc0              LDRH     r0,[r0,#0x26]
0002da  4401              ADD      r1,r1,r0
0002dc  4849              LDR      r0,|L12.1028|
0002de  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0002e2  8fc0              LDRH     r0,[r0,#0x3e]
0002e4  4401              ADD      r1,r1,r0
0002e6  4847              LDR      r0,|L12.1028|
0002e8  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0002ec  f8b00056          LDRH     r0,[r0,#0x56]
0002f0  4401              ADD      r1,r1,r0
0002f2  4844              LDR      r0,|L12.1028|
0002f4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0002f8  f8b0006e          LDRH     r0,[r0,#0x6e]
0002fc  4401              ADD      r1,r1,r0
0002fe  4841              LDR      r0,|L12.1028|
000300  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000304  f8b00086          LDRH     r0,[r0,#0x86]
000308  4401              ADD      r1,r1,r0
00030a  483e              LDR      r0,|L12.1028|
00030c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000310  f8b0009e          LDRH     r0,[r0,#0x9e]
000314  4401              ADD      r1,r1,r0
000316  483b              LDR      r0,|L12.1028|
000318  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00031c  f8b000b6          LDRH     r0,[r0,#0xb6]
000320  4408              ADD      r0,r0,r1
000322  493b              LDR      r1,|L12.1040|
000324  81c8              STRH     r0,[r1,#0xe]
;;;426    	AD_FILTER (After_filter, g_counter.AD_Value_p, 8, SAMPLE_NUM);
000326  4837              LDR      r0,|L12.1028|
000328  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00032c  8a01              LDRH     r1,[r0,#0x10]
00032e  4835              LDR      r0,|L12.1028|
000330  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000334  8d00              LDRH     r0,[r0,#0x28]
000336  4401              ADD      r1,r1,r0
000338  4832              LDR      r0,|L12.1028|
00033a  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00033e  f8b00040          LDRH     r0,[r0,#0x40]
000342  4401              ADD      r1,r1,r0
000344  482f              LDR      r0,|L12.1028|
000346  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00034a  f8b00058          LDRH     r0,[r0,#0x58]
00034e  4401              ADD      r1,r1,r0
000350  482c              LDR      r0,|L12.1028|
000352  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000356  f8b00070          LDRH     r0,[r0,#0x70]
00035a  4401              ADD      r1,r1,r0
00035c  4829              LDR      r0,|L12.1028|
00035e  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000362  f8b00088          LDRH     r0,[r0,#0x88]
000366  4401              ADD      r1,r1,r0
000368  4826              LDR      r0,|L12.1028|
00036a  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00036e  f8b000a0          LDRH     r0,[r0,#0xa0]
000372  4401              ADD      r1,r1,r0
000374  4823              LDR      r0,|L12.1028|
000376  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00037a  f8b000b8          LDRH     r0,[r0,#0xb8]
00037e  4408              ADD      r0,r0,r1
000380  4923              LDR      r1,|L12.1040|
000382  8208              STRH     r0,[r1,#0x10]
;;;427    	AD_FILTER (After_filter, g_counter.AD_Value_p, 9, SAMPLE_NUM);
000384  481f              LDR      r0,|L12.1028|
000386  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00038a  8a41              LDRH     r1,[r0,#0x12]
00038c  481d              LDR      r0,|L12.1028|
00038e  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000392  8d40              LDRH     r0,[r0,#0x2a]
000394  4401              ADD      r1,r1,r0
000396  481b              LDR      r0,|L12.1028|
000398  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00039c  f8b00042          LDRH     r0,[r0,#0x42]
0003a0  4401              ADD      r1,r1,r0
0003a2  4818              LDR      r0,|L12.1028|
0003a4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0003a8  f8b0005a          LDRH     r0,[r0,#0x5a]
0003ac  4401              ADD      r1,r1,r0
0003ae  4815              LDR      r0,|L12.1028|
0003b0  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0003b4  f8b00072          LDRH     r0,[r0,#0x72]
0003b8  4401              ADD      r1,r1,r0
0003ba  4812              LDR      r0,|L12.1028|
0003bc  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0003c0  f8b0008a          LDRH     r0,[r0,#0x8a]
0003c4  4401              ADD      r1,r1,r0
0003c6  480f              LDR      r0,|L12.1028|
0003c8  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0003cc  f8b000a2          LDRH     r0,[r0,#0xa2]
0003d0  4401              ADD      r1,r1,r0
0003d2  480c              LDR      r0,|L12.1028|
0003d4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0003d8  f8b000ba          LDRH     r0,[r0,#0xba]
0003dc  4408              ADD      r0,r0,r1
0003de  490c              LDR      r1,|L12.1040|
0003e0  8248              STRH     r0,[r1,#0x12]
;;;428    	AD_FILTER (After_filter, g_counter.AD_Value_p, 10, SAMPLE_NUM);
0003e2  4808              LDR      r0,|L12.1028|
0003e4  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0003e8  8a81              LDRH     r1,[r0,#0x14]
0003ea  4806              LDR      r0,|L12.1028|
0003ec  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0003f0  8d80              LDRH     r0,[r0,#0x2c]
0003f2  4401              ADD      r1,r1,r0
0003f4  4803              LDR      r0,|L12.1028|
0003f6  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0003fa  f8b00044          LDRH     r0,[r0,#0x44]
0003fe  4401              ADD      r1,r1,r0
000400  4800              LDR      r0,|L12.1028|
000402  e007              B        |L12.1044|
                  |L12.1028|
                          DCD      g_counter
                  |L12.1032|
                          DCD      AD_Value_0
                  |L12.1036|
                          DCD      AD_Value_1
                  |L12.1040|
                          DCD      After_filter
                  |L12.1044|
000414  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000418  f8b0005c          LDRH     r0,[r0,#0x5c]
00041c  4401              ADD      r1,r1,r0
00041e  4871              LDR      r0,|L12.1508|
000420  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000424  f8b00074          LDRH     r0,[r0,#0x74]
000428  4401              ADD      r1,r1,r0
00042a  486e              LDR      r0,|L12.1508|
00042c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000430  f8b0008c          LDRH     r0,[r0,#0x8c]
000434  4401              ADD      r1,r1,r0
000436  486b              LDR      r0,|L12.1508|
000438  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00043c  f8b000a4          LDRH     r0,[r0,#0xa4]
000440  4401              ADD      r1,r1,r0
000442  4868              LDR      r0,|L12.1508|
000444  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000448  f8b000bc          LDRH     r0,[r0,#0xbc]
00044c  4408              ADD      r0,r0,r1
00044e  4966              LDR      r1,|L12.1512|
000450  8288              STRH     r0,[r1,#0x14]
;;;429    	AD_FILTER (After_filter, g_counter.AD_Value_p, 11, SAMPLE_NUM);
000452  4864              LDR      r0,|L12.1508|
000454  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000458  8ac1              LDRH     r1,[r0,#0x16]
00045a  4862              LDR      r0,|L12.1508|
00045c  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000460  8dc0              LDRH     r0,[r0,#0x2e]
000462  4401              ADD      r1,r1,r0
000464  485f              LDR      r0,|L12.1508|
000466  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00046a  f8b00046          LDRH     r0,[r0,#0x46]
00046e  4401              ADD      r1,r1,r0
000470  485c              LDR      r0,|L12.1508|
000472  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000476  f8b0005e          LDRH     r0,[r0,#0x5e]
00047a  4401              ADD      r1,r1,r0
00047c  4859              LDR      r0,|L12.1508|
00047e  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
000482  f8b00076          LDRH     r0,[r0,#0x76]
000486  4401              ADD      r1,r1,r0
000488  4856              LDR      r0,|L12.1508|
00048a  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00048e  f8b0008e          LDRH     r0,[r0,#0x8e]
000492  4401              ADD      r1,r1,r0
000494  4853              LDR      r0,|L12.1508|
000496  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
00049a  f8b000a6          LDRH     r0,[r0,#0xa6]
00049e  4401              ADD      r1,r1,r0
0004a0  4850              LDR      r0,|L12.1508|
0004a2  f8d001a8          LDR      r0,[r0,#0x1a8]  ; g_counter
0004a6  f8b000be          LDRH     r0,[r0,#0xbe]
0004aa  4408              ADD      r0,r0,r1
0004ac  494e              LDR      r1,|L12.1512|
0004ae  82c8              STRH     r0,[r1,#0x16]
;;;430    
;;;431    #if 0
;;;432    	r_code += count_piece (&g_counter.ch[0], After_filter[0], 0);
;;;433    	r_code += count_piece (&g_counter.ch[1], After_filter[1], 1);
;;;434    	r_code += count_piece (&g_counter.ch[2], After_filter[2], 2);
;;;435    	r_code += count_piece (&g_counter.ch[3], After_filter[3], 3);
;;;436    	r_code += count_piece (&g_counter.ch[4], After_filter[4], 4);
;;;437    	r_code += count_piece (&g_counter.ch[5], After_filter[5], 5);
;;;438    	r_code += count_piece (&g_counter.ch[6], After_filter[6], 6);
;;;439    	r_code += count_piece (&g_counter.ch[7], After_filter[7], 7);
;;;440    	r_code += count_piece (&g_counter.ch[8], After_filter[8], 8);
;;;441    	r_code += count_piece (&g_counter.ch[9], After_filter[9], 9);
;;;442    	r_code += count_piece (&g_counter.ch[10], After_filter[10], 10);
;;;443    	r_code += count_piece (&g_counter.ch[11], After_filter[11], 11);
;;;444    #else //以下代码只在测试的时候用，正常使用是用上面的代码
;;;445    	r_code += count_piece (&g_counter.ch[0], After_filter[0], 0);
0004b0  4608              MOV      r0,r1
0004b2  8801              LDRH     r1,[r0,#0]  ; After_filter
0004b4  2200              MOVS     r2,#0
0004b6  484b              LDR      r0,|L12.1508|
0004b8  f7fffffe          BL       count_piece
0004bc  4404              ADD      r4,r4,r0
;;;446    	r_code += count_piece (&g_counter.ch[1], After_filter[0], 1);
0004be  484a              LDR      r0,|L12.1512|
0004c0  8801              LDRH     r1,[r0,#0]  ; After_filter
0004c2  2201              MOVS     r2,#1
0004c4  4847              LDR      r0,|L12.1508|
0004c6  3022              ADDS     r0,r0,#0x22
0004c8  f7fffffe          BL       count_piece
0004cc  4404              ADD      r4,r4,r0
;;;447    	r_code += count_piece (&g_counter.ch[2], After_filter[0], 2);
0004ce  4846              LDR      r0,|L12.1512|
0004d0  8801              LDRH     r1,[r0,#0]  ; After_filter
0004d2  2202              MOVS     r2,#2
0004d4  4843              LDR      r0,|L12.1508|
0004d6  3044              ADDS     r0,r0,#0x44
0004d8  f7fffffe          BL       count_piece
0004dc  4404              ADD      r4,r4,r0
;;;448    	r_code += count_piece (&g_counter.ch[3], After_filter[0], 3);
0004de  4842              LDR      r0,|L12.1512|
0004e0  8801              LDRH     r1,[r0,#0]  ; After_filter
0004e2  2203              MOVS     r2,#3
0004e4  483f              LDR      r0,|L12.1508|
0004e6  3066              ADDS     r0,r0,#0x66
0004e8  f7fffffe          BL       count_piece
0004ec  4404              ADD      r4,r4,r0
;;;449    	r_code += count_piece (&g_counter.ch[4], After_filter[0], 4);
0004ee  483e              LDR      r0,|L12.1512|
0004f0  8801              LDRH     r1,[r0,#0]  ; After_filter
0004f2  2204              MOVS     r2,#4
0004f4  483b              LDR      r0,|L12.1508|
0004f6  3088              ADDS     r0,r0,#0x88
0004f8  f7fffffe          BL       count_piece
0004fc  4404              ADD      r4,r4,r0
;;;450    	r_code += count_piece (&g_counter.ch[5], After_filter[0], 5);
0004fe  483a              LDR      r0,|L12.1512|
000500  8801              LDRH     r1,[r0,#0]  ; After_filter
000502  2205              MOVS     r2,#5
000504  4837              LDR      r0,|L12.1508|
000506  30aa              ADDS     r0,r0,#0xaa
000508  f7fffffe          BL       count_piece
00050c  4404              ADD      r4,r4,r0
;;;451    	r_code += count_piece (&g_counter.ch[6], After_filter[0], 6);
00050e  4836              LDR      r0,|L12.1512|
000510  8801              LDRH     r1,[r0,#0]  ; After_filter
000512  2206              MOVS     r2,#6
000514  4833              LDR      r0,|L12.1508|
000516  30cc              ADDS     r0,r0,#0xcc
000518  f7fffffe          BL       count_piece
00051c  4404              ADD      r4,r4,r0
;;;452    	r_code += count_piece (&g_counter.ch[7], After_filter[0], 7);
00051e  4832              LDR      r0,|L12.1512|
000520  8801              LDRH     r1,[r0,#0]  ; After_filter
000522  2207              MOVS     r2,#7
000524  482f              LDR      r0,|L12.1508|
000526  30ee              ADDS     r0,r0,#0xee
000528  f7fffffe          BL       count_piece
00052c  4404              ADD      r4,r4,r0
;;;453    	r_code += count_piece (&g_counter.ch[8], After_filter[0], 8);
00052e  482e              LDR      r0,|L12.1512|
000530  8801              LDRH     r1,[r0,#0]  ; After_filter
000532  2208              MOVS     r2,#8
000534  482d              LDR      r0,|L12.1516|
000536  f7fffffe          BL       count_piece
00053a  4404              ADD      r4,r4,r0
;;;454    	r_code += count_piece (&g_counter.ch[9], After_filter[0], 9);
00053c  482a              LDR      r0,|L12.1512|
00053e  8801              LDRH     r1,[r0,#0]  ; After_filter
000540  2209              MOVS     r2,#9
000542  482a              LDR      r0,|L12.1516|
000544  3022              ADDS     r0,r0,#0x22
000546  f7fffffe          BL       count_piece
00054a  4404              ADD      r4,r4,r0
;;;455    	r_code += count_piece (&g_counter.ch[10], After_filter[0], 10);
00054c  4826              LDR      r0,|L12.1512|
00054e  8801              LDRH     r1,[r0,#0]  ; After_filter
000550  220a              MOVS     r2,#0xa
000552  4826              LDR      r0,|L12.1516|
000554  3044              ADDS     r0,r0,#0x44
000556  f7fffffe          BL       count_piece
00055a  4404              ADD      r4,r4,r0
;;;456    	r_code += count_piece (&g_counter.ch[11], After_filter[0], 11);
00055c  4822              LDR      r0,|L12.1512|
00055e  8801              LDRH     r1,[r0,#0]  ; After_filter
000560  220b              MOVS     r2,#0xb
000562  4822              LDR      r0,|L12.1516|
000564  3066              ADDS     r0,r0,#0x66
000566  f7fffffe          BL       count_piece
00056a  4404              ADD      r4,r4,r0
;;;457    #endif	
;;;458    
;;;459    	if (my_env.print == 1){
00056c  4820              LDR      r0,|L12.1520|
00056e  8900              LDRH     r0,[r0,#8]  ; my_env
000570  2801              CMP      r0,#1
000572  d12e              BNE      |L12.1490|
;;;460    		if (r_code != 0){
000574  bb6c              CBNZ     r4,|L12.1490|
;;;461    		}else if (g_counter.ch[my_env.watch_ch].state == CH_DATA_RDY){
000576  481e              LDR      r0,|L12.1520|
000578  8880              LDRH     r0,[r0,#4]  ; my_env
00057a  eb001000          ADD      r0,r0,r0,LSL #4
00057e  4919              LDR      r1,|L12.1508|
000580  eb010040          ADD      r0,r1,r0,LSL #1
000584  8c00              LDRH     r0,[r0,#0x20]
000586  2802              CMP      r0,#2
000588  d123              BNE      |L12.1490|
;;;462    			if (my_env.dma_state == 0){
00058a  4819              LDR      r0,|L12.1520|
00058c  88c0              LDRH     r0,[r0,#6]  ; my_env
00058e  bb00              CBNZ     r0,|L12.1490|
;;;463    				my_env.dma_state = 1;
000590  2001              MOVS     r0,#1
000592  4917              LDR      r1,|L12.1520|
000594  80c8              STRH     r0,[r1,#6]
;;;464    				g_counter.buf_addr = (u32)&Detect_Buf[g_counter.buf_index][0];
000596  4813              LDR      r0,|L12.1508|
000598  f8b001a0          LDRH     r0,[r0,#0x1a0]  ; g_counter
00059c  4915              LDR      r1,|L12.1524|
00059e  eb013040          ADD      r0,r1,r0,LSL #13
0005a2  4910              LDR      r1,|L12.1508|
0005a4  f8c101a4          STR      r0,[r1,#0x1a4]  ; g_counter
;;;465    				g_counter.buf_index++;
0005a8  4608              MOV      r0,r1
0005aa  f8b001a0          LDRH     r0,[r0,#0x1a0]  ; g_counter
0005ae  1c40              ADDS     r0,r0,#1
0005b0  f8a101a0          STRH     r0,[r1,#0x1a0]
;;;466    				g_counter.buf_index %= DETECTG_BUF_GROUP;
0005b4  f8b101a0          LDRH     r0,[r1,#0x1a0]  ; g_counter
0005b8  eb0071d0          ADD      r1,r0,r0,LSR #31
0005bc  1049              ASRS     r1,r1,#1
0005be  eba00141          SUB      r1,r0,r1,LSL #1
0005c2  4a08              LDR      r2,|L12.1508|
0005c4  f8a211a0          STRH     r1,[r2,#0x1a0]
;;;467    				OSQPost(debug_msg, (void *) 0x55);//发送消息
0005c8  2155              MOVS     r1,#0x55
0005ca  480b              LDR      r0,|L12.1528|
0005cc  6800              LDR      r0,[r0,#0]  ; debug_msg
0005ce  f7fffffe          BL       OSQPost
                  |L12.1490|
;;;468    			}
;;;469    		}
;;;470    	}
;;;471    	
;;;472    	counter_process_state = r_code;
0005d2  480a              LDR      r0,|L12.1532|
0005d4  6004              STR      r4,[r0,#0]  ; counter_process_state
;;;473    //////////////////////////////// process end /////////////////////////////////////
;;;474    //////////////////////////////////////////////////////////////////////////////////
;;;475    //////////////////////////////////////////////////////////////////////////////////
;;;476    	counter_process_cycle = get_tim5_ticks () - tick_old + 2;
0005d6  f7fffffe          BL       get_tim5_ticks
0005da  1b41              SUBS     r1,r0,r5
0005dc  1c88              ADDS     r0,r1,#2
0005de  4908              LDR      r1,|L12.1536|
0005e0  8008              STRH     r0,[r1,#0]
;;;477    }
0005e2  bd70              POP      {r4-r6,pc}
;;;478    
                          ENDP

                  |L12.1508|
                          DCD      g_counter
                  |L12.1512|
                          DCD      After_filter
                  |L12.1516|
                          DCD      g_counter+0x110
                  |L12.1520|
                          DCD      my_env
                  |L12.1524|
                          DCD      Detect_Buf
                  |L12.1528|
                          DCD      debug_msg
                  |L12.1532|
                          DCD      counter_process_state
                  |L12.1536|
                          DCD      counter_process_cycle

                          AREA ||i.save_detect_data||, CODE, READONLY, ALIGN=2

                  save_detect_data PROC
;;;280    
;;;281    int save_detect_data (U16 _ch, U16 * _index, U16 _ad_value)
000000  b510              PUSH     {r4,lr}
;;;282    {		
000002  4603              MOV      r3,r0
;;;283    	if (_ch == my_env.watch_ch){
000004  480c              LDR      r0,|L13.56|
000006  8880              LDRH     r0,[r0,#4]  ; my_env
000008  4298              CMP      r0,r3
00000a  d113              BNE      |L13.52|
;;;284    		if ((*_index) < DETECTG_BUF_SIZE){
00000c  8808              LDRH     r0,[r1,#0]
00000e  f5b05f80          CMP      r0,#0x1000
000012  da0d              BGE      |L13.48|
;;;285    			Detect_Buf[g_counter.buf_index][*_index] = _ad_value;
000014  4809              LDR      r0,|L13.60|
000016  f8b001a0          LDRH     r0,[r0,#0x1a0]  ; g_counter
00001a  4c09              LDR      r4,|L13.64|
00001c  eb043040          ADD      r0,r4,r0,LSL #13
000020  880c              LDRH     r4,[r1,#0]
000022  f8202014          STRH     r2,[r0,r4,LSL #1]
;;;286    			(*_index)++;
000026  8808              LDRH     r0,[r1,#0]
000028  1c40              ADDS     r0,r0,#1
00002a  8008              STRH     r0,[r1,#0]
;;;287    			return 0;
00002c  2000              MOVS     r0,#0
                  |L13.46|
;;;288    		}else{
;;;289    			return 1;
;;;290    		}
;;;291    	}
;;;292    	return 0;
;;;293    }
00002e  bd10              POP      {r4,pc}
                  |L13.48|
000030  2001              MOVS     r0,#1                 ;289
000032  e7fc              B        |L13.46|
                  |L13.52|
000034  2000              MOVS     r0,#0                 ;292
000036  e7fa              B        |L13.46|
;;;294    
                          ENDP

                  |L13.56|
                          DCD      my_env
                  |L13.60|
                          DCD      g_counter
                  |L13.64|
                          DCD      Detect_Buf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_counter
                          %        428
                  AD_Value_0
                          %        192
                  AD_Value_1
                          %        192
                  After_filter
                          %        24
                  Detect_Buf
                          %        16384
                  counter_env
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  process_rdy
                          DCD      0x00000000
                  detect_chanel_index
000004  0000              DCW      0x0000
                  chanel_pos_index
000006  0000              DCW      0x0000
                  ADC_sync_signal
000008  0000              DCW      0x0000
00000a  0000              DCB      0x00,0x00
                  counter_process_state
                          DCD      0x00000000
                  dma_irq_cycle
000010  0000              DCW      0x0000
                  counter_process_cycle
000012  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "AD_Sample\\AD_Sample.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_AD_Sample_c_89f93d13____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_AD_Sample_c_89f93d13____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_AD_Sample_c_89f93d13____REVSH|
#line 462
|__asm___11_AD_Sample_c_89f93d13____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_AD_Sample_c_89f93d13____RRX|
#line 649
|__asm___11_AD_Sample_c_89f93d13____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
