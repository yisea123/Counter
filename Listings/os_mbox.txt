; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\os_mbox.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_mbox.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\os_mbox.crf UCOSII\CORE\os_mbox.c]
                          THUMB

                          AREA ||i.OSMboxAccept||, CODE, READONLY, ALIGN=1

                  OSMboxAccept PROC
;;;46     #if OS_MBOX_ACCEPT_EN > 0u
;;;47     void  *OSMboxAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
000002  4604              MOV      r4,r0
;;;49         void      *pmsg;
;;;50     #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
;;;51         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;52     #endif
;;;53     
;;;54     
;;;55     
;;;56     #if OS_ARG_CHK_EN > 0u
;;;57         if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
;;;58             return ((void *)0);
;;;59         }
;;;60     #endif
;;;61         if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
000006  7820              LDRB     r0,[r4,#0]
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L1.16|
;;;62             return ((void *)0);
00000c  2000              MOVS     r0,#0
                  |L1.14|
;;;63         }
;;;64         OS_ENTER_CRITICAL();
;;;65         pmsg               = pevent->OSEventPtr;
;;;66         pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
;;;67         OS_EXIT_CRITICAL();
;;;68         return (pmsg);                                        /* Return the message received (or NULL)     */
;;;69     }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;64
000016  6865              LDR      r5,[r4,#4]            ;65
000018  2000              MOVS     r0,#0                 ;66
00001a  6060              STR      r0,[r4,#4]            ;66
00001c  4630              MOV      r0,r6                 ;67
00001e  f7fffffe          BL       OS_CPU_SR_Restore
000022  4628              MOV      r0,r5                 ;68
000024  e7f3              B        |L1.14|
;;;70     #endif
                          ENDP


                          AREA ||i.OSMboxCreate||, CODE, READONLY, ALIGN=2

                  OSMboxCreate PROC
;;;87     
;;;88     OS_EVENT  *OSMboxCreate (void *pmsg)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {
000002  4605              MOV      r5,r0
;;;90         OS_EVENT  *pevent;
;;;91     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;92         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;93     #endif
;;;94     
;;;95     
;;;96     
;;;97     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;98         if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;99             OS_SAFETY_CRITICAL_EXCEPTION();
;;;100        }
;;;101    #endif
;;;102    
;;;103        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000006  480f              LDR      r0,|L2.68|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  b108              CBZ      r0,|L2.16|
;;;104            return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00000c  2000              MOVS     r0,#0
                  |L2.14|
;;;105        }
;;;106        OS_ENTER_CRITICAL();
;;;107        pevent = OSEventFreeList;                    /* Get next free event control block                  */
;;;108        if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
;;;109            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;110        }
;;;111        OS_EXIT_CRITICAL();
;;;112        if (pevent != (OS_EVENT *)0) {
;;;113            pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
;;;114            pevent->OSEventCnt     = 0u;
;;;115            pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
;;;116    #if OS_EVENT_NAME_EN > 0u
;;;117            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;118    #endif
;;;119            OS_EventWaitListInit(pevent);
;;;120        }
;;;121        return (pevent);                             /* Return pointer to event control block              */
;;;122    }
00000e  bd70              POP      {r4-r6,pc}
                  |L2.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;106
000016  480c              LDR      r0,|L2.72|
000018  6804              LDR      r4,[r0,#0]            ;107  ; OSEventFreeList
00001a  6800              LDR      r0,[r0,#0]            ;108  ; OSEventFreeList
00001c  b120              CBZ      r0,|L2.40|
00001e  480a              LDR      r0,|L2.72|
000020  6800              LDR      r0,[r0,#0]            ;109  ; OSEventFreeList
000022  6840              LDR      r0,[r0,#4]            ;109
000024  4908              LDR      r1,|L2.72|
000026  6008              STR      r0,[r1,#0]            ;109  ; OSEventFreeList
                  |L2.40|
000028  4630              MOV      r0,r6                 ;111
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  b13c              CBZ      r4,|L2.64|
000030  2001              MOVS     r0,#1                 ;113
000032  7020              STRB     r0,[r4,#0]            ;113
000034  2000              MOVS     r0,#0                 ;114
000036  8120              STRH     r0,[r4,#8]            ;114
000038  6065              STR      r5,[r4,#4]            ;115
00003a  4620              MOV      r0,r4                 ;119
00003c  f7fffffe          BL       OS_EventWaitListInit
                  |L2.64|
000040  4620              MOV      r0,r4                 ;121
000042  e7e4              B        |L2.14|
;;;123    /*$PAGE*/
                          ENDP

                  |L2.68|
                          DCD      OSIntNesting
                  |L2.72|
                          DCD      OSEventFreeList

                          AREA ||i.OSMboxDel||, CODE, READONLY, ALIGN=2

                  OSMboxDel PROC
;;;160    #if OS_MBOX_DEL_EN > 0u
;;;161    OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;162                          INT8U      opt,
;;;163                          INT8U     *perr)
;;;164    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;165        BOOLEAN    tasks_waiting;
;;;166        OS_EVENT  *pevent_return;
;;;167    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;168        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;169    #endif
;;;170    
;;;171    
;;;172    
;;;173    #ifdef OS_SAFETY_CRITICAL
;;;174        if (perr == (INT8U *)0) {
;;;175            OS_SAFETY_CRITICAL_EXCEPTION();
;;;176        }
;;;177    #endif
;;;178    
;;;179    #if OS_ARG_CHK_EN > 0u
;;;180        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;181            *perr = OS_ERR_PEVENT_NULL;
;;;182            return (pevent);
;;;183        }
;;;184    #endif
;;;185        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L3.30|
;;;186            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;187            return (pevent);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;188        }
;;;189        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;190            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;191            return (pevent);
;;;192        }
;;;193        OS_ENTER_CRITICAL();
;;;194        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
;;;195            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;196        } else {
;;;197            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;198        }
;;;199        switch (opt) {
;;;200            case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
;;;201                 if (tasks_waiting == OS_FALSE) {
;;;202    #if OS_EVENT_NAME_EN > 0u
;;;203                     pevent->OSEventName = (INT8U *)(void *)"?";
;;;204    #endif
;;;205                     pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
;;;206                     pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
;;;207                     pevent->OSEventCnt  = 0u;
;;;208                     OSEventFreeList     = pevent;             /* Get next free event control block        */
;;;209                     OS_EXIT_CRITICAL();
;;;210                     *perr               = OS_ERR_NONE;
;;;211                     pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
;;;212                 } else {
;;;213                     OS_EXIT_CRITICAL();
;;;214                     *perr               = OS_ERR_TASK_WAITING;
;;;215                     pevent_return       = pevent;
;;;216                 }
;;;217                 break;
;;;218    
;;;219            case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
;;;220                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
;;;221                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;222                 }
;;;223    #if OS_EVENT_NAME_EN > 0u
;;;224                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;225    #endif
;;;226                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;227                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;228                 pevent->OSEventCnt     = 0u;
;;;229                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;230                 OS_EXIT_CRITICAL();
;;;231                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;232                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;233                 }
;;;234                 *perr         = OS_ERR_NONE;
;;;235                 pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
;;;236                 break;
;;;237    
;;;238            default:
;;;239                 OS_EXIT_CRITICAL();
;;;240                 *perr         = OS_ERR_INVALID_OPT;
;;;241                 pevent_return = pevent;
;;;242                 break;
;;;243        }
;;;244        return (pevent_return);
;;;245    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  482a              LDR      r0,|L3.200|
000020  7800              LDRB     r0,[r0,#0]            ;189  ; OSIntNesting
000022  b118              CBZ      r0,|L3.44|
000024  200f              MOVS     r0,#0xf               ;190
000026  7028              STRB     r0,[r5,#0]            ;190
000028  4620              MOV      r0,r4                 ;191
00002a  e7f6              B        |L3.26|
                  |L3.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4681              MOV      r9,r0                 ;193
000032  7aa0              LDRB     r0,[r4,#0xa]          ;194
000034  b108              CBZ      r0,|L3.58|
000036  2701              MOVS     r7,#1                 ;195
000038  e000              B        |L3.60|
                  |L3.58|
00003a  2700              MOVS     r7,#0                 ;197
                  |L3.60|
00003c  f1b80f00          CMP      r8,#0                 ;199
000040  d003              BEQ      |L3.74|
000042  f1b80f01          CMP      r8,#1                 ;199
000046  d135              BNE      |L3.180|
000048  e017              B        |L3.122|
                  |L3.74|
00004a  b97f              CBNZ     r7,|L3.108|
00004c  2000              MOVS     r0,#0                 ;205
00004e  7020              STRB     r0,[r4,#0]            ;205
000050  481e              LDR      r0,|L3.204|
000052  6800              LDR      r0,[r0,#0]            ;206  ; OSEventFreeList
000054  6060              STR      r0,[r4,#4]            ;206
000056  2000              MOVS     r0,#0                 ;207
000058  8120              STRH     r0,[r4,#8]            ;207
00005a  481c              LDR      r0,|L3.204|
00005c  6004              STR      r4,[r0,#0]            ;208  ; OSEventFreeList
00005e  4648              MOV      r0,r9                 ;209
000060  f7fffffe          BL       OS_CPU_SR_Restore
000064  2000              MOVS     r0,#0                 ;210
000066  7028              STRB     r0,[r5,#0]            ;210
000068  2600              MOVS     r6,#0                 ;211
00006a  e005              B        |L3.120|
                  |L3.108|
00006c  4648              MOV      r0,r9                 ;213
00006e  f7fffffe          BL       OS_CPU_SR_Restore
000072  2049              MOVS     r0,#0x49              ;214
000074  7028              STRB     r0,[r5,#0]            ;214
000076  4626              MOV      r6,r4                 ;215
                  |L3.120|
000078  e023              B        |L3.194|
                  |L3.122|
00007a  e005              B        |L3.136|
                  |L3.124|
00007c  2300              MOVS     r3,#0                 ;221
00007e  2202              MOVS     r2,#2                 ;221
000080  4619              MOV      r1,r3                 ;221
000082  4620              MOV      r0,r4                 ;221
000084  f7fffffe          BL       OS_EventTaskRdy
                  |L3.136|
000088  7aa0              LDRB     r0,[r4,#0xa]          ;220
00008a  2800              CMP      r0,#0                 ;220
00008c  d1f6              BNE      |L3.124|
00008e  7020              STRB     r0,[r4,#0]            ;226
000090  480e              LDR      r0,|L3.204|
000092  6800              LDR      r0,[r0,#0]            ;227  ; OSEventFreeList
000094  6060              STR      r0,[r4,#4]            ;227
000096  2000              MOVS     r0,#0                 ;228
000098  8120              STRH     r0,[r4,#8]            ;228
00009a  480c              LDR      r0,|L3.204|
00009c  6004              STR      r4,[r0,#0]            ;229  ; OSEventFreeList
00009e  4648              MOV      r0,r9                 ;230
0000a0  f7fffffe          BL       OS_CPU_SR_Restore
0000a4  2f01              CMP      r7,#1                 ;231
0000a6  d101              BNE      |L3.172|
0000a8  f7fffffe          BL       OS_Sched
                  |L3.172|
0000ac  2000              MOVS     r0,#0                 ;234
0000ae  7028              STRB     r0,[r5,#0]            ;234
0000b0  2600              MOVS     r6,#0                 ;235
0000b2  e006              B        |L3.194|
                  |L3.180|
0000b4  4648              MOV      r0,r9                 ;239
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  2007              MOVS     r0,#7                 ;240
0000bc  7028              STRB     r0,[r5,#0]            ;240
0000be  4626              MOV      r6,r4                 ;241
0000c0  bf00              NOP                            ;242
                  |L3.194|
0000c2  bf00              NOP                            ;217
0000c4  4630              MOV      r0,r6                 ;244
0000c6  e7a8              B        |L3.26|
;;;246    #endif
                          ENDP

                  |L3.200|
                          DCD      OSIntNesting
                  |L3.204|
                          DCD      OSEventFreeList

                          AREA ||i.OSMboxPend||, CODE, READONLY, ALIGN=2

                  OSMboxPend PROC
;;;281    /*$PAGE*/
;;;282    void  *OSMboxPend (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;283                       INT32U     timeout,
;;;284                       INT8U     *perr)
;;;285    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;286        void      *pmsg;
;;;287    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;288        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;289    #endif
;;;290    
;;;291    
;;;292    
;;;293    #ifdef OS_SAFETY_CRITICAL
;;;294        if (perr == (INT8U *)0) {
;;;295            OS_SAFETY_CRITICAL_EXCEPTION();
;;;296        }
;;;297    #endif
;;;298    
;;;299    #if OS_ARG_CHK_EN > 0u
;;;300        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;301            *perr = OS_ERR_PEVENT_NULL;
;;;302            return ((void *)0);
;;;303        }
;;;304    #endif
;;;305        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000e  7828              LDRB     r0,[r5,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L4.30|
;;;306            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7020              STRB     r0,[r4,#0]
;;;307            return ((void *)0);
000018  2000              MOVS     r0,#0
                  |L4.26|
;;;308        }
;;;309        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
;;;310            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;311            return ((void *)0);
;;;312        }
;;;313        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
;;;314            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;315            return ((void *)0);
;;;316        }
;;;317        OS_ENTER_CRITICAL();
;;;318        pmsg = pevent->OSEventPtr;
;;;319        if (pmsg != (void *)0) {                          /* See if there is already a message             */
;;;320            pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
;;;321            OS_EXIT_CRITICAL();
;;;322            *perr = OS_ERR_NONE;
;;;323            return (pmsg);                                /* Return the message received (or NULL)         */
;;;324        }
;;;325        OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
;;;326        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;327        OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
;;;328        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;329        OS_EXIT_CRITICAL();
;;;330        OS_Sched();                                       /* Find next highest priority task ready to run  */
;;;331        OS_ENTER_CRITICAL();
;;;332        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;333            case OS_STAT_PEND_OK:
;;;334                 pmsg =  OSTCBCur->OSTCBMsg;
;;;335                *perr =  OS_ERR_NONE;
;;;336                 break;
;;;337    
;;;338            case OS_STAT_PEND_ABORT:
;;;339                 pmsg = (void *)0;
;;;340                *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;341                 break;
;;;342    
;;;343            case OS_STAT_PEND_TO:
;;;344            default:
;;;345                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;346                 pmsg = (void *)0;
;;;347                *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;348                 break;
;;;349        }
;;;350        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;351        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;352        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;353    #if (OS_EVENT_MULTI_EN > 0u)
;;;354        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;355    #endif
;;;356        OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
;;;357        OS_EXIT_CRITICAL();
;;;358        return (pmsg);                                    /* Return received message                       */
;;;359    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.30|
00001e  4836              LDR      r0,|L4.248|
000020  7800              LDRB     r0,[r0,#0]            ;309  ; OSIntNesting
000022  b118              CBZ      r0,|L4.44|
000024  2002              MOVS     r0,#2                 ;310
000026  7020              STRB     r0,[r4,#0]            ;310
000028  2000              MOVS     r0,#0                 ;311
00002a  e7f6              B        |L4.26|
                  |L4.44|
00002c  4833              LDR      r0,|L4.252|
00002e  7800              LDRB     r0,[r0,#0]            ;313  ; OSLockNesting
000030  b118              CBZ      r0,|L4.58|
000032  200d              MOVS     r0,#0xd               ;314
000034  7020              STRB     r0,[r4,#0]            ;314
000036  2000              MOVS     r0,#0                 ;315
000038  e7ef              B        |L4.26|
                  |L4.58|
00003a  f7fffffe          BL       OS_CPU_SR_Save
00003e  4680              MOV      r8,r0                 ;317
000040  686e              LDR      r6,[r5,#4]            ;318
000042  b146              CBZ      r6,|L4.86|
000044  2000              MOVS     r0,#0                 ;320
000046  6068              STR      r0,[r5,#4]            ;320
000048  4640              MOV      r0,r8                 ;321
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2000              MOVS     r0,#0                 ;322
000050  7020              STRB     r0,[r4,#0]            ;322
000052  4630              MOV      r0,r6                 ;323
000054  e7e1              B        |L4.26|
                  |L4.86|
000056  482a              LDR      r0,|L4.256|
000058  6800              LDR      r0,[r0,#0]            ;325  ; OSTCBCur
00005a  f8900030          LDRB     r0,[r0,#0x30]         ;325
00005e  f0400002          ORR      r0,r0,#2              ;325
000062  4927              LDR      r1,|L4.256|
000064  6809              LDR      r1,[r1,#0]            ;325  ; OSTCBCur
000066  f8810030          STRB     r0,[r1,#0x30]         ;325
00006a  2000              MOVS     r0,#0                 ;326
00006c  4924              LDR      r1,|L4.256|
00006e  6809              LDR      r1,[r1,#0]            ;326  ; OSTCBCur
000070  f8810031          STRB     r0,[r1,#0x31]         ;326
000074  4822              LDR      r0,|L4.256|
000076  6800              LDR      r0,[r0,#0]            ;327  ; OSTCBCur
000078  62c7              STR      r7,[r0,#0x2c]         ;327
00007a  4628              MOV      r0,r5                 ;328
00007c  f7fffffe          BL       OS_EventTaskWait
000080  4640              MOV      r0,r8                 ;329
000082  f7fffffe          BL       OS_CPU_SR_Restore
000086  f7fffffe          BL       OS_Sched
00008a  f7fffffe          BL       OS_CPU_SR_Save
00008e  4680              MOV      r8,r0                 ;331
000090  481b              LDR      r0,|L4.256|
000092  6800              LDR      r0,[r0,#0]            ;332  ; OSTCBCur
000094  f8900031          LDRB     r0,[r0,#0x31]         ;332
000098  b120              CBZ      r0,|L4.164|
00009a  2801              CMP      r0,#1                 ;332
00009c  d00d              BEQ      |L4.186|
00009e  2802              CMP      r0,#2                 ;332
0000a0  d10a              BNE      |L4.184|
0000a2  e005              B        |L4.176|
                  |L4.164|
0000a4  4816              LDR      r0,|L4.256|
0000a6  6800              LDR      r0,[r0,#0]            ;334  ; OSTCBCur
0000a8  6a06              LDR      r6,[r0,#0x20]         ;334
0000aa  2000              MOVS     r0,#0                 ;335
0000ac  7020              STRB     r0,[r4,#0]            ;335
0000ae  e00d              B        |L4.204|
                  |L4.176|
0000b0  2600              MOVS     r6,#0                 ;339
0000b2  200e              MOVS     r0,#0xe               ;340
0000b4  7020              STRB     r0,[r4,#0]            ;340
0000b6  e009              B        |L4.204|
                  |L4.184|
0000b8  bf00              NOP                            ;343
                  |L4.186|
0000ba  4629              MOV      r1,r5                 ;345
0000bc  4810              LDR      r0,|L4.256|
0000be  6800              LDR      r0,[r0,#0]            ;345  ; OSTCBCur
0000c0  f7fffffe          BL       OS_EventTaskRemove
0000c4  2600              MOVS     r6,#0                 ;346
0000c6  200a              MOVS     r0,#0xa               ;347
0000c8  7020              STRB     r0,[r4,#0]            ;347
0000ca  bf00              NOP                            ;348
                  |L4.204|
0000cc  bf00              NOP                            ;336
0000ce  2000              MOVS     r0,#0                 ;350
0000d0  490b              LDR      r1,|L4.256|
0000d2  6809              LDR      r1,[r1,#0]            ;350  ; OSTCBCur
0000d4  f8810030          STRB     r0,[r1,#0x30]         ;350
0000d8  4909              LDR      r1,|L4.256|
0000da  6809              LDR      r1,[r1,#0]            ;351  ; OSTCBCur
0000dc  f8810031          STRB     r0,[r1,#0x31]         ;351
0000e0  4907              LDR      r1,|L4.256|
0000e2  6809              LDR      r1,[r1,#0]            ;352  ; OSTCBCur
0000e4  61c8              STR      r0,[r1,#0x1c]         ;352
0000e6  4906              LDR      r1,|L4.256|
0000e8  6809              LDR      r1,[r1,#0]            ;356  ; OSTCBCur
0000ea  6208              STR      r0,[r1,#0x20]         ;356
0000ec  4640              MOV      r0,r8                 ;357
0000ee  f7fffffe          BL       OS_CPU_SR_Restore
0000f2  4630              MOV      r0,r6                 ;358
0000f4  e791              B        |L4.26|
;;;360    /*$PAGE*/
                          ENDP

0000f6  0000              DCW      0x0000
                  |L4.248|
                          DCD      OSIntNesting
                  |L4.252|
                          DCD      OSLockNesting
                  |L4.256|
                          DCD      OSTCBCur

                          AREA ||i.OSMboxPendAbort||, CODE, READONLY, ALIGN=1

                  OSMboxPendAbort PROC
;;;393    #if OS_MBOX_PEND_ABORT_EN > 0u
;;;394    INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;395                            INT8U      opt,
;;;396                            INT8U     *perr)
;;;397    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;398        INT8U      nbr_tasks;
;;;399    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;400        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;401    #endif
;;;402    
;;;403    
;;;404    
;;;405    #ifdef OS_SAFETY_CRITICAL
;;;406        if (perr == (INT8U *)0) {
;;;407            OS_SAFETY_CRITICAL_EXCEPTION();
;;;408        }
;;;409    #endif
;;;410    
;;;411    #if OS_ARG_CHK_EN > 0u
;;;412        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;413            *perr = OS_ERR_PEVENT_NULL;
;;;414            return (0u);
;;;415        }
;;;416    #endif
;;;417        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L5.30|
;;;418            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;419            return (0u);
000018  2000              MOVS     r0,#0
                  |L5.26|
;;;420        }
;;;421        OS_ENTER_CRITICAL();
;;;422        if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
;;;423            nbr_tasks = 0u;
;;;424            switch (opt) {
;;;425                case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
;;;426                     while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
;;;427                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;428                         nbr_tasks++;
;;;429                     }
;;;430                     break;
;;;431    
;;;432                case OS_PEND_OPT_NONE:
;;;433                default:                                       /* No,  ready HPT       waiting on mailbox  */
;;;434                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;435                     nbr_tasks++;
;;;436                     break;
;;;437            }
;;;438            OS_EXIT_CRITICAL();
;;;439            OS_Sched();                                        /* Find HPT ready to run                    */
;;;440            *perr = OS_ERR_PEND_ABORT;
;;;441            return (nbr_tasks);
;;;442        }
;;;443        OS_EXIT_CRITICAL();
;;;444        *perr = OS_ERR_NONE;
;;;445        return (0u);                                           /* No tasks waiting on mailbox              */
;;;446    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L5.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;421
000024  7aa0              LDRB     r0,[r4,#0xa]          ;422
000026  b320              CBZ      r0,|L5.114|
000028  2600              MOVS     r6,#0                 ;423
00002a  b17f              CBZ      r7,|L5.76|
00002c  2f01              CMP      r7,#1                 ;424
00002e  d10c              BNE      |L5.74|
000030  e007              B        |L5.66|
                  |L5.50|
000032  2302              MOVS     r3,#2                 ;427
000034  461a              MOV      r2,r3                 ;427
000036  2100              MOVS     r1,#0                 ;427
000038  4620              MOV      r0,r4                 ;427
00003a  f7fffffe          BL       OS_EventTaskRdy
00003e  1c70              ADDS     r0,r6,#1              ;428
000040  b2c6              UXTB     r6,r0                 ;428
                  |L5.66|
000042  7aa0              LDRB     r0,[r4,#0xa]          ;426
000044  2800              CMP      r0,#0                 ;426
000046  d1f4              BNE      |L5.50|
000048  e009              B        |L5.94|
                  |L5.74|
00004a  bf00              NOP                            ;432
                  |L5.76|
00004c  2302              MOVS     r3,#2                 ;434
00004e  461a              MOV      r2,r3                 ;434
000050  2100              MOVS     r1,#0                 ;434
000052  4620              MOV      r0,r4                 ;434
000054  f7fffffe          BL       OS_EventTaskRdy
000058  1c70              ADDS     r0,r6,#1              ;435
00005a  b2c6              UXTB     r6,r0                 ;435
00005c  bf00              NOP                            ;436
                  |L5.94|
00005e  bf00              NOP                            ;430
000060  4640              MOV      r0,r8                 ;438
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  f7fffffe          BL       OS_Sched
00006a  200e              MOVS     r0,#0xe               ;440
00006c  7028              STRB     r0,[r5,#0]            ;440
00006e  4630              MOV      r0,r6                 ;441
000070  e7d3              B        |L5.26|
                  |L5.114|
000072  4640              MOV      r0,r8                 ;443
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;444
00007a  7028              STRB     r0,[r5,#0]            ;444
00007c  bf00              NOP                            ;445
00007e  e7cc              B        |L5.26|
;;;447    #endif
                          ENDP


                          AREA ||i.OSMboxPost||, CODE, READONLY, ALIGN=1

                  OSMboxPost PROC
;;;472    #if OS_MBOX_POST_EN > 0u
;;;473    INT8U  OSMboxPost (OS_EVENT  *pevent,
000000  b570              PUSH     {r4-r6,lr}
;;;474                       void      *pmsg)
;;;475    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;476    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;477        OS_CPU_SR  cpu_sr = 0u;
000006  2600              MOVS     r6,#0
;;;478    #endif
;;;479    
;;;480    
;;;481    
;;;482    #if OS_ARG_CHK_EN > 0u
;;;483        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;484            return (OS_ERR_PEVENT_NULL);
;;;485        }
;;;486        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
;;;487            return (OS_ERR_POST_NULL_PTR);
;;;488        }
;;;489    #endif
;;;490        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
000008  7820              LDRB     r0,[r4,#0]
00000a  2801              CMP      r0,#1
00000c  d001              BEQ      |L6.18|
;;;491            return (OS_ERR_EVENT_TYPE);
00000e  2001              MOVS     r0,#1
                  |L6.16|
;;;492        }
;;;493        OS_ENTER_CRITICAL();
;;;494        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;495                                                          /* Ready HPT waiting on event                    */
;;;496            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;497            OS_EXIT_CRITICAL();
;;;498            OS_Sched();                                   /* Find highest priority task ready to run       */
;;;499            return (OS_ERR_NONE);
;;;500        }
;;;501        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;502            OS_EXIT_CRITICAL();
;;;503            return (OS_ERR_MBOX_FULL);
;;;504        }
;;;505        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;506        OS_EXIT_CRITICAL();
;;;507        return (OS_ERR_NONE);
;;;508    }
000010  bd70              POP      {r4-r6,pc}
                  |L6.18|
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4606              MOV      r6,r0                 ;493
000018  7aa0              LDRB     r0,[r4,#0xa]          ;494
00001a  b160              CBZ      r0,|L6.54|
00001c  2300              MOVS     r3,#0                 ;496
00001e  2202              MOVS     r2,#2                 ;496
000020  4629              MOV      r1,r5                 ;496
000022  4620              MOV      r0,r4                 ;496
000024  f7fffffe          BL       OS_EventTaskRdy
000028  4630              MOV      r0,r6                 ;497
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  f7fffffe          BL       OS_Sched
000032  2000              MOVS     r0,#0                 ;499
000034  e7ec              B        |L6.16|
                  |L6.54|
000036  6860              LDR      r0,[r4,#4]            ;501
000038  b120              CBZ      r0,|L6.68|
00003a  4630              MOV      r0,r6                 ;502
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  2014              MOVS     r0,#0x14              ;503
000042  e7e5              B        |L6.16|
                  |L6.68|
000044  6065              STR      r5,[r4,#4]            ;505
000046  4630              MOV      r0,r6                 ;506
000048  f7fffffe          BL       OS_CPU_SR_Restore
00004c  2000              MOVS     r0,#0                 ;507
00004e  e7df              B        |L6.16|
;;;509    #endif
                          ENDP


                          AREA ||i.OSMboxPostOpt||, CODE, READONLY, ALIGN=1

                  OSMboxPostOpt PROC
;;;544    #if OS_MBOX_POST_OPT_EN > 0u
;;;545    INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;546                          void      *pmsg,
;;;547                          INT8U      opt)
;;;548    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;549    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;550        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;551    #endif
;;;552    
;;;553    
;;;554    
;;;555    #if OS_ARG_CHK_EN > 0u
;;;556        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;557            return (OS_ERR_PEVENT_NULL);
;;;558        }
;;;559        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
;;;560            return (OS_ERR_POST_NULL_PTR);
;;;561        }
;;;562    #endif
;;;563        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L7.24|
;;;564            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L7.20|
;;;565        }
;;;566        OS_ENTER_CRITICAL();
;;;567        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;568            if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
;;;569                while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
;;;570                    (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;571                }
;;;572            } else {                                      /* No,  Post to HPT waiting on mbox              */
;;;573                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;574            }
;;;575            OS_EXIT_CRITICAL();
;;;576            if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
;;;577                OS_Sched();                               /* Find HPT ready to run                         */
;;;578            }
;;;579            return (OS_ERR_NONE);
;;;580        }
;;;581        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;582            OS_EXIT_CRITICAL();
;;;583            return (OS_ERR_MBOX_FULL);
;;;584        }
;;;585        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;586        OS_EXIT_CRITICAL();
;;;587        return (OS_ERR_NONE);
;;;588    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L7.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4607              MOV      r7,r0                 ;566
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;567
000020  b1e8              CBZ      r0,|L7.94|
000022  f0050001          AND      r0,r5,#1              ;568
000026  b150              CBZ      r0,|L7.62|
000028  e005              B        |L7.54|
                  |L7.42|
00002a  2300              MOVS     r3,#0                 ;570
00002c  2202              MOVS     r2,#2                 ;570
00002e  4631              MOV      r1,r6                 ;570
000030  4620              MOV      r0,r4                 ;570
000032  f7fffffe          BL       OS_EventTaskRdy
                  |L7.54|
000036  7aa0              LDRB     r0,[r4,#0xa]          ;569
000038  2800              CMP      r0,#0                 ;569
00003a  d1f6              BNE      |L7.42|
00003c  e005              B        |L7.74|
                  |L7.62|
00003e  2300              MOVS     r3,#0                 ;573
000040  2202              MOVS     r2,#2                 ;573
000042  4631              MOV      r1,r6                 ;573
000044  4620              MOV      r0,r4                 ;573
000046  f7fffffe          BL       OS_EventTaskRdy
                  |L7.74|
00004a  4638              MOV      r0,r7                 ;575
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  f0050004          AND      r0,r5,#4              ;576
000054  b908              CBNZ     r0,|L7.90|
000056  f7fffffe          BL       OS_Sched
                  |L7.90|
00005a  2000              MOVS     r0,#0                 ;579
00005c  e7da              B        |L7.20|
                  |L7.94|
00005e  6860              LDR      r0,[r4,#4]            ;581
000060  b120              CBZ      r0,|L7.108|
000062  4638              MOV      r0,r7                 ;582
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2014              MOVS     r0,#0x14              ;583
00006a  e7d3              B        |L7.20|
                  |L7.108|
00006c  6066              STR      r6,[r4,#4]            ;585
00006e  4638              MOV      r0,r7                 ;586
000070  f7fffffe          BL       OS_CPU_SR_Restore
000074  2000              MOVS     r0,#0                 ;587
000076  e7cd              B        |L7.20|
;;;589    #endif
                          ENDP


                          AREA ||i.OSMboxQuery||, CODE, READONLY, ALIGN=1

                  OSMboxQuery PROC
;;;610    #if OS_MBOX_QUERY_EN > 0u
;;;611    INT8U  OSMboxQuery (OS_EVENT      *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;612                        OS_MBOX_DATA  *p_mbox_data)
;;;613    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;614        INT8U       i;
;;;615        OS_PRIO    *psrc;
;;;616        OS_PRIO    *pdest;
;;;617    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;618        OS_CPU_SR   cpu_sr = 0u;
000008  f04f0900          MOV      r9,#0
;;;619    #endif
;;;620    
;;;621    
;;;622    
;;;623    #if OS_ARG_CHK_EN > 0u
;;;624        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;625            return (OS_ERR_PEVENT_NULL);
;;;626        }
;;;627        if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
;;;628            return (OS_ERR_PDATA_NULL);
;;;629        }
;;;630    #endif
;;;631        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L8.24|
;;;632            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L8.20|
;;;633        }
;;;634        OS_ENTER_CRITICAL();
;;;635        p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
;;;636        psrc                    = &pevent->OSEventTbl[0];
;;;637        pdest                   = &p_mbox_data->OSEventTbl[0];
;;;638        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;639            *pdest++ = *psrc++;
;;;640        }
;;;641        p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
;;;642        OS_EXIT_CRITICAL();
;;;643        return (OS_ERR_NONE);
;;;644    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L8.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4681              MOV      r9,r0                 ;634
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;635
000020  7328              STRB     r0,[r5,#0xc]          ;635
000022  f104070b          ADD      r7,r4,#0xb            ;636
000026  f1050804          ADD      r8,r5,#4              ;637
00002a  2600              MOVS     r6,#0                 ;638
00002c  e005              B        |L8.58|
                  |L8.46|
00002e  f8170b01          LDRB     r0,[r7],#1            ;639
000032  f8080b01          STRB     r0,[r8],#1            ;639
000036  1c70              ADDS     r0,r6,#1              ;638
000038  b2c6              UXTB     r6,r0                 ;638
                  |L8.58|
00003a  2e08              CMP      r6,#8                 ;638
00003c  d3f7              BCC      |L8.46|
00003e  6860              LDR      r0,[r4,#4]            ;641
000040  6028              STR      r0,[r5,#0]            ;641
000042  4648              MOV      r0,r9                 ;642
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;643
00004a  e7e3              B        |L8.20|
;;;645    #endif                                                     /* OS_MBOX_QUERY_EN                         */
                          ENDP

