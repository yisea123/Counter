; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\usart.crf driver\usart.c]
                          THUMB

                          AREA ||i.DMA1_Channel4_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Channel4_IRQHandler PROC
;;;73     //串口1DMA方式发送中断  
;;;74     void DMA1_Channel4_IRQHandler(void)  
000000  b510              PUSH     {r4,lr}
;;;75     {  
;;;76     	if(DMA_GetITStatus(DMA1_IT_TC4)){
000002  f44f5000          MOV      r0,#0x2000
000006  f7fffffe          BL       DMA_GetITStatus
00000a  b1a8              CBZ      r0,|L1.56|
;;;77     		//清除标志位  
;;;78     		DMA_ClearFlag(DMA1_FLAG_TC4);//清除通道4传输完成标志
00000c  f44f5000          MOV      r0,#0x2000
000010  f7fffffe          BL       DMA_ClearFlag
;;;79     		DMA_ClearITPendingBit(DMA1_IT_GL4); //清除全部中断标志 
000014  f44f5080          MOV      r0,#0x1000
000018  f7fffffe          BL       DMA_ClearITPendingBit
;;;80     		USART_DMACmd(USART1,USART_DMAReq_Tx, DISABLE); //DISABLE串口1的DMA发送  
00001c  2200              MOVS     r2,#0
00001e  2180              MOVS     r1,#0x80
000020  4806              LDR      r0,|L1.60|
000022  f7fffffe          BL       USART_DMACmd
;;;81     		DMA_Cmd(DMA1_Channel4, DISABLE);  
000026  2100              MOVS     r1,#0
000028  4805              LDR      r0,|L1.64|
00002a  f7fffffe          BL       DMA_Cmd
;;;82     		
;;;83     		OSQPost(debug_msg, (void *) 0xaa);//发送消息
00002e  21aa              MOVS     r1,#0xaa
000030  4804              LDR      r0,|L1.68|
000032  6800              LDR      r0,[r0,#0]  ; debug_msg
000034  f7fffffe          BL       OSQPost
                  |L1.56|
;;;84     	}
;;;85     } 
000038  bd10              POP      {r4,pc}
;;;86     
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      0x40013800
                  |L1.64|
                          DCD      0x40020044
                  |L1.68|
                          DCD      debug_msg

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;142    #if EN_USART1_RX   //如果使能了接收
;;;143    void USART1_IRQHandler(void)                	//串口1中断服务程序
000000  b508              PUSH     {r3,lr}
;;;144    {
;;;145    	__IO u8 Res;
;;;146    	//Res = USART1->SR;
;;;147    #if SYSTEM_SUPPORT_OS 		//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
;;;148    	OSIntEnter();    
000002  f7fffffe          BL       OSIntEnter
;;;149    #endif
;;;150    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000006  f2405125          MOV      r1,#0x525
00000a  480d              LDR      r0,|L2.64|
00000c  f7fffffe          BL       USART_GetITStatus
000010  b168              CBZ      r0,|L2.46|
;;;151    	{
;;;152    	#if (MODBUS_RTU_USE_UART == 1)
;;;153    		TIM_Cmd(TIM7,ENABLE);//开始计时
000012  2101              MOVS     r1,#1
000014  480b              LDR      r0,|L2.68|
000016  f7fffffe          BL       TIM_Cmd
;;;154    	#endif
;;;155    		Res = USART_ReceiveData(USART1);	//读取接收到的数据
00001a  4809              LDR      r0,|L2.64|
00001c  f7fffffe          BL       USART_ReceiveData
000020  b2c0              UXTB     r0,r0
000022  9000              STR      r0,[sp,#0]
;;;156    //		while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);
;;;157    //		//一个一个发送字符
;;;158    //		USART_SendData(USART1, (unsigned char) Res);
;;;159    //		//等待发送完成
;;;160    //		while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);
;;;161    		
;;;162    		fill_rec_buf((char)Res);
000024  f89d0000          LDRB     r0,[sp,#0]
000028  f7fffffe          BL       fill_rec_buf
00002c  e004              B        |L2.56|
                  |L2.46|
;;;163    	}else{
;;;164    		Res = USART_ReceiveData(USART1);	//读取接收到的数据
00002e  4804              LDR      r0,|L2.64|
000030  f7fffffe          BL       USART_ReceiveData
000034  b2c0              UXTB     r0,r0
000036  9000              STR      r0,[sp,#0]
                  |L2.56|
;;;165    	}
;;;166    	 
;;;167    #if SYSTEM_SUPPORT_OS 	//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
;;;168    	OSIntExit();  											 
000038  f7fffffe          BL       OSIntExit
;;;169    #endif
;;;170    } 
00003c  bd08              POP      {r3,pc}
;;;171    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x40013800
                  |L2.68|
                          DCD      0x40001400

                          AREA ||i.start_uart1_dma||, CODE, READONLY, ALIGN=2

                  start_uart1_dma PROC
;;;86     
;;;87     void start_uart1_dma (u32 _memBaseAddr, U16 _size)
000000  b570              PUSH     {r4-r6,lr}
;;;88     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;89     	/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
;;;90     	/* Write to DMA1 Channel4 CMAR */
;;;91     	DMA1_Channel4->CMAR = _memBaseAddr;
000006  4809              LDR      r0,|L3.44|
000008  6504              STR      r4,[r0,#0x50]
;;;92     	DMA_SetCurrDataCounter (DMA1_Channel4, _size);
00000a  4629              MOV      r1,r5
00000c  4807              LDR      r0,|L3.44|
00000e  3044              ADDS     r0,r0,#0x44
000010  f7fffffe          BL       DMA_SetCurrDataCounter
;;;93     	USART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE); //使能串口1的DMA发送   
000014  2201              MOVS     r2,#1
000016  2180              MOVS     r1,#0x80
000018  4805              LDR      r0,|L3.48|
00001a  f7fffffe          BL       USART_DMACmd
;;;94     	DMA_Cmd(DMA1_Channel4, ENABLE);  
00001e  2101              MOVS     r1,#1
000020  4802              LDR      r0,|L3.44|
000022  3044              ADDS     r0,r0,#0x44
000024  f7fffffe          BL       DMA_Cmd
;;;95     }
000028  bd70              POP      {r4-r6,pc}
;;;96     
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40020000
                  |L3.48|
                          DCD      0x40013800

                          AREA ||i.uart1_dma_config||, CODE, READONLY, ALIGN=2

                  uart1_dma_config PROC
;;;28     
;;;29     void uart1_dma_config (void)
000000  b500              PUSH     {lr}
;;;30     {
000002  b08d              SUB      sp,sp,#0x34
;;;31     	DMA_InitTypeDef DMA_InitStructure;
;;;32     	NVIC_InitTypeDef NVIC_InitStructure;
;;;33     	
;;;34     	//---------------------串口功能配置---------------------   
;;;35     	//启动DMA时钟  
;;;36     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);  
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;37     	//DMA1通道4配置  
;;;38     	DMA_DeInit(DMA1_Channel4);  
00000c  4818              LDR      r0,|L4.112|
00000e  f7fffffe          BL       DMA_DeInit
;;;39     	//外设地址  
;;;40     	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART1->DR);  
000012  4818              LDR      r0,|L4.116|
000014  9002              STR      r0,[sp,#8]
;;;41     	//内存地址  
;;;42     	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)(&Detect_Buf[0][0]);  
000016  4818              LDR      r0,|L4.120|
000018  9003              STR      r0,[sp,#0xc]
;;;43     	//dma传输方向单向  
;;;44     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;  
00001a  2010              MOVS     r0,#0x10
00001c  9004              STR      r0,[sp,#0x10]
;;;45     	//设置DMA在传输时缓冲区的长度  
;;;46     	DMA_InitStructure.DMA_BufferSize = DETECTG_BUF_SIZE * 2;  
00001e  0240              LSLS     r0,r0,#9
000020  9005              STR      r0,[sp,#0x14]
;;;47     	//设置DMA的外设递增模式，一个外设  
;;;48     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
000022  2000              MOVS     r0,#0
000024  9006              STR      r0,[sp,#0x18]
;;;49     	//设置DMA的内存递增模式  
;;;50     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
000026  2080              MOVS     r0,#0x80
000028  9007              STR      r0,[sp,#0x1c]
;;;51     	//外设数据字长  
;;;52     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
00002a  2000              MOVS     r0,#0
00002c  9008              STR      r0,[sp,#0x20]
;;;53     	//内存数据字长  
;;;54     	DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;  
00002e  9009              STR      r0,[sp,#0x24]
;;;55     	//设置DMA的传输模式  
;;;56     	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
000030  900a              STR      r0,[sp,#0x28]
;;;57     	//设置DMA的优先级别  
;;;58     	DMA_InitStructure.DMA_Priority = DMA_Priority_High;  
000032  f44f5000          MOV      r0,#0x2000
000036  900b              STR      r0,[sp,#0x2c]
;;;59     	//设置DMA的2个memory中的变量互相访问  
;;;60     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
000038  2000              MOVS     r0,#0
00003a  900c              STR      r0,[sp,#0x30]
;;;61     	DMA_Init(DMA1_Channel4,&DMA_InitStructure);  
00003c  a902              ADD      r1,sp,#8
00003e  480c              LDR      r0,|L4.112|
000040  f7fffffe          BL       DMA_Init
;;;62     	DMA_ITConfig(DMA1_Channel4, DMA_IT_TC, ENABLE);  
000044  2201              MOVS     r2,#1
000046  2102              MOVS     r1,#2
000048  4809              LDR      r0,|L4.112|
00004a  f7fffffe          BL       DMA_ITConfig
;;;63     	
;;;64     	//DMA发送中断设置  
;;;65     	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel4_IRQn;  
00004e  200e              MOVS     r0,#0xe
000050  f88d0004          STRB     r0,[sp,#4]
;;;66     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = DMA1_4_INT_PREEM;  
000054  2002              MOVS     r0,#2
000056  f88d0005          STRB     r0,[sp,#5]
;;;67     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = DMA1_4_INT_SUB;  
00005a  f88d0006          STRB     r0,[sp,#6]
;;;68     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  
00005e  2001              MOVS     r0,#1
000060  f88d0007          STRB     r0,[sp,#7]
;;;69     	NVIC_Init(&NVIC_InitStructure);    
000064  a801              ADD      r0,sp,#4
000066  f7fffffe          BL       NVIC_Init
;;;70     	//使能通道4  
;;;71     	//DMA_Cmd(DMA1_Channel4, ENABLE);  
;;;72     }
00006a  b00d              ADD      sp,sp,#0x34
00006c  bd00              POP      {pc}
;;;73     //串口1DMA方式发送中断  
                          ENDP

00006e  0000              DCW      0x0000
                  |L4.112|
                          DCD      0x40020044
                  |L4.116|
                          DCD      0x40013804
                  |L4.120|
                          DCD      Detect_Buf

                          AREA ||i.uart1_init||, CODE, READONLY, ALIGN=2

                  uart1_init PROC
;;;96     
;;;97     void uart1_init (void)
000000  b500              PUSH     {lr}
;;;98     {
000002  b087              SUB      sp,sp,#0x1c
;;;99     	//GPIO端口设置
;;;100    	GPIO_InitTypeDef GPIO_InitStructure;
;;;101    	USART_InitTypeDef USART_InitStructure;
;;;102    	NVIC_InitTypeDef NVIC_InitStructure;
;;;103    	 
;;;104    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
000004  2101              MOVS     r1,#1
000006  f2440004          MOV      r0,#0x4004
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;105      
;;;106    	//USART1_TX   GPIOA.9
;;;107    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
00000e  f44f7000          MOV      r0,#0x200
000012  f8ad0018          STRH     r0,[sp,#0x18]
;;;108    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d001a          STRB     r0,[sp,#0x1a]
;;;109    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00001c  2018              MOVS     r0,#0x18
00001e  f88d001b          STRB     r0,[sp,#0x1b]
;;;110    	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.9
000022  a906              ADD      r1,sp,#0x18
000024  481e              LDR      r0,|L5.160|
000026  f7fffffe          BL       GPIO_Init
;;;111       
;;;112    	//USART1_RX	  GPIOA.10初始化
;;;113    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10
00002a  f44f6080          MOV      r0,#0x400
00002e  f8ad0018          STRH     r0,[sp,#0x18]
;;;114    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000032  2004              MOVS     r0,#4
000034  f88d001b          STRB     r0,[sp,#0x1b]
;;;115    	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.10  
000038  a906              ADD      r1,sp,#0x18
00003a  4819              LDR      r0,|L5.160|
00003c  f7fffffe          BL       GPIO_Init
;;;116    
;;;117    	//Usart1 NVIC 配置
;;;118    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000040  2025              MOVS     r0,#0x25
000042  f88d0004          STRB     r0,[sp,#4]
;;;119    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = UART1_RX_INT_PREEM;//抢占优先级3
000046  2002              MOVS     r0,#2
000048  f88d0005          STRB     r0,[sp,#5]
;;;120    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = UART1_RX_INT_SUB;		//子优先级3
00004c  2003              MOVS     r0,#3
00004e  f88d0006          STRB     r0,[sp,#6]
;;;121    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000052  2001              MOVS     r0,#1
000054  f88d0007          STRB     r0,[sp,#7]
;;;122    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
000058  a801              ADD      r0,sp,#4
00005a  f7fffffe          BL       NVIC_Init
;;;123      
;;;124    	//USART 初始化设置
;;;125    
;;;126    	USART_InitStructure.USART_BaudRate = BOUND_RATE;//串口波特率
00005e  f44f30e1          MOV      r0,#0x1c200
000062  9002              STR      r0,[sp,#8]
;;;127    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000064  2000              MOVS     r0,#0
000066  f8ad000c          STRH     r0,[sp,#0xc]
;;;128    	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
00006a  f8ad000e          STRH     r0,[sp,#0xe]
;;;129    	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
00006e  f8ad0010          STRH     r0,[sp,#0x10]
;;;130    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
000072  f8ad0014          STRH     r0,[sp,#0x14]
;;;131    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000076  200c              MOVS     r0,#0xc
000078  f8ad0012          STRH     r0,[sp,#0x12]
;;;132    
;;;133    	USART_Init(USART1, &USART_InitStructure); //初始化串口1
00007c  a902              ADD      r1,sp,#8
00007e  4809              LDR      r0,|L5.164|
000080  f7fffffe          BL       USART_Init
;;;134    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
000084  2201              MOVS     r2,#1
000086  f2405125          MOV      r1,#0x525
00008a  4806              LDR      r0,|L5.164|
00008c  f7fffffe          BL       USART_ITConfig
;;;135    	USART_Cmd(USART1, ENABLE);                    //使能串口1 
000090  2101              MOVS     r1,#1
000092  4804              LDR      r0,|L5.164|
000094  f7fffffe          BL       USART_Cmd
;;;136    	
;;;137    	uart1_dma_config ();
000098  f7fffffe          BL       uart1_dma_config
;;;138    
;;;139    }
00009c  b007              ADD      sp,sp,#0x1c
00009e  bd00              POP      {pc}
;;;140    
                          ENDP

                  |L5.160|
                          DCD      0x40010800
                  |L5.164|
                          DCD      0x40013800

                          AREA ||i.uart1_puts||, CODE, READONLY, ALIGN=1

                  uart1_puts PROC
;;;21     
;;;22     void uart1_puts(const char *s)
000000  b510              PUSH     {r4,lr}
;;;23     {
000002  4604              MOV      r4,r0
;;;24     	while (*s) {
000004  e003              B        |L6.14|
                  |L6.6|
;;;25     		uart1_send_data(*s++);
000006  f8140b01          LDRB     r0,[r4],#1
00000a  f7fffffe          BL       uart1_send_data
                  |L6.14|
00000e  7820              LDRB     r0,[r4,#0]            ;24
000010  2800              CMP      r0,#0                 ;24
000012  d1f8              BNE      |L6.6|
;;;26     	}
;;;27     }
000014  bd10              POP      {r4,pc}
;;;28     
                          ENDP


                          AREA ||i.uart1_send_data||, CODE, READONLY, ALIGN=2

                  uart1_send_data PROC
;;;4      
;;;5      void uart1_send_data (int ch)
000000  b510              PUSH     {r4,lr}
;;;6      {
000002  4604              MOV      r4,r0
;;;7          //USART1->SR;  //USART_GetFlagStatus(USART1, USART_FLAG_TC) 解决第一个字符发送失败的问题
;;;8      	
;;;9      	while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);
000004  bf00              NOP      
                  |L7.6|
000006  2140              MOVS     r1,#0x40
000008  4811              LDR      r0,|L7.80|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2801              CMP      r0,#1
000010  d1f9              BNE      |L7.6|
;;;10     	if(ch == '\n')
000012  2c0a              CMP      r4,#0xa
000014  d10f              BNE      |L7.54|
;;;11     	{
;;;12     		USART_SendData(USART1, '\r');
000016  210d              MOVS     r1,#0xd
000018  480d              LDR      r0,|L7.80|
00001a  f7fffffe          BL       USART_SendData
;;;13     		my_env.roll_count++;
00001e  480d              LDR      r0,|L7.84|
000020  8840              LDRH     r0,[r0,#2]  ; my_env
000022  1c40              ADDS     r0,r0,#1
000024  490b              LDR      r1,|L7.84|
000026  8048              STRH     r0,[r1,#2]
;;;14     		while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);
000028  bf00              NOP      
                  |L7.42|
00002a  2140              MOVS     r1,#0x40
00002c  4808              LDR      r0,|L7.80|
00002e  f7fffffe          BL       USART_GetFlagStatus
000032  2801              CMP      r0,#1
000034  d1f9              BNE      |L7.42|
                  |L7.54|
;;;15     	}
;;;16         //一个一个发送字符
;;;17         USART_SendData(USART1, (unsigned char) ch);
000036  b2e1              UXTB     r1,r4
000038  4805              LDR      r0,|L7.80|
00003a  f7fffffe          BL       USART_SendData
;;;18         //等待发送完成
;;;19         while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);
00003e  bf00              NOP      
                  |L7.64|
000040  2140              MOVS     r1,#0x40
000042  4803              LDR      r0,|L7.80|
000044  f7fffffe          BL       USART_GetFlagStatus
000048  2801              CMP      r0,#1
00004a  d1f9              BNE      |L7.64|
;;;20     }
00004c  bd10              POP      {r4,pc}
;;;21     
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      0x40013800
                  |L7.84|
                          DCD      my_env

;*** Start embedded assembler ***

#line 1 "driver\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_80f86c9c____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_usart_c_80f86c9c____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_80f86c9c____REVSH|
#line 462
|__asm___7_usart_c_80f86c9c____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_80f86c9c____RRX|
#line 649
|__asm___7_usart_c_80f86c9c____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
