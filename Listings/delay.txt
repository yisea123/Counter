; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\delay.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\delay.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\user -I.\driver -I.\HARDWARE\TIMER -I.\AD_Sample -I.\SYSTEM\delay -I.\Cmd -I.\SYSTEM\sys -I.\UCOSII\CONFIG -I.\UCOSII\CORE -I.\UCOSII\PORT -I.\Protocol -I.\RTE\Device\STM32F103ZE -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\objects\delay.crf SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;111    //systick中断服务函数,使用ucos时用到
;;;112    void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;113    {	
;;;114    	if(delay_osrunning==1)						//OS开始跑了,才执行正常的调度处理
000002  4805              LDR      r0,|L1.24|
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  2801              CMP      r0,#1
000008  d105              BNE      |L1.22|
;;;115    	{
;;;116    		OSIntEnter();							//进入中断
00000a  f7fffffe          BL       OSIntEnter
;;;117    		OSTimeTick();       					//调用ucos的时钟服务程序               
00000e  f7fffffe          BL       OSTimeTick
;;;118    		OSIntExit();       	 					//触发任务切换软中断
000012  f7fffffe          BL       OSIntExit
                  |L1.22|
;;;119    	}
;;;120    }
000016  bd10              POP      {r4,pc}
;;;121    #endif
                          ENDP

                  |L1.24|
                          DCD      OSRunning

                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;127    //SYSCLK:系统时钟
;;;128    void delay_init()
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130    #if SYSTEM_SUPPORT_OS  							//如果需要支持OS.
;;;131    	u32 reload;
;;;132    #endif
;;;133    	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);	//选择外部时钟  HCLK/8
000002  f06f0004          MVN      r0,#4
000006  f7fffffe          BL       SysTick_CLKSourceConfig
;;;134    	fac_us=SystemCoreClock/8000000;				//为系统时钟的1/8  
00000a  4810              LDR      r0,|L2.76|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  4910              LDR      r1,|L2.80|
000010  fbb0f0f1          UDIV     r0,r0,r1
000014  490f              LDR      r1,|L2.84|
000016  7008              STRB     r0,[r1,#0]
;;;135    #if SYSTEM_SUPPORT_OS  							//如果需要支持OS.
;;;136    	reload=SystemCoreClock/8000000;				//每秒钟的计数次数 单位为K	   
000018  480c              LDR      r0,|L2.76|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  490c              LDR      r1,|L2.80|
00001e  fbb0f4f1          UDIV     r4,r0,r1
;;;137    	reload*=1000000/delay_ostickspersec;		//根据delay_ostickspersec设定溢出时间
000022  f2413088          MOV      r0,#0x1388
000026  4344              MULS     r4,r0,r4
;;;138    												//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右	
;;;139    	fac_ms=1000/delay_ostickspersec;			//代表OS可以延时的最少单位	   
000028  2005              MOVS     r0,#5
00002a  490b              LDR      r1,|L2.88|
00002c  8008              STRH     r0,[r1,#0]
;;;140    
;;;141    	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
00002e  f04f20e0          MOV      r0,#0xe000e000
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400002          ORR      r0,r0,#2
000038  f04f21e0          MOV      r1,#0xe000e000
00003c  6108              STR      r0,[r1,#0x10]
;;;142    	SysTick->LOAD=reload; 						//每1/delay_ostickspersec秒中断一次	
00003e  4608              MOV      r0,r1
000040  6144              STR      r4,[r0,#0x14]
;;;143    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK    
000042  6900              LDR      r0,[r0,#0x10]
000044  f0400001          ORR      r0,r0,#1
000048  6108              STR      r0,[r1,#0x10]
;;;144    
;;;145    #else
;;;146    	fac_ms=(u16)fac_us*1000;					//非OS下,代表每个ms需要的systick时钟数   
;;;147    #endif
;;;148    }								    
00004a  bd10              POP      {r4,pc}
;;;149    
                          ENDP

                  |L2.76|
                          DCD      SystemCoreClock
                  |L2.80|
                          DCD      0x007a1200
                  |L2.84|
                          DCD      fac_us
                  |L2.88|
                          DCD      fac_ms

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;176    //nms:要延时的ms数
;;;177    void delay_ms(u16 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {	
000002  4604              MOV      r4,r0
;;;179    	if(delay_osrunning&&delay_osintnesting==0)	//如果OS已经在跑了,并且不是在中断里面(中断里面不能任务调度)	    
000004  480f              LDR      r0,|L3.68|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  b1a0              CBZ      r0,|L3.52|
00000a  480f              LDR      r0,|L3.72|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b988              CBNZ     r0,|L3.52|
;;;180    	{		 
;;;181    		if(nms>=fac_ms)							//延时的时间大于OS的最少时间周期 
000010  480e              LDR      r0,|L3.76|
000012  8800              LDRH     r0,[r0,#0]  ; fac_ms
000014  4284              CMP      r4,r0
000016  db06              BLT      |L3.38|
;;;182    		{ 
;;;183       			delay_ostimedly(nms/fac_ms);		//OS延时
000018  480c              LDR      r0,|L3.76|
00001a  8800              LDRH     r0,[r0,#0]  ; fac_ms
00001c  fb94f5f0          SDIV     r5,r4,r0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       delay_ostimedly
                  |L3.38|
;;;184    		}
;;;185    		nms%=fac_ms;							//OS已经无法提供这么小的延时了,采用普通方式延时    
000026  4809              LDR      r0,|L3.76|
000028  8800              LDRH     r0,[r0,#0]  ; fac_ms
00002a  fb94f1f0          SDIV     r1,r4,r0
00002e  fb004011          MLS      r0,r0,r1,r4
000032  b284              UXTH     r4,r0
                  |L3.52|
;;;186    	}
;;;187    	delay_us((u32)(nms*1000));					//普通方式延时  
000034  f44f717a          MOV      r1,#0x3e8
000038  fb04f001          MUL      r0,r4,r1
00003c  f7fffffe          BL       delay_us
;;;188    }
000040  bd70              POP      {r4-r6,pc}
;;;189    #else //不用OS时
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      OSRunning
                  |L3.72|
                          DCD      OSIntNesting
                  |L3.76|
                          DCD      fac_ms

                          AREA ||i.delay_osschedlock||, CODE, READONLY, ALIGN=1

                  delay_osschedlock PROC
;;;77     //us级延时时,关闭任务调度(防止打断us级延迟)
;;;78     void delay_osschedlock(void)
000000  b510              PUSH     {r4,lr}
;;;79     {
;;;80     #ifdef CPU_CFG_CRITICAL_METHOD   				//使用UCOSIII
;;;81     	OS_ERR err; 
;;;82     	OSSchedLock(&err);							//UCOSIII的方式,禁止调度，防止打断us延时
;;;83     #else											//否则UCOSII
;;;84     	OSSchedLock();								//UCOSII的方式,禁止调度，防止打断us延时
000002  f7fffffe          BL       OSSchedLock
;;;85     #endif
;;;86     }
000006  bd10              POP      {r4,pc}
;;;87     
                          ENDP


                          AREA ||i.delay_osschedunlock||, CODE, READONLY, ALIGN=1

                  delay_osschedunlock PROC
;;;88     //us级延时时,恢复任务调度
;;;89     void delay_osschedunlock(void)
000000  b510              PUSH     {r4,lr}
;;;90     {	
;;;91     #ifdef CPU_CFG_CRITICAL_METHOD   				//使用UCOSIII
;;;92     	OS_ERR err; 
;;;93     	OSSchedUnlock(&err);						//UCOSIII的方式,恢复调度
;;;94     #else											//否则UCOSII
;;;95     	OSSchedUnlock();							//UCOSII的方式,恢复调度
000002  f7fffffe          BL       OSSchedUnlock
;;;96     #endif
;;;97     }
000006  bd10              POP      {r4,pc}
;;;98     
                          ENDP


                          AREA ||i.delay_ostimedly||, CODE, READONLY, ALIGN=1

                  delay_ostimedly PROC
;;;100    //ticks:延时的节拍数
;;;101    void delay_ostimedly(u32 ticks)
000000  b510              PUSH     {r4,lr}
;;;102    {
000002  4604              MOV      r4,r0
;;;103    #ifdef CPU_CFG_CRITICAL_METHOD
;;;104    	OS_ERR err; 
;;;105    	OSTimeDly(ticks,OS_OPT_TIME_PERIODIC,&err);	//UCOSIII延时采用周期模式
;;;106    #else
;;;107    	OSTimeDly(ticks);							//UCOSII延时
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       OSTimeDly
;;;108    #endif 
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110     
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;152    //nus为要延时的us数.		    								   
;;;153    void delay_us(u32 nus)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;154    {		
000004  4607              MOV      r7,r0
;;;155    	u32 ticks;
;;;156    	u32 told,tnow,tcnt=0;
000006  2600              MOVS     r6,#0
;;;157    	u32 reload=SysTick->LOAD;					//LOAD的值	    	 
000008  f04f20e0          MOV      r0,#0xe000e000
00000c  f8d09014          LDR      r9,[r0,#0x14]
;;;158    	ticks=nus*fac_us; 							//需要的节拍数	  		 
000010  4811              LDR      r0,|L7.88|
000012  7800              LDRB     r0,[r0,#0]  ; fac_us
000014  fb07f800          MUL      r8,r7,r0
;;;159    	tcnt=0;
000018  bf00              NOP      
;;;160    	delay_osschedlock();						//阻止OS调度，防止打断us延时
00001a  f7fffffe          BL       delay_osschedlock
;;;161    	told=SysTick->VAL;        					//刚进入时的计数器值
00001e  f04f20e0          MOV      r0,#0xe000e000
000022  6985              LDR      r5,[r0,#0x18]
;;;162    	while(1)
000024  e011              B        |L7.74|
                  |L7.38|
;;;163    	{
;;;164    		tnow=SysTick->VAL;	
000026  f04f20e0          MOV      r0,#0xe000e000
00002a  6984              LDR      r4,[r0,#0x18]
;;;165    		if(tnow!=told)
00002c  42ac              CMP      r4,r5
00002e  d00c              BEQ      |L7.74|
;;;166    		{	    
;;;167    			if(tnow<told)tcnt+=told-tnow;		//这里注意一下SYSTICK是一个递减的计数器就可以了.
000030  42ac              CMP      r4,r5
000032  d202              BCS      |L7.58|
000034  1b28              SUBS     r0,r5,r4
000036  4406              ADD      r6,r6,r0
000038  e003              B        |L7.66|
                  |L7.58|
;;;168    			else tcnt+=reload-tnow+told;	    
00003a  eba90004          SUB      r0,r9,r4
00003e  4428              ADD      r0,r0,r5
000040  4406              ADD      r6,r6,r0
                  |L7.66|
;;;169    			told=tnow;
000042  4625              MOV      r5,r4
;;;170    			if(tcnt>=ticks)break;				//时间超过/等于要延迟的时间,则退出.
000044  4546              CMP      r6,r8
000046  d300              BCC      |L7.74|
000048  e000              B        |L7.76|
                  |L7.74|
00004a  e7ec              B        |L7.38|
                  |L7.76|
00004c  bf00              NOP      
;;;171    		}  
;;;172    	};
;;;173    	delay_osschedunlock();						//恢复OS调度									    
00004e  f7fffffe          BL       delay_osschedunlock
;;;174    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;175    //延时nms
                          ENDP

000056  0000              DCW      0x0000
                  |L7.88|
                          DCD      fac_us

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "SYSTEM\\delay\\delay.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_8c8ced7d____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_delay_c_8c8ced7d____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_8c8ced7d____REVSH|
#line 462
|__asm___7_delay_c_8c8ced7d____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_8c8ced7d____RRX|
#line 649
|__asm___7_delay_c_8c8ced7d____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
